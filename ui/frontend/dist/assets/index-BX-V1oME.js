var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys$1 = __getOwnPropNames(from), i = 0, n = keys$1.length, key; i < n; i++) {
		key = keys$1[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
(function polyfill() {
	const relList = document.createElement("link").relList;
	if (relList && relList.supports && relList.supports("modulepreload")) return;
	for (const link of document.querySelectorAll("link[rel=\"modulepreload\"]")) processPreload(link);
	new MutationObserver((mutations) => {
		for (const mutation of mutations) {
			if (mutation.type !== "childList") continue;
			for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
		}
	}).observe(document, {
		childList: true,
		subtree: true
	});
	function getFetchOpts(link) {
		const fetchOpts = {};
		if (link.integrity) fetchOpts.integrity = link.integrity;
		if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
		if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
		else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
		else fetchOpts.credentials = "same-origin";
		return fetchOpts;
	}
	function processPreload(link) {
		if (link.ep) return;
		link.ep = true;
		const fetchOpts = getFetchOpts(link);
		fetch(link.href, fetchOpts);
	}
})();
/**
* @license React
* react.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_react_production = /* @__PURE__ */ __commonJSMin(((exports) => {
	var REACT_ELEMENT_TYPE$2 = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE$2 = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE$2 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE$1 = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE$1 = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE$1 = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE$1 = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE$1 = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE$1 = Symbol.for("react.suspense"), REACT_MEMO_TYPE$1 = Symbol.for("react.memo"), REACT_LAZY_TYPE$1 = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE$1 = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL$1 = Symbol.iterator;
	function getIteratorFn$1(maybeIterable) {
		if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
		maybeIterable = MAYBE_ITERATOR_SYMBOL$1 && maybeIterable[MAYBE_ITERATOR_SYMBOL$1] || maybeIterable["@@iterator"];
		return "function" === typeof maybeIterable ? maybeIterable : null;
	}
	var ReactNoopUpdateQueue = {
		isMounted: function() {
			return !1;
		},
		enqueueForceUpdate: function() {},
		enqueueReplaceState: function() {},
		enqueueSetState: function() {}
	}, assign$1 = Object.assign, emptyObject = {};
	function Component(props, context, updater) {
		this.props = props;
		this.context = context;
		this.refs = emptyObject;
		this.updater = updater || ReactNoopUpdateQueue;
	}
	Component.prototype.isReactComponent = {};
	Component.prototype.setState = function(partialState, callback) {
		if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
		this.updater.enqueueSetState(this, partialState, callback, "setState");
	};
	Component.prototype.forceUpdate = function(callback) {
		this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
	};
	function ComponentDummy() {}
	ComponentDummy.prototype = Component.prototype;
	function PureComponent(props, context, updater) {
		this.props = props;
		this.context = context;
		this.refs = emptyObject;
		this.updater = updater || ReactNoopUpdateQueue;
	}
	var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
	pureComponentPrototype.constructor = PureComponent;
	assign$1(pureComponentPrototype, Component.prototype);
	pureComponentPrototype.isPureReactComponent = !0;
	var isArrayImpl$1 = Array.isArray;
	function noop$4() {}
	var ReactSharedInternals$2 = {
		H: null,
		A: null,
		T: null,
		S: null
	}, hasOwnProperty$1 = Object.prototype.hasOwnProperty;
	function ReactElement(type, key, props) {
		var refProp = props.ref;
		return {
			$$typeof: REACT_ELEMENT_TYPE$2,
			type,
			key,
			ref: void 0 !== refProp ? refProp : null,
			props
		};
	}
	function cloneAndReplaceKey(oldElement, newKey) {
		return ReactElement(oldElement.type, newKey, oldElement.props);
	}
	function isValidElement(object) {
		return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE$2;
	}
	function escape(key) {
		var escaperLookup = {
			"=": "=0",
			":": "=2"
		};
		return "$" + key.replace(/[=:]/g, function(match) {
			return escaperLookup[match];
		});
	}
	var userProvidedKeyEscapeRegex = /\/+/g;
	function getElementKey(element, index$3) {
		return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index$3.toString(36);
	}
	function resolveThenable(thenable) {
		switch (thenable.status) {
			case "fulfilled": return thenable.value;
			case "rejected": throw thenable.reason;
			default: switch ("string" === typeof thenable.status ? thenable.then(noop$4, noop$4) : (thenable.status = "pending", thenable.then(function(fulfilledValue) {
				"pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
			}, function(error) {
				"pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
			})), thenable.status) {
				case "fulfilled": return thenable.value;
				case "rejected": throw thenable.reason;
			}
		}
		throw thenable;
	}
	function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
		var type = typeof children;
		if ("undefined" === type || "boolean" === type) children = null;
		var invokeCallback = !1;
		if (null === children) invokeCallback = !0;
		else switch (type) {
			case "bigint":
			case "string":
			case "number":
				invokeCallback = !0;
				break;
			case "object": switch (children.$$typeof) {
				case REACT_ELEMENT_TYPE$2:
				case REACT_PORTAL_TYPE$2:
					invokeCallback = !0;
					break;
				case REACT_LAZY_TYPE$1: return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
			}
		}
		if (invokeCallback) return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl$1(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
			return c;
		})) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(callback, escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + invokeCallback)), array.push(callback)), 1;
		invokeCallback = 0;
		var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
		if (isArrayImpl$1(children)) for (var i = 0; i < children.length; i++) nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
		else if (i = getIteratorFn$1(children), "function" === typeof i) for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done;) nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
		else if ("object" === type) {
			if ("function" === typeof children.then) return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
			array = String(children);
			throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
		}
		return invokeCallback;
	}
	function mapChildren(children, func, context) {
		if (null == children) return children;
		var result = [], count$1 = 0;
		mapIntoArray(children, result, "", "", function(child) {
			return func.call(context, child, count$1++);
		});
		return result;
	}
	function lazyInitializer(payload) {
		if (-1 === payload._status) {
			var ctor = payload._result;
			ctor = ctor();
			ctor.then(function(moduleObject) {
				if (0 === payload._status || -1 === payload._status) payload._status = 1, payload._result = moduleObject;
			}, function(error) {
				if (0 === payload._status || -1 === payload._status) payload._status = 2, payload._result = error;
			});
			-1 === payload._status && (payload._status = 0, payload._result = ctor);
		}
		if (1 === payload._status) return payload._result.default;
		throw payload._result;
	}
	var reportGlobalError$1 = "function" === typeof reportError ? reportError : function(error) {
		if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
			var event = new window.ErrorEvent("error", {
				bubbles: !0,
				cancelable: !0,
				message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
				error
			});
			if (!window.dispatchEvent(event)) return;
		} else if ("object" === typeof process && "function" === typeof process.emit) {
			process.emit("uncaughtException", error);
			return;
		}
		console.error(error);
	}, Children$1 = {
		map: mapChildren,
		forEach: function(children, forEachFunc, forEachContext) {
			mapChildren(children, function() {
				forEachFunc.apply(this, arguments);
			}, forEachContext);
		},
		count: function(children) {
			var n = 0;
			mapChildren(children, function() {
				n++;
			});
			return n;
		},
		toArray: function(children) {
			return mapChildren(children, function(child) {
				return child;
			}) || [];
		},
		only: function(children) {
			if (!isValidElement(children)) throw Error("React.Children.only expected to receive a single React element child.");
			return children;
		}
	};
	exports.Activity = REACT_ACTIVITY_TYPE$1;
	exports.Children = Children$1;
	exports.Component = Component;
	exports.Fragment = REACT_FRAGMENT_TYPE$2;
	exports.Profiler = REACT_PROFILER_TYPE$1;
	exports.PureComponent = PureComponent;
	exports.StrictMode = REACT_STRICT_MODE_TYPE$1;
	exports.Suspense = REACT_SUSPENSE_TYPE$1;
	exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals$2;
	exports.__COMPILER_RUNTIME = {
		__proto__: null,
		c: function(size$3) {
			return ReactSharedInternals$2.H.useMemoCache(size$3);
		}
	};
	exports.cache = function(fn) {
		return function() {
			return fn.apply(null, arguments);
		};
	};
	exports.cacheSignal = function() {
		return null;
	};
	exports.cloneElement = function(element, config, children) {
		if (null === element || void 0 === element) throw Error("The argument must be a React element, but you passed " + element + ".");
		var props = assign$1({}, element.props), key = element.key;
		if (null != config) for (propName in void 0 !== config.key && (key = "" + config.key), config) !hasOwnProperty$1.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
		var propName = arguments.length - 2;
		if (1 === propName) props.children = children;
		else if (1 < propName) {
			for (var childArray = Array(propName), i = 0; i < propName; i++) childArray[i] = arguments[i + 2];
			props.children = childArray;
		}
		return ReactElement(element.type, key, props);
	};
	exports.createContext = function(defaultValue) {
		defaultValue = {
			$$typeof: REACT_CONTEXT_TYPE$1,
			_currentValue: defaultValue,
			_currentValue2: defaultValue,
			_threadCount: 0,
			Provider: null,
			Consumer: null
		};
		defaultValue.Provider = defaultValue;
		defaultValue.Consumer = {
			$$typeof: REACT_CONSUMER_TYPE$1,
			_context: defaultValue
		};
		return defaultValue;
	};
	exports.createElement = function(type, config, children) {
		var propName, props = {}, key = null;
		if (null != config) for (propName in void 0 !== config.key && (key = "" + config.key), config) hasOwnProperty$1.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
		var childrenLength = arguments.length - 2;
		if (1 === childrenLength) props.children = children;
		else if (1 < childrenLength) {
			for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++) childArray[i] = arguments[i + 2];
			props.children = childArray;
		}
		if (type && type.defaultProps) for (propName in childrenLength = type.defaultProps, childrenLength) void 0 === props[propName] && (props[propName] = childrenLength[propName]);
		return ReactElement(type, key, props);
	};
	exports.createRef = function() {
		return { current: null };
	};
	exports.forwardRef = function(render) {
		return {
			$$typeof: REACT_FORWARD_REF_TYPE$1,
			render
		};
	};
	exports.isValidElement = isValidElement;
	exports.lazy = function(ctor) {
		return {
			$$typeof: REACT_LAZY_TYPE$1,
			_payload: {
				_status: -1,
				_result: ctor
			},
			_init: lazyInitializer
		};
	};
	exports.memo = function(type, compare$1) {
		return {
			$$typeof: REACT_MEMO_TYPE$1,
			type,
			compare: void 0 === compare$1 ? null : compare$1
		};
	};
	exports.startTransition = function(scope) {
		var prevTransition = ReactSharedInternals$2.T, currentTransition = {};
		ReactSharedInternals$2.T = currentTransition;
		try {
			var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals$2.S;
			null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
			"object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop$4, reportGlobalError$1);
		} catch (error) {
			reportGlobalError$1(error);
		} finally {
			null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals$2.T = prevTransition;
		}
	};
	exports.unstable_useCacheRefresh = function() {
		return ReactSharedInternals$2.H.useCacheRefresh();
	};
	exports.use = function(usable) {
		return ReactSharedInternals$2.H.use(usable);
	};
	exports.useActionState = function(action, initialState, permalink) {
		return ReactSharedInternals$2.H.useActionState(action, initialState, permalink);
	};
	exports.useCallback = function(callback, deps) {
		return ReactSharedInternals$2.H.useCallback(callback, deps);
	};
	exports.useContext = function(Context) {
		return ReactSharedInternals$2.H.useContext(Context);
	};
	exports.useDebugValue = function() {};
	exports.useDeferredValue = function(value, initialValue) {
		return ReactSharedInternals$2.H.useDeferredValue(value, initialValue);
	};
	exports.useEffect = function(create$1, deps) {
		return ReactSharedInternals$2.H.useEffect(create$1, deps);
	};
	exports.useEffectEvent = function(callback) {
		return ReactSharedInternals$2.H.useEffectEvent(callback);
	};
	exports.useId = function() {
		return ReactSharedInternals$2.H.useId();
	};
	exports.useImperativeHandle = function(ref, create$1, deps) {
		return ReactSharedInternals$2.H.useImperativeHandle(ref, create$1, deps);
	};
	exports.useInsertionEffect = function(create$1, deps) {
		return ReactSharedInternals$2.H.useInsertionEffect(create$1, deps);
	};
	exports.useLayoutEffect = function(create$1, deps) {
		return ReactSharedInternals$2.H.useLayoutEffect(create$1, deps);
	};
	exports.useMemo = function(create$1, deps) {
		return ReactSharedInternals$2.H.useMemo(create$1, deps);
	};
	exports.useOptimistic = function(passthrough, reducer) {
		return ReactSharedInternals$2.H.useOptimistic(passthrough, reducer);
	};
	exports.useReducer = function(reducer, initialArg, init) {
		return ReactSharedInternals$2.H.useReducer(reducer, initialArg, init);
	};
	exports.useRef = function(initialValue) {
		return ReactSharedInternals$2.H.useRef(initialValue);
	};
	exports.useState = function(initialState) {
		return ReactSharedInternals$2.H.useState(initialState);
	};
	exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
		return ReactSharedInternals$2.H.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
	};
	exports.useTransition = function() {
		return ReactSharedInternals$2.H.useTransition();
	};
	exports.version = "19.2.3";
}));
var require_react = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_react_production();
}));
/**
* @license React
* scheduler.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_scheduler_production = /* @__PURE__ */ __commonJSMin(((exports) => {
	function push$1(heap, node) {
		var index$3 = heap.length;
		heap.push(node);
		a: for (; 0 < index$3;) {
			var parentIndex = index$3 - 1 >>> 1, parent = heap[parentIndex];
			if (0 < compare(parent, node)) heap[parentIndex] = node, heap[index$3] = parent, index$3 = parentIndex;
			else break a;
		}
	}
	function peek(heap) {
		return 0 === heap.length ? null : heap[0];
	}
	function pop$1(heap) {
		if (0 === heap.length) return null;
		var first = heap[0], last = heap.pop();
		if (last !== first) {
			heap[0] = last;
			a: for (var index$3 = 0, length = heap.length, halfLength = length >>> 1; index$3 < halfLength;) {
				var leftIndex = 2 * (index$3 + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
				if (0 > compare(left, last)) rightIndex < length && 0 > compare(right, left) ? (heap[index$3] = right, heap[rightIndex] = last, index$3 = rightIndex) : (heap[index$3] = left, heap[leftIndex] = last, index$3 = leftIndex);
				else if (rightIndex < length && 0 > compare(right, last)) heap[index$3] = right, heap[rightIndex] = last, index$3 = rightIndex;
				else break a;
			}
		}
		return first;
	}
	function compare(a, b) {
		var diff = a.sortIndex - b.sortIndex;
		return 0 !== diff ? diff : a.id - b.id;
	}
	exports.unstable_now = void 0;
	if ("object" === typeof performance && "function" === typeof performance.now) {
		var localPerformance = performance;
		exports.unstable_now = function() {
			return localPerformance.now();
		};
	} else {
		var localDate = Date, initialTime = localDate.now();
		exports.unstable_now = function() {
			return localDate.now() - initialTime;
		};
	}
	var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = !1, isHostCallbackScheduled = !1, isHostTimeoutScheduled = !1, needsPaint = !1, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
	function advanceTimers(currentTime) {
		for (var timer = peek(timerQueue); null !== timer;) {
			if (null === timer.callback) pop$1(timerQueue);
			else if (timer.startTime <= currentTime) pop$1(timerQueue), timer.sortIndex = timer.expirationTime, push$1(taskQueue, timer);
			else break;
			timer = peek(timerQueue);
		}
	}
	function handleTimeout(currentTime) {
		isHostTimeoutScheduled = !1;
		advanceTimers(currentTime);
		if (!isHostCallbackScheduled) if (null !== peek(taskQueue)) isHostCallbackScheduled = !0, isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline());
		else {
			var firstTimer = peek(timerQueue);
			null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
		}
	}
	var isMessageLoopRunning = !1, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
	function shouldYieldToHost() {
		return needsPaint ? !0 : exports.unstable_now() - startTime < frameInterval ? !1 : !0;
	}
	function performWorkUntilDeadline() {
		needsPaint = !1;
		if (isMessageLoopRunning) {
			var currentTime = exports.unstable_now();
			startTime = currentTime;
			var hasMoreWork = !0;
			try {
				a: {
					isHostCallbackScheduled = !1;
					isHostTimeoutScheduled && (isHostTimeoutScheduled = !1, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
					isPerformingWork = !0;
					var previousPriorityLevel = currentPriorityLevel;
					try {
						b: {
							advanceTimers(currentTime);
							for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost());) {
								var callback = currentTask.callback;
								if ("function" === typeof callback) {
									currentTask.callback = null;
									currentPriorityLevel = currentTask.priorityLevel;
									var continuationCallback = callback(currentTask.expirationTime <= currentTime);
									currentTime = exports.unstable_now();
									if ("function" === typeof continuationCallback) {
										currentTask.callback = continuationCallback;
										advanceTimers(currentTime);
										hasMoreWork = !0;
										break b;
									}
									currentTask === peek(taskQueue) && pop$1(taskQueue);
									advanceTimers(currentTime);
								} else pop$1(taskQueue);
								currentTask = peek(taskQueue);
							}
							if (null !== currentTask) hasMoreWork = !0;
							else {
								var firstTimer = peek(timerQueue);
								null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
								hasMoreWork = !1;
							}
						}
						break a;
					} finally {
						currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1;
					}
					hasMoreWork = void 0;
				}
			} finally {
				hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = !1;
			}
		}
	}
	var schedulePerformWorkUntilDeadline;
	if ("function" === typeof localSetImmediate) schedulePerformWorkUntilDeadline = function() {
		localSetImmediate(performWorkUntilDeadline);
	};
	else if ("undefined" !== typeof MessageChannel) {
		var channel = new MessageChannel(), port = channel.port2;
		channel.port1.onmessage = performWorkUntilDeadline;
		schedulePerformWorkUntilDeadline = function() {
			port.postMessage(null);
		};
	} else schedulePerformWorkUntilDeadline = function() {
		localSetTimeout(performWorkUntilDeadline, 0);
	};
	function requestHostTimeout(callback, ms) {
		taskTimeoutID = localSetTimeout(function() {
			callback(exports.unstable_now());
		}, ms);
	}
	exports.unstable_IdlePriority = 5;
	exports.unstable_ImmediatePriority = 1;
	exports.unstable_LowPriority = 4;
	exports.unstable_NormalPriority = 3;
	exports.unstable_Profiling = null;
	exports.unstable_UserBlockingPriority = 2;
	exports.unstable_cancelCallback = function(task) {
		task.callback = null;
	};
	exports.unstable_forceFrameRate = function(fps) {
		0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
	};
	exports.unstable_getCurrentPriorityLevel = function() {
		return currentPriorityLevel;
	};
	exports.unstable_next = function(eventHandler) {
		switch (currentPriorityLevel) {
			case 1:
			case 2:
			case 3:
				var priorityLevel = 3;
				break;
			default: priorityLevel = currentPriorityLevel;
		}
		var previousPriorityLevel = currentPriorityLevel;
		currentPriorityLevel = priorityLevel;
		try {
			return eventHandler();
		} finally {
			currentPriorityLevel = previousPriorityLevel;
		}
	};
	exports.unstable_requestPaint = function() {
		needsPaint = !0;
	};
	exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
		switch (priorityLevel) {
			case 1:
			case 2:
			case 3:
			case 4:
			case 5: break;
			default: priorityLevel = 3;
		}
		var previousPriorityLevel = currentPriorityLevel;
		currentPriorityLevel = priorityLevel;
		try {
			return eventHandler();
		} finally {
			currentPriorityLevel = previousPriorityLevel;
		}
	};
	exports.unstable_scheduleCallback = function(priorityLevel, callback, options$1) {
		var currentTime = exports.unstable_now();
		"object" === typeof options$1 && null !== options$1 ? (options$1 = options$1.delay, options$1 = "number" === typeof options$1 && 0 < options$1 ? currentTime + options$1 : currentTime) : options$1 = currentTime;
		switch (priorityLevel) {
			case 1:
				var timeout = -1;
				break;
			case 2:
				timeout = 250;
				break;
			case 5:
				timeout = 1073741823;
				break;
			case 4:
				timeout = 1e4;
				break;
			default: timeout = 5e3;
		}
		timeout = options$1 + timeout;
		priorityLevel = {
			id: taskIdCounter++,
			callback,
			priorityLevel,
			startTime: options$1,
			expirationTime: timeout,
			sortIndex: -1
		};
		options$1 > currentTime ? (priorityLevel.sortIndex = options$1, push$1(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = !0, requestHostTimeout(handleTimeout, options$1 - currentTime))) : (priorityLevel.sortIndex = timeout, push$1(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline())));
		return priorityLevel;
	};
	exports.unstable_shouldYield = shouldYieldToHost;
	exports.unstable_wrapCallback = function(callback) {
		var parentPriorityLevel = currentPriorityLevel;
		return function() {
			var previousPriorityLevel = currentPriorityLevel;
			currentPriorityLevel = parentPriorityLevel;
			try {
				return callback.apply(this, arguments);
			} finally {
				currentPriorityLevel = previousPriorityLevel;
			}
		};
	};
}));
var require_scheduler = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_scheduler_production();
}));
/**
* @license React
* react-dom.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_react_dom_production = /* @__PURE__ */ __commonJSMin(((exports) => {
	var React$7 = require_react();
	function formatProdErrorMessage$1(code) {
		var url = "https://react.dev/errors/" + code;
		if (1 < arguments.length) {
			url += "?args[]=" + encodeURIComponent(arguments[1]);
			for (var i = 2; i < arguments.length; i++) url += "&args[]=" + encodeURIComponent(arguments[i]);
		}
		return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
	}
	function noop$3() {}
	var Internals = {
		d: {
			f: noop$3,
			r: function() {
				throw Error(formatProdErrorMessage$1(522));
			},
			D: noop$3,
			C: noop$3,
			L: noop$3,
			m: noop$3,
			X: noop$3,
			S: noop$3,
			M: noop$3
		},
		p: 0,
		findDOMNode: null
	}, REACT_PORTAL_TYPE$1 = Symbol.for("react.portal");
	function createPortal$1(children, containerInfo, implementation) {
		var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
		return {
			$$typeof: REACT_PORTAL_TYPE$1,
			key: null == key ? null : "" + key,
			children,
			containerInfo,
			implementation
		};
	}
	var ReactSharedInternals$1 = React$7.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
	function getCrossOriginStringAs(as, input) {
		if ("font" === as) return "";
		if ("string" === typeof input) return "use-credentials" === input ? input : "";
	}
	exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
	exports.createPortal = function(children, container) {
		var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
		if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType) throw Error(formatProdErrorMessage$1(299));
		return createPortal$1(children, container, null, key);
	};
	exports.flushSync = function(fn) {
		var previousTransition = ReactSharedInternals$1.T, previousUpdatePriority = Internals.p;
		try {
			if (ReactSharedInternals$1.T = null, Internals.p = 2, fn) return fn();
		} finally {
			ReactSharedInternals$1.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
		}
	};
	exports.preconnect = function(href, options$1) {
		"string" === typeof href && (options$1 ? (options$1 = options$1.crossOrigin, options$1 = "string" === typeof options$1 ? "use-credentials" === options$1 ? options$1 : "" : void 0) : options$1 = null, Internals.d.C(href, options$1));
	};
	exports.prefetchDNS = function(href) {
		"string" === typeof href && Internals.d.D(href);
	};
	exports.preinit = function(href, options$1) {
		if ("string" === typeof href && options$1 && "string" === typeof options$1.as) {
			var as = options$1.as, crossOrigin = getCrossOriginStringAs(as, options$1.crossOrigin), integrity = "string" === typeof options$1.integrity ? options$1.integrity : void 0, fetchPriority = "string" === typeof options$1.fetchPriority ? options$1.fetchPriority : void 0;
			"style" === as ? Internals.d.S(href, "string" === typeof options$1.precedence ? options$1.precedence : void 0, {
				crossOrigin,
				integrity,
				fetchPriority
			}) : "script" === as && Internals.d.X(href, {
				crossOrigin,
				integrity,
				fetchPriority,
				nonce: "string" === typeof options$1.nonce ? options$1.nonce : void 0
			});
		}
	};
	exports.preinitModule = function(href, options$1) {
		if ("string" === typeof href) if ("object" === typeof options$1 && null !== options$1) {
			if (null == options$1.as || "script" === options$1.as) {
				var crossOrigin = getCrossOriginStringAs(options$1.as, options$1.crossOrigin);
				Internals.d.M(href, {
					crossOrigin,
					integrity: "string" === typeof options$1.integrity ? options$1.integrity : void 0,
					nonce: "string" === typeof options$1.nonce ? options$1.nonce : void 0
				});
			}
		} else options$1 ?? Internals.d.M(href);
	};
	exports.preload = function(href, options$1) {
		if ("string" === typeof href && "object" === typeof options$1 && null !== options$1 && "string" === typeof options$1.as) {
			var as = options$1.as, crossOrigin = getCrossOriginStringAs(as, options$1.crossOrigin);
			Internals.d.L(href, as, {
				crossOrigin,
				integrity: "string" === typeof options$1.integrity ? options$1.integrity : void 0,
				nonce: "string" === typeof options$1.nonce ? options$1.nonce : void 0,
				type: "string" === typeof options$1.type ? options$1.type : void 0,
				fetchPriority: "string" === typeof options$1.fetchPriority ? options$1.fetchPriority : void 0,
				referrerPolicy: "string" === typeof options$1.referrerPolicy ? options$1.referrerPolicy : void 0,
				imageSrcSet: "string" === typeof options$1.imageSrcSet ? options$1.imageSrcSet : void 0,
				imageSizes: "string" === typeof options$1.imageSizes ? options$1.imageSizes : void 0,
				media: "string" === typeof options$1.media ? options$1.media : void 0
			});
		}
	};
	exports.preloadModule = function(href, options$1) {
		if ("string" === typeof href) if (options$1) {
			var crossOrigin = getCrossOriginStringAs(options$1.as, options$1.crossOrigin);
			Internals.d.m(href, {
				as: "string" === typeof options$1.as && "script" !== options$1.as ? options$1.as : void 0,
				crossOrigin,
				integrity: "string" === typeof options$1.integrity ? options$1.integrity : void 0
			});
		} else Internals.d.m(href);
	};
	exports.requestFormReset = function(form) {
		Internals.d.r(form);
	};
	exports.unstable_batchedUpdates = function(fn, a) {
		return fn(a);
	};
	exports.useFormState = function(action, initialState, permalink) {
		return ReactSharedInternals$1.H.useFormState(action, initialState, permalink);
	};
	exports.useFormStatus = function() {
		return ReactSharedInternals$1.H.useHostTransitionStatus();
	};
	exports.version = "19.2.3";
}));
var require_react_dom = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function checkDCE$1() {
		if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") return;
		try {
			__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE$1);
		} catch (err) {
			console.error(err);
		}
	}
	checkDCE$1();
	module.exports = require_react_dom_production();
}));
/**
* @license React
* react-dom-client.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_react_dom_client_production = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scheduler = require_scheduler(), React$6 = require_react(), ReactDOM$1 = require_react_dom();
	function formatProdErrorMessage(code) {
		var url = "https://react.dev/errors/" + code;
		if (1 < arguments.length) {
			url += "?args[]=" + encodeURIComponent(arguments[1]);
			for (var i = 2; i < arguments.length; i++) url += "&args[]=" + encodeURIComponent(arguments[i]);
		}
		return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
	}
	function isValidContainer(node) {
		return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
	}
	function getNearestMountedFiber(fiber) {
		var node = fiber, nearestMounted = fiber;
		if (fiber.alternate) for (; node.return;) node = node.return;
		else {
			fiber = node;
			do
				node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
			while (fiber);
		}
		return 3 === node.tag ? nearestMounted : null;
	}
	function getSuspenseInstanceFromFiber(fiber) {
		if (13 === fiber.tag) {
			var suspenseState = fiber.memoizedState;
			null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
			if (null !== suspenseState) return suspenseState.dehydrated;
		}
		return null;
	}
	function getActivityInstanceFromFiber(fiber) {
		if (31 === fiber.tag) {
			var activityState = fiber.memoizedState;
			null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
			if (null !== activityState) return activityState.dehydrated;
		}
		return null;
	}
	function assertIsMounted(fiber) {
		if (getNearestMountedFiber(fiber) !== fiber) throw Error(formatProdErrorMessage(188));
	}
	function findCurrentFiberUsingSlowPath(fiber) {
		var alternate = fiber.alternate;
		if (!alternate) {
			alternate = getNearestMountedFiber(fiber);
			if (null === alternate) throw Error(formatProdErrorMessage(188));
			return alternate !== fiber ? null : fiber;
		}
		for (var a = fiber, b = alternate;;) {
			var parentA = a.return;
			if (null === parentA) break;
			var parentB = parentA.alternate;
			if (null === parentB) {
				b = parentA.return;
				if (null !== b) {
					a = b;
					continue;
				}
				break;
			}
			if (parentA.child === parentB.child) {
				for (parentB = parentA.child; parentB;) {
					if (parentB === a) return assertIsMounted(parentA), fiber;
					if (parentB === b) return assertIsMounted(parentA), alternate;
					parentB = parentB.sibling;
				}
				throw Error(formatProdErrorMessage(188));
			}
			if (a.return !== b.return) a = parentA, b = parentB;
			else {
				for (var didFindChild = !1, child$0 = parentA.child; child$0;) {
					if (child$0 === a) {
						didFindChild = !0;
						a = parentA;
						b = parentB;
						break;
					}
					if (child$0 === b) {
						didFindChild = !0;
						b = parentA;
						a = parentB;
						break;
					}
					child$0 = child$0.sibling;
				}
				if (!didFindChild) {
					for (child$0 = parentB.child; child$0;) {
						if (child$0 === a) {
							didFindChild = !0;
							a = parentB;
							b = parentA;
							break;
						}
						if (child$0 === b) {
							didFindChild = !0;
							b = parentB;
							a = parentA;
							break;
						}
						child$0 = child$0.sibling;
					}
					if (!didFindChild) throw Error(formatProdErrorMessage(189));
				}
			}
			if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
		}
		if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
		return a.stateNode.current === a ? fiber : alternate;
	}
	function findCurrentHostFiberImpl(node) {
		var tag = node.tag;
		if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
		for (node = node.child; null !== node;) {
			tag = findCurrentHostFiberImpl(node);
			if (null !== tag) return tag;
			node = node.sibling;
		}
		return null;
	}
	var assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE$1 = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE$1 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
	var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
	var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
	var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
	function getIteratorFn(maybeIterable) {
		if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
		maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
		return "function" === typeof maybeIterable ? maybeIterable : null;
	}
	var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
	function getComponentNameFromType(type) {
		if (null == type) return null;
		if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
		if ("string" === typeof type) return type;
		switch (type) {
			case REACT_FRAGMENT_TYPE$1: return "Fragment";
			case REACT_PROFILER_TYPE: return "Profiler";
			case REACT_STRICT_MODE_TYPE: return "StrictMode";
			case REACT_SUSPENSE_TYPE: return "Suspense";
			case REACT_SUSPENSE_LIST_TYPE: return "SuspenseList";
			case REACT_ACTIVITY_TYPE: return "Activity";
		}
		if ("object" === typeof type) switch (type.$$typeof) {
			case REACT_PORTAL_TYPE: return "Portal";
			case REACT_CONTEXT_TYPE: return type.displayName || "Context";
			case REACT_CONSUMER_TYPE: return (type._context.displayName || "Context") + ".Consumer";
			case REACT_FORWARD_REF_TYPE:
				var innerType = type.render;
				type = type.displayName;
				type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
				return type;
			case REACT_MEMO_TYPE: return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
			case REACT_LAZY_TYPE:
				innerType = type._payload;
				type = type._init;
				try {
					return getComponentNameFromType(type(innerType));
				} catch (x) {}
		}
		return null;
	}
	var isArrayImpl = Array.isArray, ReactSharedInternals = React$6.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM$1.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
		pending: !1,
		data: null,
		method: null,
		action: null
	}, valueStack = [], index$2 = -1;
	function createCursor(defaultValue) {
		return { current: defaultValue };
	}
	function pop(cursor) {
		0 > index$2 || (cursor.current = valueStack[index$2], valueStack[index$2] = null, index$2--);
	}
	function push(cursor, value) {
		index$2++;
		valueStack[index$2] = cursor.current;
		cursor.current = value;
	}
	var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
	function pushHostContainer(fiber, nextRootInstance) {
		push(rootInstanceStackCursor, nextRootInstance);
		push(contextFiberStackCursor, fiber);
		push(contextStackCursor, null);
		switch (nextRootInstance.nodeType) {
			case 9:
			case 11:
				fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
				break;
			default: if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI) nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
			else switch (fiber) {
				case "svg":
					fiber = 1;
					break;
				case "math":
					fiber = 2;
					break;
				default: fiber = 0;
			}
		}
		pop(contextStackCursor);
		push(contextStackCursor, fiber);
	}
	function popHostContainer() {
		pop(contextStackCursor);
		pop(contextFiberStackCursor);
		pop(rootInstanceStackCursor);
	}
	function pushHostContext(fiber) {
		null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
		var context = contextStackCursor.current;
		var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
		context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
	}
	function popHostContext(fiber) {
		contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
		hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
	}
	var prefix, suffix;
	function describeBuiltInComponentFrame(name) {
		if (void 0 === prefix) try {
			throw Error();
		} catch (x) {
			var match = x.stack.trim().match(/\n( *(at )?)/);
			prefix = match && match[1] || "";
			suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
		}
		return "\n" + prefix + name + suffix;
	}
	var reentry = !1;
	function describeNativeComponentFrame(fn, construct) {
		if (!fn || reentry) return "";
		reentry = !0;
		var previousPrepareStackTrace = Error.prepareStackTrace;
		Error.prepareStackTrace = void 0;
		try {
			var RunInRootFrame = { DetermineComponentFrameRoot: function() {
				try {
					if (construct) {
						var Fake = function() {
							throw Error();
						};
						Object.defineProperty(Fake.prototype, "props", { set: function() {
							throw Error();
						} });
						if ("object" === typeof Reflect && Reflect.construct) {
							try {
								Reflect.construct(Fake, []);
							} catch (x) {
								var control = x;
							}
							Reflect.construct(fn, [], Fake);
						} else {
							try {
								Fake.call();
							} catch (x$1) {
								control = x$1;
							}
							fn.call(Fake.prototype);
						}
					} else {
						try {
							throw Error();
						} catch (x$2) {
							control = x$2;
						}
						(Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {});
					}
				} catch (sample) {
					if (sample && control && "string" === typeof sample.stack) return [sample.stack, control.stack];
				}
				return [null, null];
			} };
			RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
			var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
			namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
			var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
			if (sampleStack && controlStack) {
				var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
				for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");) RunInRootFrame++;
				for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes("DetermineComponentFrameRoot");) namePropDescriptor++;
				if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length) for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];) namePropDescriptor--;
				for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--) if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
					if (1 !== RunInRootFrame || 1 !== namePropDescriptor) do
						if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
							var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
							fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
							return frame;
						}
					while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
					break;
				}
			}
		} finally {
			reentry = !1, Error.prepareStackTrace = previousPrepareStackTrace;
		}
		return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
	}
	function describeFiber(fiber, childFiber) {
		switch (fiber.tag) {
			case 26:
			case 27:
			case 5: return describeBuiltInComponentFrame(fiber.type);
			case 16: return describeBuiltInComponentFrame("Lazy");
			case 13: return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
			case 19: return describeBuiltInComponentFrame("SuspenseList");
			case 0:
			case 15: return describeNativeComponentFrame(fiber.type, !1);
			case 11: return describeNativeComponentFrame(fiber.type.render, !1);
			case 1: return describeNativeComponentFrame(fiber.type, !0);
			case 31: return describeBuiltInComponentFrame("Activity");
			default: return "";
		}
	}
	function getStackByFiberInDevAndProd(workInProgress$1) {
		try {
			var info = "", previous = null;
			do
				info += describeFiber(workInProgress$1, previous), previous = workInProgress$1, workInProgress$1 = workInProgress$1.return;
			while (workInProgress$1);
			return info;
		} catch (x) {
			return "\nError generating stack: " + x.message + "\n" + x.stack;
		}
	}
	var hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null;
	function setIsStrictModeForDevtools(newIsStrictMode) {
		"function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
		if (injectedHook && "function" === typeof injectedHook.setStrictMode) try {
			injectedHook.setStrictMode(rendererID, newIsStrictMode);
		} catch (err) {}
	}
	var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
	function clz32Fallback(x) {
		x >>>= 0;
		return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
	}
	var nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304;
	function getHighestPriorityLanes(lanes) {
		var pendingSyncLanes = lanes & 42;
		if (0 !== pendingSyncLanes) return pendingSyncLanes;
		switch (lanes & -lanes) {
			case 1: return 1;
			case 2: return 2;
			case 4: return 4;
			case 8: return 8;
			case 16: return 16;
			case 32: return 32;
			case 64: return 64;
			case 128: return 128;
			case 256:
			case 512:
			case 1024:
			case 2048:
			case 4096:
			case 8192:
			case 16384:
			case 32768:
			case 65536:
			case 131072: return lanes & 261888;
			case 262144:
			case 524288:
			case 1048576:
			case 2097152: return lanes & 3932160;
			case 4194304:
			case 8388608:
			case 16777216:
			case 33554432: return lanes & 62914560;
			case 67108864: return 67108864;
			case 134217728: return 134217728;
			case 268435456: return 268435456;
			case 536870912: return 536870912;
			case 1073741824: return 0;
			default: return lanes;
		}
	}
	function getNextLanes(root$1, wipLanes, rootHasPendingCommit) {
		var pendingLanes = root$1.pendingLanes;
		if (0 === pendingLanes) return 0;
		var nextLanes = 0, suspendedLanes = root$1.suspendedLanes, pingedLanes = root$1.pingedLanes;
		root$1 = root$1.warmLanes;
		var nonIdlePendingLanes = pendingLanes & 134217727;
		0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root$1, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root$1, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
		return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
	}
	function checkIfRootIsPrerendering(root$1, renderLanes$1) {
		return 0 === (root$1.pendingLanes & ~(root$1.suspendedLanes & ~root$1.pingedLanes) & renderLanes$1);
	}
	function computeExpirationTime(lane, currentTime) {
		switch (lane) {
			case 1:
			case 2:
			case 4:
			case 8:
			case 64: return currentTime + 250;
			case 16:
			case 32:
			case 128:
			case 256:
			case 512:
			case 1024:
			case 2048:
			case 4096:
			case 8192:
			case 16384:
			case 32768:
			case 65536:
			case 131072:
			case 262144:
			case 524288:
			case 1048576:
			case 2097152: return currentTime + 5e3;
			case 4194304:
			case 8388608:
			case 16777216:
			case 33554432: return -1;
			case 67108864:
			case 134217728:
			case 268435456:
			case 536870912:
			case 1073741824: return -1;
			default: return -1;
		}
	}
	function claimNextRetryLane() {
		var lane = nextRetryLane;
		nextRetryLane <<= 1;
		0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
		return lane;
	}
	function createLaneMap(initial) {
		for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
		return laneMap;
	}
	function markRootUpdated$1(root$1, updateLane) {
		root$1.pendingLanes |= updateLane;
		268435456 !== updateLane && (root$1.suspendedLanes = 0, root$1.pingedLanes = 0, root$1.warmLanes = 0);
	}
	function markRootFinished(root$1, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
		var previouslyPendingLanes = root$1.pendingLanes;
		root$1.pendingLanes = remainingLanes;
		root$1.suspendedLanes = 0;
		root$1.pingedLanes = 0;
		root$1.warmLanes = 0;
		root$1.expiredLanes &= remainingLanes;
		root$1.entangledLanes &= remainingLanes;
		root$1.errorRecoveryDisabledLanes &= remainingLanes;
		root$1.shellSuspendCounter = 0;
		var entanglements = root$1.entanglements, expirationTimes = root$1.expirationTimes, hiddenUpdates = root$1.hiddenUpdates;
		for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;) {
			var index$7 = 31 - clz32(remainingLanes), lane = 1 << index$7;
			entanglements[index$7] = 0;
			expirationTimes[index$7] = -1;
			var hiddenUpdatesForLane = hiddenUpdates[index$7];
			if (null !== hiddenUpdatesForLane) for (hiddenUpdates[index$7] = null, index$7 = 0; index$7 < hiddenUpdatesForLane.length; index$7++) {
				var update = hiddenUpdatesForLane[index$7];
				null !== update && (update.lane &= -536870913);
			}
			remainingLanes &= ~lane;
		}
		0 !== spawnedLane && markSpawnedDeferredLane(root$1, spawnedLane, 0);
		0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root$1.tag && (root$1.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
	}
	function markSpawnedDeferredLane(root$1, spawnedLane, entangledLanes) {
		root$1.pendingLanes |= spawnedLane;
		root$1.suspendedLanes &= ~spawnedLane;
		var spawnedLaneIndex = 31 - clz32(spawnedLane);
		root$1.entangledLanes |= spawnedLane;
		root$1.entanglements[spawnedLaneIndex] = root$1.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
	}
	function markRootEntangled(root$1, entangledLanes) {
		var rootEntangledLanes = root$1.entangledLanes |= entangledLanes;
		for (root$1 = root$1.entanglements; rootEntangledLanes;) {
			var index$8 = 31 - clz32(rootEntangledLanes), lane = 1 << index$8;
			lane & entangledLanes | root$1[index$8] & entangledLanes && (root$1[index$8] |= entangledLanes);
			rootEntangledLanes &= ~lane;
		}
	}
	function getBumpedLaneForHydration(root$1, renderLanes$1) {
		var renderLane = renderLanes$1 & -renderLanes$1;
		renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
		return 0 !== (renderLane & (root$1.suspendedLanes | renderLanes$1)) ? 0 : renderLane;
	}
	function getBumpedLaneForHydrationByLane(lane) {
		switch (lane) {
			case 2:
				lane = 1;
				break;
			case 8:
				lane = 4;
				break;
			case 32:
				lane = 16;
				break;
			case 256:
			case 512:
			case 1024:
			case 2048:
			case 4096:
			case 8192:
			case 16384:
			case 32768:
			case 65536:
			case 131072:
			case 262144:
			case 524288:
			case 1048576:
			case 2097152:
			case 4194304:
			case 8388608:
			case 16777216:
			case 33554432:
				lane = 128;
				break;
			case 268435456:
				lane = 134217728;
				break;
			default: lane = 0;
		}
		return lane;
	}
	function lanesToEventPriority(lanes) {
		lanes &= -lanes;
		return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
	}
	function resolveUpdatePriority() {
		var updatePriority = ReactDOMSharedInternals.p;
		if (0 !== updatePriority) return updatePriority;
		updatePriority = window.event;
		return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
	}
	function runWithPriority(priority, fn) {
		var previousPriority = ReactDOMSharedInternals.p;
		try {
			return ReactDOMSharedInternals.p = priority, fn();
		} finally {
			ReactDOMSharedInternals.p = previousPriority;
		}
	}
	var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
	function detachDeletedInstance(node) {
		delete node[internalInstanceKey];
		delete node[internalPropsKey];
		delete node[internalEventHandlersKey];
		delete node[internalEventHandlerListenersKey];
		delete node[internalEventHandlesSetKey];
	}
	function getClosestInstanceFromNode(targetNode) {
		var targetInst = targetNode[internalInstanceKey];
		if (targetInst) return targetInst;
		for (var parentNode = targetNode.parentNode; parentNode;) {
			if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
				parentNode = targetInst.alternate;
				if (null !== targetInst.child || null !== parentNode && null !== parentNode.child) for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode;) {
					if (parentNode = targetNode[internalInstanceKey]) return parentNode;
					targetNode = getParentHydrationBoundary(targetNode);
				}
				return targetInst;
			}
			targetNode = parentNode;
			parentNode = targetNode.parentNode;
		}
		return null;
	}
	function getInstanceFromNode(node) {
		if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
			var tag = node.tag;
			if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag) return node;
		}
		return null;
	}
	function getNodeFromInstance(inst) {
		var tag = inst.tag;
		if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
		throw Error(formatProdErrorMessage(33));
	}
	function getResourcesFromRoot(root$1) {
		var resources = root$1[internalRootNodeResourcesKey];
		resources || (resources = root$1[internalRootNodeResourcesKey] = {
			hoistableStyles: /* @__PURE__ */ new Map(),
			hoistableScripts: /* @__PURE__ */ new Map()
		});
		return resources;
	}
	function markNodeAsHoistable(node) {
		node[internalHoistableMarker] = !0;
	}
	var allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {};
	function registerTwoPhaseEvent(registrationName, dependencies) {
		registerDirectEvent(registrationName, dependencies);
		registerDirectEvent(registrationName + "Capture", dependencies);
	}
	function registerDirectEvent(registrationName, dependencies) {
		registrationNameDependencies[registrationName] = dependencies;
		for (registrationName = 0; registrationName < dependencies.length; registrationName++) allNativeEvents.add(dependencies[registrationName]);
	}
	var VALID_ATTRIBUTE_NAME_REGEX = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
	function isAttributeNameSafe(attributeName) {
		if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) return !0;
		if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;
		if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) return validatedAttributeNameCache[attributeName] = !0;
		illegalAttributeNameCache[attributeName] = !0;
		return !1;
	}
	function setValueForAttribute(node, name, value) {
		if (isAttributeNameSafe(name)) if (null === value) node.removeAttribute(name);
		else {
			switch (typeof value) {
				case "undefined":
				case "function":
				case "symbol":
					node.removeAttribute(name);
					return;
				case "boolean":
					var prefix$10 = name.toLowerCase().slice(0, 5);
					if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
						node.removeAttribute(name);
						return;
					}
			}
			node.setAttribute(name, "" + value);
		}
	}
	function setValueForKnownAttribute(node, name, value) {
		if (null === value) node.removeAttribute(name);
		else {
			switch (typeof value) {
				case "undefined":
				case "function":
				case "symbol":
				case "boolean":
					node.removeAttribute(name);
					return;
			}
			node.setAttribute(name, "" + value);
		}
	}
	function setValueForNamespacedAttribute(node, namespace, name, value) {
		if (null === value) node.removeAttribute(name);
		else {
			switch (typeof value) {
				case "undefined":
				case "function":
				case "symbol":
				case "boolean":
					node.removeAttribute(name);
					return;
			}
			node.setAttributeNS(namespace, name, "" + value);
		}
	}
	function getToStringValue(value) {
		switch (typeof value) {
			case "bigint":
			case "boolean":
			case "number":
			case "string":
			case "undefined": return value;
			case "object": return value;
			default: return "";
		}
	}
	function isCheckable(elem) {
		var type = elem.type;
		return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
	}
	function trackValueOnNode(node, valueField, currentValue) {
		var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
		if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
			var get = descriptor.get, set$1 = descriptor.set;
			Object.defineProperty(node, valueField, {
				configurable: !0,
				get: function() {
					return get.call(this);
				},
				set: function(value) {
					currentValue = "" + value;
					set$1.call(this, value);
				}
			});
			Object.defineProperty(node, valueField, { enumerable: descriptor.enumerable });
			return {
				getValue: function() {
					return currentValue;
				},
				setValue: function(value) {
					currentValue = "" + value;
				},
				stopTracking: function() {
					node._valueTracker = null;
					delete node[valueField];
				}
			};
		}
	}
	function track(node) {
		if (!node._valueTracker) {
			var valueField = isCheckable(node) ? "checked" : "value";
			node._valueTracker = trackValueOnNode(node, valueField, "" + node[valueField]);
		}
	}
	function updateValueIfChanged(node) {
		if (!node) return !1;
		var tracker = node._valueTracker;
		if (!tracker) return !0;
		var lastValue = tracker.getValue();
		var value = "";
		node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
		node = value;
		return node !== lastValue ? (tracker.setValue(node), !0) : !1;
	}
	function getActiveElement(doc) {
		doc = doc || ("undefined" !== typeof document ? document : void 0);
		if ("undefined" === typeof doc) return null;
		try {
			return doc.activeElement || doc.body;
		} catch (e) {
			return doc.body;
		}
	}
	var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
	function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
		return value.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function(ch) {
			return "\\" + ch.charCodeAt(0).toString(16) + " ";
		});
	}
	function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
		element.name = "";
		null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
		if (null != value) if ("number" === type) {
			if (0 === value && "" === element.value || element.value != value) element.value = "" + getToStringValue(value);
		} else element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
		else "submit" !== type && "reset" !== type || element.removeAttribute("value");
		null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
		null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
		null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
		null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
	}
	function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating$1) {
		null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
		if (null != value || null != defaultValue) {
			if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
				track(element);
				return;
			}
			defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
			value = null != value ? "" + getToStringValue(value) : defaultValue;
			isHydrating$1 || value === element.value || (element.value = value);
			element.defaultValue = value;
		}
		checked = null != checked ? checked : defaultChecked;
		checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
		element.checked = isHydrating$1 ? element.checked : !!checked;
		element.defaultChecked = !!checked;
		null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
		track(element);
	}
	function setDefaultValue(node, type, value) {
		"number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
	}
	function updateOptions(node, multiple, propValue, setDefaultSelected) {
		node = node.options;
		if (multiple) {
			multiple = {};
			for (var i = 0; i < propValue.length; i++) multiple["$" + propValue[i]] = !0;
			for (propValue = 0; propValue < node.length; propValue++) i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = !0);
		} else {
			propValue = "" + getToStringValue(propValue);
			multiple = null;
			for (i = 0; i < node.length; i++) {
				if (node[i].value === propValue) {
					node[i].selected = !0;
					setDefaultSelected && (node[i].defaultSelected = !0);
					return;
				}
				null !== multiple || node[i].disabled || (multiple = node[i]);
			}
			null !== multiple && (multiple.selected = !0);
		}
	}
	function updateTextarea(element, value, defaultValue) {
		if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
			element.defaultValue !== value && (element.defaultValue = value);
			return;
		}
		element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
	}
	function initTextarea(element, value, defaultValue, children) {
		if (null == value) {
			if (null != children) {
				if (null != defaultValue) throw Error(formatProdErrorMessage(92));
				if (isArrayImpl(children)) {
					if (1 < children.length) throw Error(formatProdErrorMessage(93));
					children = children[0];
				}
				defaultValue = children;
			}
			defaultValue ??= "";
			value = defaultValue;
		}
		defaultValue = getToStringValue(value);
		element.defaultValue = defaultValue;
		children = element.textContent;
		children === defaultValue && "" !== children && null !== children && (element.value = children);
		track(element);
	}
	function setTextContent(node, text) {
		if (text) {
			var firstChild = node.firstChild;
			if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
				firstChild.nodeValue = text;
				return;
			}
		}
		node.textContent = text;
	}
	var unitlessNumbers = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
	function setValueForStyle(style$1, styleName, value) {
		var isCustomProperty = 0 === styleName.indexOf("--");
		null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style$1.setProperty(styleName, "") : "float" === styleName ? style$1.cssFloat = "" : style$1[styleName] = "" : isCustomProperty ? style$1.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style$1.cssFloat = value : style$1[styleName] = ("" + value).trim() : style$1[styleName] = value + "px";
	}
	function setValueForStyles(node, styles, prevStyles) {
		if (null != styles && "object" !== typeof styles) throw Error(formatProdErrorMessage(62));
		node = node.style;
		if (null != prevStyles) {
			for (var styleName in prevStyles) !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
			for (var styleName$16 in styles) styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
		} else for (var styleName$17 in styles) styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
	}
	function isCustomElement(tagName) {
		if (-1 === tagName.indexOf("-")) return !1;
		switch (tagName) {
			case "annotation-xml":
			case "color-profile":
			case "font-face":
			case "font-face-src":
			case "font-face-uri":
			case "font-face-format":
			case "font-face-name":
			case "missing-glyph": return !1;
			default: return !0;
		}
	}
	var aliases = new Map([
		["acceptCharset", "accept-charset"],
		["htmlFor", "for"],
		["httpEquiv", "http-equiv"],
		["crossOrigin", "crossorigin"],
		["accentHeight", "accent-height"],
		["alignmentBaseline", "alignment-baseline"],
		["arabicForm", "arabic-form"],
		["baselineShift", "baseline-shift"],
		["capHeight", "cap-height"],
		["clipPath", "clip-path"],
		["clipRule", "clip-rule"],
		["colorInterpolation", "color-interpolation"],
		["colorInterpolationFilters", "color-interpolation-filters"],
		["colorProfile", "color-profile"],
		["colorRendering", "color-rendering"],
		["dominantBaseline", "dominant-baseline"],
		["enableBackground", "enable-background"],
		["fillOpacity", "fill-opacity"],
		["fillRule", "fill-rule"],
		["floodColor", "flood-color"],
		["floodOpacity", "flood-opacity"],
		["fontFamily", "font-family"],
		["fontSize", "font-size"],
		["fontSizeAdjust", "font-size-adjust"],
		["fontStretch", "font-stretch"],
		["fontStyle", "font-style"],
		["fontVariant", "font-variant"],
		["fontWeight", "font-weight"],
		["glyphName", "glyph-name"],
		["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
		["glyphOrientationVertical", "glyph-orientation-vertical"],
		["horizAdvX", "horiz-adv-x"],
		["horizOriginX", "horiz-origin-x"],
		["imageRendering", "image-rendering"],
		["letterSpacing", "letter-spacing"],
		["lightingColor", "lighting-color"],
		["markerEnd", "marker-end"],
		["markerMid", "marker-mid"],
		["markerStart", "marker-start"],
		["overlinePosition", "overline-position"],
		["overlineThickness", "overline-thickness"],
		["paintOrder", "paint-order"],
		["panose-1", "panose-1"],
		["pointerEvents", "pointer-events"],
		["renderingIntent", "rendering-intent"],
		["shapeRendering", "shape-rendering"],
		["stopColor", "stop-color"],
		["stopOpacity", "stop-opacity"],
		["strikethroughPosition", "strikethrough-position"],
		["strikethroughThickness", "strikethrough-thickness"],
		["strokeDasharray", "stroke-dasharray"],
		["strokeDashoffset", "stroke-dashoffset"],
		["strokeLinecap", "stroke-linecap"],
		["strokeLinejoin", "stroke-linejoin"],
		["strokeMiterlimit", "stroke-miterlimit"],
		["strokeOpacity", "stroke-opacity"],
		["strokeWidth", "stroke-width"],
		["textAnchor", "text-anchor"],
		["textDecoration", "text-decoration"],
		["textRendering", "text-rendering"],
		["transformOrigin", "transform-origin"],
		["underlinePosition", "underline-position"],
		["underlineThickness", "underline-thickness"],
		["unicodeBidi", "unicode-bidi"],
		["unicodeRange", "unicode-range"],
		["unitsPerEm", "units-per-em"],
		["vAlphabetic", "v-alphabetic"],
		["vHanging", "v-hanging"],
		["vIdeographic", "v-ideographic"],
		["vMathematical", "v-mathematical"],
		["vectorEffect", "vector-effect"],
		["vertAdvY", "vert-adv-y"],
		["vertOriginX", "vert-origin-x"],
		["vertOriginY", "vert-origin-y"],
		["wordSpacing", "word-spacing"],
		["writingMode", "writing-mode"],
		["xmlnsXlink", "xmlns:xlink"],
		["xHeight", "x-height"]
	]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
	function sanitizeURL(url) {
		return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
	}
	function noop$1$1() {}
	var currentReplayingEvent = null;
	function getEventTarget(nativeEvent) {
		nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
		nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
		return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
	}
	var restoreTarget = null, restoreQueue = null;
	function restoreStateOfTarget(target) {
		var internalInstance = getInstanceFromNode(target);
		if (internalInstance && (target = internalInstance.stateNode)) {
			var props = target[internalPropsKey] || null;
			a: switch (target = internalInstance.stateNode, internalInstance.type) {
				case "input":
					updateInput(target, props.value, props.defaultValue, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name);
					internalInstance = props.name;
					if ("radio" === props.type && null != internalInstance) {
						for (props = target; props.parentNode;) props = props.parentNode;
						props = props.querySelectorAll("input[name=\"" + escapeSelectorAttributeValueInsideDoubleQuotes("" + internalInstance) + "\"][type=\"radio\"]");
						for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
							var otherNode = props[internalInstance];
							if (otherNode !== target && otherNode.form === target.form) {
								var otherProps = otherNode[internalPropsKey] || null;
								if (!otherProps) throw Error(formatProdErrorMessage(90));
								updateInput(otherNode, otherProps.value, otherProps.defaultValue, otherProps.defaultValue, otherProps.checked, otherProps.defaultChecked, otherProps.type, otherProps.name);
							}
						}
						for (internalInstance = 0; internalInstance < props.length; internalInstance++) otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
					}
					break a;
				case "textarea":
					updateTextarea(target, props.value, props.defaultValue);
					break a;
				case "select": internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, !1);
			}
		}
	}
	var isInsideEventHandler = !1;
	function batchedUpdates$1(fn, a, b) {
		if (isInsideEventHandler) return fn(a, b);
		isInsideEventHandler = !0;
		try {
			return fn(a);
		} finally {
			if (isInsideEventHandler = !1, null !== restoreTarget || null !== restoreQueue) {
				if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn)) for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
			}
		}
	}
	function getListener(inst, registrationName) {
		var stateNode = inst.stateNode;
		if (null === stateNode) return null;
		var props = stateNode[internalPropsKey] || null;
		if (null === props) return null;
		stateNode = props[registrationName];
		a: switch (registrationName) {
			case "onClick":
			case "onClickCapture":
			case "onDoubleClick":
			case "onDoubleClickCapture":
			case "onMouseDown":
			case "onMouseDownCapture":
			case "onMouseMove":
			case "onMouseMoveCapture":
			case "onMouseUp":
			case "onMouseUpCapture":
			case "onMouseEnter":
				(props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
				inst = !props;
				break a;
			default: inst = !1;
		}
		if (inst) return null;
		if (stateNode && "function" !== typeof stateNode) throw Error(formatProdErrorMessage(231, registrationName, typeof stateNode));
		return stateNode;
	}
	var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = !1;
	if (canUseDOM) try {
		var options = {};
		Object.defineProperty(options, "passive", { get: function() {
			passiveBrowserEventsSupported = !0;
		} });
		window.addEventListener("test", options, options);
		window.removeEventListener("test", options, options);
	} catch (e) {
		passiveBrowserEventsSupported = !1;
	}
	var root = null, startText = null, fallbackText = null;
	function getData() {
		if (fallbackText) return fallbackText;
		var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
		for (start = 0; start < startLength && startValue[start] === endValue[start]; start++);
		var minEnd = startLength - start;
		for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++);
		return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
	}
	function getEventCharCode(nativeEvent) {
		var keyCode = nativeEvent.keyCode;
		"charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
		10 === nativeEvent && (nativeEvent = 13);
		return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
	}
	function functionThatReturnsTrue() {
		return !0;
	}
	function functionThatReturnsFalse() {
		return !1;
	}
	function createSyntheticEvent(Interface) {
		function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
			this._reactName = reactName;
			this._targetInst = targetInst;
			this.type = reactEventType;
			this.nativeEvent = nativeEvent;
			this.target = nativeEventTarget;
			this.currentTarget = null;
			for (var propName in Interface) Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
			this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : !1 === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
			this.isPropagationStopped = functionThatReturnsFalse;
			return this;
		}
		assign(SyntheticBaseEvent.prototype, {
			preventDefault: function() {
				this.defaultPrevented = !0;
				var event = this.nativeEvent;
				event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = !1), this.isDefaultPrevented = functionThatReturnsTrue);
			},
			stopPropagation: function() {
				var event = this.nativeEvent;
				event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = !0), this.isPropagationStopped = functionThatReturnsTrue);
			},
			persist: function() {},
			isPersistent: functionThatReturnsTrue
		});
		return SyntheticBaseEvent;
	}
	var EventInterface = {
		eventPhase: 0,
		bubbles: 0,
		cancelable: 0,
		timeStamp: function(event) {
			return event.timeStamp || Date.now();
		},
		defaultPrevented: 0,
		isTrusted: 0
	}, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, {
		view: 0,
		detail: 0
	}), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
		screenX: 0,
		screenY: 0,
		clientX: 0,
		clientY: 0,
		pageX: 0,
		pageY: 0,
		ctrlKey: 0,
		shiftKey: 0,
		altKey: 0,
		metaKey: 0,
		getModifierState: getEventModifierState,
		button: 0,
		buttons: 0,
		relatedTarget: function(event) {
			return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
		},
		movementX: function(event) {
			if ("movementX" in event) return event.movementX;
			event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
			return lastMovementX;
		},
		movementY: function(event) {
			return "movementY" in event ? event.movementY : lastMovementY;
		}
	}), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), SyntheticDragEvent = createSyntheticEvent(assign({}, MouseEventInterface, { dataTransfer: 0 })), SyntheticFocusEvent = createSyntheticEvent(assign({}, UIEventInterface, { relatedTarget: 0 })), SyntheticAnimationEvent = createSyntheticEvent(assign({}, EventInterface, {
		animationName: 0,
		elapsedTime: 0,
		pseudoElement: 0
	})), SyntheticClipboardEvent = createSyntheticEvent(assign({}, EventInterface, { clipboardData: function(event) {
		return "clipboardData" in event ? event.clipboardData : window.clipboardData;
	} })), SyntheticCompositionEvent = createSyntheticEvent(assign({}, EventInterface, { data: 0 })), normalizeKey = {
		Esc: "Escape",
		Spacebar: " ",
		Left: "ArrowLeft",
		Up: "ArrowUp",
		Right: "ArrowRight",
		Down: "ArrowDown",
		Del: "Delete",
		Win: "OS",
		Menu: "ContextMenu",
		Apps: "ContextMenu",
		Scroll: "ScrollLock",
		MozPrintableKey: "Unidentified"
	}, translateToKey = {
		8: "Backspace",
		9: "Tab",
		12: "Clear",
		13: "Enter",
		16: "Shift",
		17: "Control",
		18: "Alt",
		19: "Pause",
		20: "CapsLock",
		27: "Escape",
		32: " ",
		33: "PageUp",
		34: "PageDown",
		35: "End",
		36: "Home",
		37: "ArrowLeft",
		38: "ArrowUp",
		39: "ArrowRight",
		40: "ArrowDown",
		45: "Insert",
		46: "Delete",
		112: "F1",
		113: "F2",
		114: "F3",
		115: "F4",
		116: "F5",
		117: "F6",
		118: "F7",
		119: "F8",
		120: "F9",
		121: "F10",
		122: "F11",
		123: "F12",
		144: "NumLock",
		145: "ScrollLock",
		224: "Meta"
	}, modifierKeyToProp = {
		Alt: "altKey",
		Control: "ctrlKey",
		Meta: "metaKey",
		Shift: "shiftKey"
	};
	function modifierStateGetter(keyArg) {
		var nativeEvent = this.nativeEvent;
		return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : !1;
	}
	function getEventModifierState() {
		return modifierStateGetter;
	}
	var SyntheticKeyboardEvent = createSyntheticEvent(assign({}, UIEventInterface, {
		key: function(nativeEvent) {
			if (nativeEvent.key) {
				var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
				if ("Unidentified" !== key) return key;
			}
			return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
		},
		code: 0,
		location: 0,
		ctrlKey: 0,
		shiftKey: 0,
		altKey: 0,
		metaKey: 0,
		repeat: 0,
		locale: 0,
		getModifierState: getEventModifierState,
		charCode: function(event) {
			return "keypress" === event.type ? getEventCharCode(event) : 0;
		},
		keyCode: function(event) {
			return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
		},
		which: function(event) {
			return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
		}
	})), SyntheticPointerEvent = createSyntheticEvent(assign({}, MouseEventInterface, {
		pointerId: 0,
		width: 0,
		height: 0,
		pressure: 0,
		tangentialPressure: 0,
		tiltX: 0,
		tiltY: 0,
		twist: 0,
		pointerType: 0,
		isPrimary: 0
	})), SyntheticTouchEvent = createSyntheticEvent(assign({}, UIEventInterface, {
		touches: 0,
		targetTouches: 0,
		changedTouches: 0,
		altKey: 0,
		metaKey: 0,
		ctrlKey: 0,
		shiftKey: 0,
		getModifierState: getEventModifierState
	})), SyntheticTransitionEvent = createSyntheticEvent(assign({}, EventInterface, {
		propertyName: 0,
		elapsedTime: 0,
		pseudoElement: 0
	})), SyntheticWheelEvent = createSyntheticEvent(assign({}, MouseEventInterface, {
		deltaX: function(event) {
			return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
		},
		deltaY: function(event) {
			return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
		},
		deltaZ: 0,
		deltaMode: 0
	})), SyntheticToggleEvent = createSyntheticEvent(assign({}, EventInterface, {
		newState: 0,
		oldState: 0
	})), END_KEYCODES = [
		9,
		13,
		27,
		32
	], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
	canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
	var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = !1;
	function isFallbackCompositionEnd(domEventName, nativeEvent) {
		switch (domEventName) {
			case "keyup": return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
			case "keydown": return 229 !== nativeEvent.keyCode;
			case "keypress":
			case "mousedown":
			case "focusout": return !0;
			default: return !1;
		}
	}
	function getDataFromCustomEvent(nativeEvent) {
		nativeEvent = nativeEvent.detail;
		return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
	}
	var isComposing = !1;
	function getNativeBeforeInputChars(domEventName, nativeEvent) {
		switch (domEventName) {
			case "compositionend": return getDataFromCustomEvent(nativeEvent);
			case "keypress":
				if (32 !== nativeEvent.which) return null;
				hasSpaceKeypress = !0;
				return SPACEBAR_CHAR;
			case "textInput": return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
			default: return null;
		}
	}
	function getFallbackBeforeInputChars(domEventName, nativeEvent) {
		if (isComposing) return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = !1, domEventName) : null;
		switch (domEventName) {
			case "paste": return null;
			case "keypress":
				if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
					if (nativeEvent.char && 1 < nativeEvent.char.length) return nativeEvent.char;
					if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
				}
				return null;
			case "compositionend": return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
			default: return null;
		}
	}
	var supportedInputTypes = {
		color: !0,
		date: !0,
		datetime: !0,
		"datetime-local": !0,
		email: !0,
		month: !0,
		number: !0,
		password: !0,
		range: !0,
		search: !0,
		tel: !0,
		text: !0,
		time: !0,
		url: !0,
		week: !0
	};
	function isTextInputElement(elem) {
		var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
		return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? !0 : !1;
	}
	function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
		restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
		inst = accumulateTwoPhaseListeners(inst, "onChange");
		0 < inst.length && (nativeEvent = new SyntheticEvent("onChange", "change", null, nativeEvent, target), dispatchQueue.push({
			event: nativeEvent,
			listeners: inst
		}));
	}
	var activeElement$1 = null, activeElementInst$1 = null;
	function runEventInBatch(dispatchQueue) {
		processDispatchQueue(dispatchQueue, 0);
	}
	function getInstIfValueChanged(targetInst) {
		if (updateValueIfChanged(getNodeFromInstance(targetInst))) return targetInst;
	}
	function getTargetInstForChangeEvent(domEventName, targetInst) {
		if ("change" === domEventName) return targetInst;
	}
	var isInputEventSupported = !1;
	if (canUseDOM) {
		var JSCompiler_inline_result$jscomp$286;
		if (canUseDOM) {
			var isSupported$jscomp$inline_427 = "oninput" in document;
			if (!isSupported$jscomp$inline_427) {
				var element$jscomp$inline_428 = document.createElement("div");
				element$jscomp$inline_428.setAttribute("oninput", "return;");
				isSupported$jscomp$inline_427 = "function" === typeof element$jscomp$inline_428.oninput;
			}
			JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
		} else JSCompiler_inline_result$jscomp$286 = !1;
		isInputEventSupported = JSCompiler_inline_result$jscomp$286 && (!document.documentMode || 9 < document.documentMode);
	}
	function stopWatchingForValueChange() {
		activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
	}
	function handlePropertyChange(nativeEvent) {
		if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
			var dispatchQueue = [];
			createAndAccumulateChangeEvent(dispatchQueue, activeElementInst$1, nativeEvent, getEventTarget(nativeEvent));
			batchedUpdates$1(runEventInBatch, dispatchQueue);
		}
	}
	function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
		"focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
	}
	function getTargetInstForInputEventPolyfill(domEventName) {
		if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName) return getInstIfValueChanged(activeElementInst$1);
	}
	function getTargetInstForClickEvent(domEventName, targetInst) {
		if ("click" === domEventName) return getInstIfValueChanged(targetInst);
	}
	function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
		if ("input" === domEventName || "change" === domEventName) return getInstIfValueChanged(targetInst);
	}
	function is(x, y) {
		return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
	}
	var objectIs = "function" === typeof Object.is ? Object.is : is;
	function shallowEqual(objA, objB) {
		if (objectIs(objA, objB)) return !0;
		if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB) return !1;
		var keysA = Object.keys(objA), keysB = Object.keys(objB);
		if (keysA.length !== keysB.length) return !1;
		for (keysB = 0; keysB < keysA.length; keysB++) {
			var currentKey = keysA[keysB];
			if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return !1;
		}
		return !0;
	}
	function getLeafNode(node) {
		for (; node && node.firstChild;) node = node.firstChild;
		return node;
	}
	function getNodeForCharacterOffset(root$1, offset$3) {
		var node = getLeafNode(root$1);
		root$1 = 0;
		for (var nodeEnd; node;) {
			if (3 === node.nodeType) {
				nodeEnd = root$1 + node.textContent.length;
				if (root$1 <= offset$3 && nodeEnd >= offset$3) return {
					node,
					offset: offset$3 - root$1
				};
				root$1 = nodeEnd;
			}
			a: {
				for (; node;) {
					if (node.nextSibling) {
						node = node.nextSibling;
						break a;
					}
					node = node.parentNode;
				}
				node = void 0;
			}
			node = getLeafNode(node);
		}
	}
	function containsNode(outerNode, innerNode) {
		return outerNode && innerNode ? outerNode === innerNode ? !0 : outerNode && 3 === outerNode.nodeType ? !1 : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : !1 : !1;
	}
	function getActiveElementDeep(containerInfo) {
		containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
		for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement;) {
			try {
				var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
			} catch (err) {
				JSCompiler_inline_result = !1;
			}
			if (JSCompiler_inline_result) containerInfo = element.contentWindow;
			else break;
			element = getActiveElement(containerInfo.document);
		}
		return element;
	}
	function hasSelectionCapabilities(elem) {
		var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
		return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
	}
	var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement$2 = null, activeElementInst = null, lastSelection = null, mouseDown = !1;
	function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
		var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
		mouseDown || null == activeElement$2 || activeElement$2 !== getActiveElement(doc) || (doc = activeElement$2, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = {
			start: doc.selectionStart,
			end: doc.selectionEnd
		} : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
			anchorNode: doc.anchorNode,
			anchorOffset: doc.anchorOffset,
			focusNode: doc.focusNode,
			focusOffset: doc.focusOffset
		}), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
			event: nativeEvent,
			listeners: doc
		}), nativeEvent.target = activeElement$2)));
	}
	function makePrefixMap(styleProp, eventName) {
		var prefixes = {};
		prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
		prefixes["Webkit" + styleProp] = "webkit" + eventName;
		prefixes["Moz" + styleProp] = "moz" + eventName;
		return prefixes;
	}
	var vendorPrefixes = {
		animationend: makePrefixMap("Animation", "AnimationEnd"),
		animationiteration: makePrefixMap("Animation", "AnimationIteration"),
		animationstart: makePrefixMap("Animation", "AnimationStart"),
		transitionrun: makePrefixMap("Transition", "TransitionRun"),
		transitionstart: makePrefixMap("Transition", "TransitionStart"),
		transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
		transitionend: makePrefixMap("Transition", "TransitionEnd")
	}, prefixedEventNames = {}, style = {};
	canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
	function getVendorPrefixedEventName(eventName) {
		if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
		if (!vendorPrefixes[eventName]) return eventName;
		var prefixMap = vendorPrefixes[eventName], styleProp;
		for (styleProp in prefixMap) if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) return prefixedEventNames[eventName] = prefixMap[styleProp];
		return eventName;
	}
	var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
	simpleEventPluginEvents.push("scrollEnd");
	function registerSimpleEvent(domEventName, reactName) {
		topLevelEventsToReactNames.set(domEventName, reactName);
		registerTwoPhaseEvent(reactName, [domEventName]);
	}
	var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
		if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
			var event = new window.ErrorEvent("error", {
				bubbles: !0,
				cancelable: !0,
				message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
				error
			});
			if (!window.dispatchEvent(event)) return;
		} else if ("object" === typeof process && "function" === typeof process.emit) {
			process.emit("uncaughtException", error);
			return;
		}
		console.error(error);
	}, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
	function finishQueueingConcurrentUpdates() {
		for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex;) {
			var fiber = concurrentQueues[i];
			concurrentQueues[i++] = null;
			var queue = concurrentQueues[i];
			concurrentQueues[i++] = null;
			var update = concurrentQueues[i];
			concurrentQueues[i++] = null;
			var lane = concurrentQueues[i];
			concurrentQueues[i++] = null;
			if (null !== queue && null !== update) {
				var pending = queue.pending;
				null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
				queue.pending = update;
			}
			0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
		}
	}
	function enqueueUpdate$1(fiber, queue, update, lane) {
		concurrentQueues[concurrentQueuesIndex++] = fiber;
		concurrentQueues[concurrentQueuesIndex++] = queue;
		concurrentQueues[concurrentQueuesIndex++] = update;
		concurrentQueues[concurrentQueuesIndex++] = lane;
		concurrentlyUpdatedLanes |= lane;
		fiber.lanes |= lane;
		fiber = fiber.alternate;
		null !== fiber && (fiber.lanes |= lane);
	}
	function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
		enqueueUpdate$1(fiber, queue, update, lane);
		return getRootForUpdatedFiber(fiber);
	}
	function enqueueConcurrentRenderForLane(fiber, lane) {
		enqueueUpdate$1(fiber, null, null, lane);
		return getRootForUpdatedFiber(fiber);
	}
	function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
		sourceFiber.lanes |= lane;
		var alternate = sourceFiber.alternate;
		null !== alternate && (alternate.lanes |= lane);
		for (var isHidden = !1, parent = sourceFiber.return; null !== parent;) parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)), sourceFiber = parent, parent = parent.return;
		return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
	}
	function getRootForUpdatedFiber(sourceFiber) {
		if (50 < nestedUpdateCount) throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
		for (var parent = sourceFiber.return; null !== parent;) sourceFiber = parent, parent = sourceFiber.return;
		return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
	}
	var emptyContextObject = {};
	function FiberNode(tag, pendingProps, key, mode) {
		this.tag = tag;
		this.key = key;
		this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
		this.index = 0;
		this.refCleanup = this.ref = null;
		this.pendingProps = pendingProps;
		this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
		this.mode = mode;
		this.subtreeFlags = this.flags = 0;
		this.deletions = null;
		this.childLanes = this.lanes = 0;
		this.alternate = null;
	}
	function createFiberImplClass(tag, pendingProps, key, mode) {
		return new FiberNode(tag, pendingProps, key, mode);
	}
	function shouldConstruct(Component$1) {
		Component$1 = Component$1.prototype;
		return !(!Component$1 || !Component$1.isReactComponent);
	}
	function createWorkInProgress(current, pendingProps) {
		var workInProgress$1 = current.alternate;
		null === workInProgress$1 ? (workInProgress$1 = createFiberImplClass(current.tag, pendingProps, current.key, current.mode), workInProgress$1.elementType = current.elementType, workInProgress$1.type = current.type, workInProgress$1.stateNode = current.stateNode, workInProgress$1.alternate = current, current.alternate = workInProgress$1) : (workInProgress$1.pendingProps = pendingProps, workInProgress$1.type = current.type, workInProgress$1.flags = 0, workInProgress$1.subtreeFlags = 0, workInProgress$1.deletions = null);
		workInProgress$1.flags = current.flags & 65011712;
		workInProgress$1.childLanes = current.childLanes;
		workInProgress$1.lanes = current.lanes;
		workInProgress$1.child = current.child;
		workInProgress$1.memoizedProps = current.memoizedProps;
		workInProgress$1.memoizedState = current.memoizedState;
		workInProgress$1.updateQueue = current.updateQueue;
		pendingProps = current.dependencies;
		workInProgress$1.dependencies = null === pendingProps ? null : {
			lanes: pendingProps.lanes,
			firstContext: pendingProps.firstContext
		};
		workInProgress$1.sibling = current.sibling;
		workInProgress$1.index = current.index;
		workInProgress$1.ref = current.ref;
		workInProgress$1.refCleanup = current.refCleanup;
		return workInProgress$1;
	}
	function resetWorkInProgress(workInProgress$1, renderLanes$1) {
		workInProgress$1.flags &= 65011714;
		var current = workInProgress$1.alternate;
		null === current ? (workInProgress$1.childLanes = 0, workInProgress$1.lanes = renderLanes$1, workInProgress$1.child = null, workInProgress$1.subtreeFlags = 0, workInProgress$1.memoizedProps = null, workInProgress$1.memoizedState = null, workInProgress$1.updateQueue = null, workInProgress$1.dependencies = null, workInProgress$1.stateNode = null) : (workInProgress$1.childLanes = current.childLanes, workInProgress$1.lanes = current.lanes, workInProgress$1.child = current.child, workInProgress$1.subtreeFlags = 0, workInProgress$1.deletions = null, workInProgress$1.memoizedProps = current.memoizedProps, workInProgress$1.memoizedState = current.memoizedState, workInProgress$1.updateQueue = current.updateQueue, workInProgress$1.type = current.type, renderLanes$1 = current.dependencies, workInProgress$1.dependencies = null === renderLanes$1 ? null : {
			lanes: renderLanes$1.lanes,
			firstContext: renderLanes$1.firstContext
		});
		return workInProgress$1;
	}
	function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
		var fiberTag = 0;
		owner = type;
		if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
		else if ("string" === typeof type) fiberTag = isHostHoistableType(type, pendingProps, contextStackCursor.current) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
		else a: switch (type) {
			case REACT_ACTIVITY_TYPE: return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
			case REACT_FRAGMENT_TYPE$1: return createFiberFromFragment(pendingProps.children, mode, lanes, key);
			case REACT_STRICT_MODE_TYPE:
				fiberTag = 8;
				mode |= 24;
				break;
			case REACT_PROFILER_TYPE: return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
			case REACT_SUSPENSE_TYPE: return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
			case REACT_SUSPENSE_LIST_TYPE: return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
			default:
				if ("object" === typeof type && null !== type) switch (type.$$typeof) {
					case REACT_CONTEXT_TYPE:
						fiberTag = 10;
						break a;
					case REACT_CONSUMER_TYPE:
						fiberTag = 9;
						break a;
					case REACT_FORWARD_REF_TYPE:
						fiberTag = 11;
						break a;
					case REACT_MEMO_TYPE:
						fiberTag = 14;
						break a;
					case REACT_LAZY_TYPE:
						fiberTag = 16;
						owner = null;
						break a;
				}
				fiberTag = 29;
				pendingProps = Error(formatProdErrorMessage(130, null === type ? "null" : typeof type, ""));
				owner = null;
		}
		key = createFiberImplClass(fiberTag, pendingProps, key, mode);
		key.elementType = type;
		key.type = owner;
		key.lanes = lanes;
		return key;
	}
	function createFiberFromFragment(elements, mode, lanes, key) {
		elements = createFiberImplClass(7, elements, key, mode);
		elements.lanes = lanes;
		return elements;
	}
	function createFiberFromText(content, mode, lanes) {
		content = createFiberImplClass(6, content, null, mode);
		content.lanes = lanes;
		return content;
	}
	function createFiberFromDehydratedFragment(dehydratedNode) {
		var fiber = createFiberImplClass(18, null, null, 0);
		fiber.stateNode = dehydratedNode;
		return fiber;
	}
	function createFiberFromPortal(portal, mode, lanes) {
		mode = createFiberImplClass(4, null !== portal.children ? portal.children : [], portal.key, mode);
		mode.lanes = lanes;
		mode.stateNode = {
			containerInfo: portal.containerInfo,
			pendingChildren: null,
			implementation: portal.implementation
		};
		return mode;
	}
	var CapturedStacks = /* @__PURE__ */ new WeakMap();
	function createCapturedValueAtFiber(value, source) {
		if ("object" === typeof value && null !== value) {
			var existing = CapturedStacks.get(value);
			if (void 0 !== existing) return existing;
			source = {
				value,
				source,
				stack: getStackByFiberInDevAndProd(source)
			};
			CapturedStacks.set(value, source);
			return source;
		}
		return {
			value,
			source,
			stack: getStackByFiberInDevAndProd(source)
		};
	}
	var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
	function pushTreeFork(workInProgress$1, totalChildren) {
		forkStack[forkStackIndex++] = treeForkCount;
		forkStack[forkStackIndex++] = treeForkProvider;
		treeForkProvider = workInProgress$1;
		treeForkCount = totalChildren;
	}
	function pushTreeId(workInProgress$1, totalChildren, index$3) {
		idStack[idStackIndex++] = treeContextId;
		idStack[idStackIndex++] = treeContextOverflow;
		idStack[idStackIndex++] = treeContextProvider;
		treeContextProvider = workInProgress$1;
		var baseIdWithLeadingBit = treeContextId;
		workInProgress$1 = treeContextOverflow;
		var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
		baseIdWithLeadingBit &= ~(1 << baseLength);
		index$3 += 1;
		var length = 32 - clz32(totalChildren) + baseLength;
		if (30 < length) {
			var numberOfOverflowBits = baseLength - baseLength % 5;
			length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
			baseIdWithLeadingBit >>= numberOfOverflowBits;
			baseLength -= numberOfOverflowBits;
			treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index$3 << baseLength | baseIdWithLeadingBit;
			treeContextOverflow = length + workInProgress$1;
		} else treeContextId = 1 << length | index$3 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress$1;
	}
	function pushMaterializedTreeId(workInProgress$1) {
		null !== workInProgress$1.return && (pushTreeFork(workInProgress$1, 1), pushTreeId(workInProgress$1, 1, 0));
	}
	function popTreeContext(workInProgress$1) {
		for (; workInProgress$1 === treeForkProvider;) treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
		for (; workInProgress$1 === treeContextProvider;) treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
	}
	function restoreSuspendedTreeContext(workInProgress$1, suspendedContext) {
		idStack[idStackIndex++] = treeContextId;
		idStack[idStackIndex++] = treeContextOverflow;
		idStack[idStackIndex++] = treeContextProvider;
		treeContextId = suspendedContext.id;
		treeContextOverflow = suspendedContext.overflow;
		treeContextProvider = workInProgress$1;
	}
	var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1, hydrationErrors = null, rootOrSingletonContext = !1, HydrationMismatchException = Error(formatProdErrorMessage(519));
	function throwOnHydrationMismatch(fiber) {
		queueHydrationError(createCapturedValueAtFiber(Error(formatProdErrorMessage(418, 1 < arguments.length && void 0 !== arguments[1] && arguments[1] ? "text" : "HTML", "")), fiber));
		throw HydrationMismatchException;
	}
	function prepareToHydrateHostInstance(fiber) {
		var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
		instance[internalInstanceKey] = fiber;
		instance[internalPropsKey] = props;
		switch (type) {
			case "dialog":
				listenToNonDelegatedEvent("cancel", instance);
				listenToNonDelegatedEvent("close", instance);
				break;
			case "iframe":
			case "object":
			case "embed":
				listenToNonDelegatedEvent("load", instance);
				break;
			case "video":
			case "audio":
				for (type = 0; type < mediaEventTypes.length; type++) listenToNonDelegatedEvent(mediaEventTypes[type], instance);
				break;
			case "source":
				listenToNonDelegatedEvent("error", instance);
				break;
			case "img":
			case "image":
			case "link":
				listenToNonDelegatedEvent("error", instance);
				listenToNonDelegatedEvent("load", instance);
				break;
			case "details":
				listenToNonDelegatedEvent("toggle", instance);
				break;
			case "input":
				listenToNonDelegatedEvent("invalid", instance);
				initInput(instance, props.value, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name, !0);
				break;
			case "select":
				listenToNonDelegatedEvent("invalid", instance);
				break;
			case "textarea": listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children);
		}
		type = props.children;
		"string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || !0 === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1$1), instance = !0) : instance = !1;
		instance || throwOnHydrationMismatch(fiber, !0);
	}
	function popToNextHostParent(fiber) {
		for (hydrationParentFiber = fiber.return; hydrationParentFiber;) switch (hydrationParentFiber.tag) {
			case 5:
			case 31:
			case 13:
				rootOrSingletonContext = !1;
				return;
			case 27:
			case 3:
				rootOrSingletonContext = !0;
				return;
			default: hydrationParentFiber = hydrationParentFiber.return;
		}
	}
	function popHydrationState(fiber) {
		if (fiber !== hydrationParentFiber) return !1;
		if (!isHydrating) return popToNextHostParent(fiber), isHydrating = !0, !1;
		var tag = fiber.tag, JSCompiler_temp;
		if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
			if (JSCompiler_temp = 5 === tag) JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
			JSCompiler_temp = !JSCompiler_temp;
		}
		JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
		popToNextHostParent(fiber);
		if (13 === tag) {
			fiber = fiber.memoizedState;
			fiber = null !== fiber ? fiber.dehydrated : null;
			if (!fiber) throw Error(formatProdErrorMessage(317));
			nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
		} else if (31 === tag) {
			fiber = fiber.memoizedState;
			fiber = null !== fiber ? fiber.dehydrated : null;
			if (!fiber) throw Error(formatProdErrorMessage(317));
			nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
		} else 27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
		return !0;
	}
	function resetHydrationState() {
		nextHydratableInstance = hydrationParentFiber = null;
		isHydrating = !1;
	}
	function upgradeHydrationErrorsToRecoverable() {
		var queuedErrors = hydrationErrors;
		null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, queuedErrors), hydrationErrors = null);
		return queuedErrors;
	}
	function queueHydrationError(error) {
		null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
	}
	var valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null;
	function pushProvider(providerFiber, context, nextValue) {
		push(valueCursor, context._currentValue);
		context._currentValue = nextValue;
	}
	function popProvider(context) {
		context._currentValue = valueCursor.current;
		pop(valueCursor);
	}
	function scheduleContextWorkOnParentPath(parent, renderLanes$1, propagationRoot) {
		for (; null !== parent;) {
			var alternate = parent.alternate;
			(parent.childLanes & renderLanes$1) !== renderLanes$1 ? (parent.childLanes |= renderLanes$1, null !== alternate && (alternate.childLanes |= renderLanes$1)) : null !== alternate && (alternate.childLanes & renderLanes$1) !== renderLanes$1 && (alternate.childLanes |= renderLanes$1);
			if (parent === propagationRoot) break;
			parent = parent.return;
		}
	}
	function propagateContextChanges(workInProgress$1, contexts, renderLanes$1, forcePropagateEntireTree) {
		var fiber = workInProgress$1.child;
		null !== fiber && (fiber.return = workInProgress$1);
		for (; null !== fiber;) {
			var list = fiber.dependencies;
			if (null !== list) {
				var nextFiber = fiber.child;
				list = list.firstContext;
				a: for (; null !== list;) {
					var dependency = list;
					list = fiber;
					for (var i = 0; i < contexts.length; i++) if (dependency.context === contexts[i]) {
						list.lanes |= renderLanes$1;
						dependency = list.alternate;
						null !== dependency && (dependency.lanes |= renderLanes$1);
						scheduleContextWorkOnParentPath(list.return, renderLanes$1, workInProgress$1);
						forcePropagateEntireTree || (nextFiber = null);
						break a;
					}
					list = dependency.next;
				}
			} else if (18 === fiber.tag) {
				nextFiber = fiber.return;
				if (null === nextFiber) throw Error(formatProdErrorMessage(341));
				nextFiber.lanes |= renderLanes$1;
				list = nextFiber.alternate;
				null !== list && (list.lanes |= renderLanes$1);
				scheduleContextWorkOnParentPath(nextFiber, renderLanes$1, workInProgress$1);
				nextFiber = null;
			} else nextFiber = fiber.child;
			if (null !== nextFiber) nextFiber.return = fiber;
			else for (nextFiber = fiber; null !== nextFiber;) {
				if (nextFiber === workInProgress$1) {
					nextFiber = null;
					break;
				}
				fiber = nextFiber.sibling;
				if (null !== fiber) {
					fiber.return = nextFiber.return;
					nextFiber = fiber;
					break;
				}
				nextFiber = nextFiber.return;
			}
			fiber = nextFiber;
		}
	}
	function propagateParentContextChanges(current, workInProgress$1, renderLanes$1, forcePropagateEntireTree) {
		current = null;
		for (var parent = workInProgress$1, isInsidePropagationBailout = !1; null !== parent;) {
			if (!isInsidePropagationBailout) {
				if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;
				else if (0 !== (parent.flags & 262144)) break;
			}
			if (10 === parent.tag) {
				var currentParent = parent.alternate;
				if (null === currentParent) throw Error(formatProdErrorMessage(387));
				currentParent = currentParent.memoizedProps;
				if (null !== currentParent) {
					var context = parent.type;
					objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
				}
			} else if (parent === hostTransitionProviderCursor.current) {
				currentParent = parent.alternate;
				if (null === currentParent) throw Error(formatProdErrorMessage(387));
				currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
			}
			parent = parent.return;
		}
		null !== current && propagateContextChanges(workInProgress$1, current, renderLanes$1, forcePropagateEntireTree);
		workInProgress$1.flags |= 262144;
	}
	function checkIfContextChanged(currentDependencies) {
		for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies;) {
			if (!objectIs(currentDependencies.context._currentValue, currentDependencies.memoizedValue)) return !0;
			currentDependencies = currentDependencies.next;
		}
		return !1;
	}
	function prepareToReadContext(workInProgress$1) {
		currentlyRenderingFiber$1 = workInProgress$1;
		lastContextDependency = null;
		workInProgress$1 = workInProgress$1.dependencies;
		null !== workInProgress$1 && (workInProgress$1.firstContext = null);
	}
	function readContext(context) {
		return readContextForConsumer(currentlyRenderingFiber$1, context);
	}
	function readContextDuringReconciliation(consumer, context) {
		null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
		return readContextForConsumer(consumer, context);
	}
	function readContextForConsumer(consumer, context) {
		var value = context._currentValue;
		context = {
			context,
			memoizedValue: value,
			next: null
		};
		if (null === lastContextDependency) {
			if (null === consumer) throw Error(formatProdErrorMessage(308));
			lastContextDependency = context;
			consumer.dependencies = {
				lanes: 0,
				firstContext: context
			};
			consumer.flags |= 524288;
		} else lastContextDependency = lastContextDependency.next = context;
		return value;
	}
	var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
		var listeners = [], signal = this.signal = {
			aborted: !1,
			addEventListener: function(type, listener) {
				listeners.push(listener);
			}
		};
		this.abort = function() {
			signal.aborted = !0;
			listeners.forEach(function(listener) {
				return listener();
			});
		};
	}, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
		$$typeof: REACT_CONTEXT_TYPE,
		Consumer: null,
		Provider: null,
		_currentValue: null,
		_currentValue2: null,
		_threadCount: 0
	};
	function createCache() {
		return {
			controller: new AbortControllerLocal(),
			data: /* @__PURE__ */ new Map(),
			refCount: 0
		};
	}
	function releaseCache(cache) {
		cache.refCount--;
		0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
			cache.controller.abort();
		});
	}
	var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
	function entangleAsyncAction(transition, thenable) {
		if (null === currentEntangledListeners) {
			var entangledListeners = currentEntangledListeners = [];
			currentEntangledPendingCount = 0;
			currentEntangledLane = requestTransitionLane();
			currentEntangledActionThenable = {
				status: "pending",
				value: void 0,
				then: function(resolve) {
					entangledListeners.push(resolve);
				}
			};
		}
		currentEntangledPendingCount++;
		thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
		return thenable;
	}
	function pingEngtangledActionScope() {
		if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
			null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
			var listeners = currentEntangledListeners;
			currentEntangledListeners = null;
			currentEntangledLane = 0;
			currentEntangledActionThenable = null;
			for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
		}
	}
	function chainThenableValue(thenable, result) {
		var listeners = [], thenableWithOverride = {
			status: "pending",
			value: null,
			reason: null,
			then: function(resolve) {
				listeners.push(resolve);
			}
		};
		thenable.then(function() {
			thenableWithOverride.status = "fulfilled";
			thenableWithOverride.value = result;
			for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
		}, function(error) {
			thenableWithOverride.status = "rejected";
			thenableWithOverride.reason = error;
			for (error = 0; error < listeners.length; error++) (0, listeners[error])(void 0);
		});
		return thenableWithOverride;
	}
	var prevOnStartTransitionFinish = ReactSharedInternals.S;
	ReactSharedInternals.S = function(transition, returnValue) {
		globalMostRecentTransitionTime = now();
		"object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
		null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
	};
	var resumedCache = createCursor(null);
	function peekCacheFromPool() {
		var cacheResumedFromPreviousRender = resumedCache.current;
		return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
	}
	function pushTransition(offscreenWorkInProgress, prevCachePool) {
		null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
	}
	function getSuspendedCache() {
		var cacheFromPool = peekCacheFromPool();
		return null === cacheFromPool ? null : {
			parent: CacheContext._currentValue,
			pool: cacheFromPool
		};
	}
	var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = { then: function() {} };
	function isThenableResolved(thenable) {
		thenable = thenable.status;
		return "fulfilled" === thenable || "rejected" === thenable;
	}
	function trackUsedThenable(thenableState$2, thenable, index$3) {
		index$3 = thenableState$2[index$3];
		void 0 === index$3 ? thenableState$2.push(thenable) : index$3 !== thenable && (thenable.then(noop$1$1, noop$1$1), thenable = index$3);
		switch (thenable.status) {
			case "fulfilled": return thenable.value;
			case "rejected": throw thenableState$2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState$2), thenableState$2;
			default:
				if ("string" === typeof thenable.status) thenable.then(noop$1$1, noop$1$1);
				else {
					thenableState$2 = workInProgressRoot;
					if (null !== thenableState$2 && 100 < thenableState$2.shellSuspendCounter) throw Error(formatProdErrorMessage(482));
					thenableState$2 = thenable;
					thenableState$2.status = "pending";
					thenableState$2.then(function(fulfilledValue) {
						if ("pending" === thenable.status) {
							var fulfilledThenable = thenable;
							fulfilledThenable.status = "fulfilled";
							fulfilledThenable.value = fulfilledValue;
						}
					}, function(error) {
						if ("pending" === thenable.status) {
							var rejectedThenable = thenable;
							rejectedThenable.status = "rejected";
							rejectedThenable.reason = error;
						}
					});
				}
				switch (thenable.status) {
					case "fulfilled": return thenable.value;
					case "rejected": throw thenableState$2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState$2), thenableState$2;
				}
				suspendedThenable = thenable;
				throw SuspenseException;
		}
	}
	function resolveLazy(lazyType) {
		try {
			var init = lazyType._init;
			return init(lazyType._payload);
		} catch (x) {
			if (null !== x && "object" === typeof x && "function" === typeof x.then) throw suspendedThenable = x, SuspenseException;
			throw x;
		}
	}
	var suspendedThenable = null;
	function getSuspendedThenable() {
		if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
		var thenable = suspendedThenable;
		suspendedThenable = null;
		return thenable;
	}
	function checkIfUseWrappedInAsyncCatch(rejectedReason) {
		if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException) throw Error(formatProdErrorMessage(483));
	}
	var thenableState$1 = null, thenableIndexCounter$1 = 0;
	function unwrapThenable(thenable) {
		var index$3 = thenableIndexCounter$1;
		thenableIndexCounter$1 += 1;
		null === thenableState$1 && (thenableState$1 = []);
		return trackUsedThenable(thenableState$1, thenable, index$3);
	}
	function coerceRef(workInProgress$1, element) {
		element = element.props.ref;
		workInProgress$1.ref = void 0 !== element ? element : null;
	}
	function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
		if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error(formatProdErrorMessage(525));
		returnFiber = Object.prototype.toString.call(newChild);
		throw Error(formatProdErrorMessage(31, "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber));
	}
	function createChildReconciler(shouldTrackSideEffects) {
		function deleteChild(returnFiber, childToDelete) {
			if (shouldTrackSideEffects) {
				var deletions = returnFiber.deletions;
				null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
			}
		}
		function deleteRemainingChildren(returnFiber, currentFirstChild) {
			if (!shouldTrackSideEffects) return null;
			for (; null !== currentFirstChild;) deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
			return null;
		}
		function mapRemainingChildren(currentFirstChild) {
			for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild;) null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
			return existingChildren;
		}
		function useFiber(fiber, pendingProps) {
			fiber = createWorkInProgress(fiber, pendingProps);
			fiber.index = 0;
			fiber.sibling = null;
			return fiber;
		}
		function placeChild(newFiber, lastPlacedIndex, newIndex) {
			newFiber.index = newIndex;
			if (!shouldTrackSideEffects) return newFiber.flags |= 1048576, lastPlacedIndex;
			newIndex = newFiber.alternate;
			if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
			newFiber.flags |= 67108866;
			return lastPlacedIndex;
		}
		function placeSingleChild(newFiber) {
			shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
			return newFiber;
		}
		function updateTextNode(returnFiber, current, textContent, lanes) {
			if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
			current = useFiber(current, textContent);
			current.return = returnFiber;
			return current;
		}
		function updateElement(returnFiber, current, element, lanes) {
			var elementType = element.type;
			if (elementType === REACT_FRAGMENT_TYPE$1) return updateFragment(returnFiber, current, element.props.children, lanes, element.key);
			if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type)) return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
			current = createFiberFromTypeAndProps(element.type, element.key, element.props, null, returnFiber.mode, lanes);
			coerceRef(current, element);
			current.return = returnFiber;
			return current;
		}
		function updatePortal(returnFiber, current, portal, lanes) {
			if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
			current = useFiber(current, portal.children || []);
			current.return = returnFiber;
			return current;
		}
		function updateFragment(returnFiber, current, fragment, lanes, key) {
			if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current;
			current = useFiber(current, fragment);
			current.return = returnFiber;
			return current;
		}
		function createChild(returnFiber, newChild, lanes) {
			if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return newChild = createFiberFromText("" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild;
			if ("object" === typeof newChild && null !== newChild) {
				switch (newChild.$$typeof) {
					case REACT_ELEMENT_TYPE$1: return lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
					case REACT_PORTAL_TYPE: return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild;
					case REACT_LAZY_TYPE: return newChild = resolveLazy(newChild), createChild(returnFiber, newChild, lanes);
				}
				if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newChild = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), newChild.return = returnFiber, newChild;
				if ("function" === typeof newChild.then) return createChild(returnFiber, unwrapThenable(newChild), lanes);
				if (newChild.$$typeof === REACT_CONTEXT_TYPE) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
				throwOnInvalidObjectTypeImpl(returnFiber, newChild);
			}
			return null;
		}
		function updateSlot(returnFiber, oldFiber, newChild, lanes) {
			var key = null !== oldFiber ? oldFiber.key : null;
			if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
			if ("object" === typeof newChild && null !== newChild) {
				switch (newChild.$$typeof) {
					case REACT_ELEMENT_TYPE$1: return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
					case REACT_PORTAL_TYPE: return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
					case REACT_LAZY_TYPE: return newChild = resolveLazy(newChild), updateSlot(returnFiber, oldFiber, newChild, lanes);
				}
				if (isArrayImpl(newChild) || getIteratorFn(newChild)) return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
				if ("function" === typeof newChild.then) return updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes);
				if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
				throwOnInvalidObjectTypeImpl(returnFiber, newChild);
			}
			return null;
		}
		function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
			if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
			if ("object" === typeof newChild && null !== newChild) {
				switch (newChild.$$typeof) {
					case REACT_ELEMENT_TYPE$1: return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
					case REACT_PORTAL_TYPE: return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
					case REACT_LAZY_TYPE: return newChild = resolveLazy(newChild), updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);
				}
				if (isArrayImpl(newChild) || getIteratorFn(newChild)) return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
				if ("function" === typeof newChild.then) return updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes);
				if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);
				throwOnInvalidObjectTypeImpl(returnFiber, newChild);
			}
			return null;
		}
		function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
			for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
				oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
				var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
				if (null === newFiber) {
					null === oldFiber && (oldFiber = nextOldFiber);
					break;
				}
				shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
				currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
				null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
				previousNewFiber = newFiber;
				oldFiber = nextOldFiber;
			}
			if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
			if (null === oldFiber) {
				for (; newIdx < newChildren.length; newIdx++) oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
				isHydrating && pushTreeFork(returnFiber, newIdx);
				return resultingFirstChild;
			}
			for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++) nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
			shouldTrackSideEffects && oldFiber.forEach(function(child) {
				return deleteChild(returnFiber, child);
			});
			isHydrating && pushTreeFork(returnFiber, newIdx);
			return resultingFirstChild;
		}
		function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
			if (null == newChildren) throw Error(formatProdErrorMessage(151));
			for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
				oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
				var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
				if (null === newFiber) {
					null === oldFiber && (oldFiber = nextOldFiber);
					break;
				}
				shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
				currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
				null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
				previousNewFiber = newFiber;
				oldFiber = nextOldFiber;
			}
			if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
			if (null === oldFiber) {
				for (; !step.done; newIdx++, step = newChildren.next()) step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
				isHydrating && pushTreeFork(returnFiber, newIdx);
				return resultingFirstChild;
			}
			for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next()) step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
			shouldTrackSideEffects && oldFiber.forEach(function(child) {
				return deleteChild(returnFiber, child);
			});
			isHydrating && pushTreeFork(returnFiber, newIdx);
			return resultingFirstChild;
		}
		function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
			"object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE$1 && null === newChild.key && (newChild = newChild.props.children);
			if ("object" === typeof newChild && null !== newChild) {
				switch (newChild.$$typeof) {
					case REACT_ELEMENT_TYPE$1:
						a: {
							for (var key = newChild.key; null !== currentFirstChild;) {
								if (currentFirstChild.key === key) {
									key = newChild.type;
									if (key === REACT_FRAGMENT_TYPE$1) {
										if (7 === currentFirstChild.tag) {
											deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
											lanes = useFiber(currentFirstChild, newChild.props.children);
											lanes.return = returnFiber;
											returnFiber = lanes;
											break a;
										}
									} else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
										deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
										lanes = useFiber(currentFirstChild, newChild.props);
										coerceRef(lanes, newChild);
										lanes.return = returnFiber;
										returnFiber = lanes;
										break a;
									}
									deleteRemainingChildren(returnFiber, currentFirstChild);
									break;
								} else deleteChild(returnFiber, currentFirstChild);
								currentFirstChild = currentFirstChild.sibling;
							}
							newChild.type === REACT_FRAGMENT_TYPE$1 ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
						}
						return placeSingleChild(returnFiber);
					case REACT_PORTAL_TYPE:
						a: {
							for (key = newChild.key; null !== currentFirstChild;) {
								if (currentFirstChild.key === key) if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
									deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
									lanes = useFiber(currentFirstChild, newChild.children || []);
									lanes.return = returnFiber;
									returnFiber = lanes;
									break a;
								} else {
									deleteRemainingChildren(returnFiber, currentFirstChild);
									break;
								}
								else deleteChild(returnFiber, currentFirstChild);
								currentFirstChild = currentFirstChild.sibling;
							}
							lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
							lanes.return = returnFiber;
							returnFiber = lanes;
						}
						return placeSingleChild(returnFiber);
					case REACT_LAZY_TYPE: return newChild = resolveLazy(newChild), reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
				}
				if (isArrayImpl(newChild)) return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
				if (getIteratorFn(newChild)) {
					key = getIteratorFn(newChild);
					if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
					newChild = key.call(newChild);
					return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
				}
				if ("function" === typeof newChild.then) return reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes);
				if (newChild.$$typeof === REACT_CONTEXT_TYPE) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);
				throwOnInvalidObjectTypeImpl(returnFiber, newChild);
			}
			return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
		}
		return function(returnFiber, currentFirstChild, newChild, lanes) {
			try {
				thenableIndexCounter$1 = 0;
				var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
				thenableState$1 = null;
				return firstChildFiber;
			} catch (x) {
				if (x === SuspenseException || x === SuspenseActionException) throw x;
				var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
				fiber.lanes = lanes;
				fiber.return = returnFiber;
				return fiber;
			}
		};
	}
	var reconcileChildFibers = createChildReconciler(!0), mountChildFibers = createChildReconciler(!1), hasForceUpdate = !1;
	function initializeUpdateQueue(fiber) {
		fiber.updateQueue = {
			baseState: fiber.memoizedState,
			firstBaseUpdate: null,
			lastBaseUpdate: null,
			shared: {
				pending: null,
				lanes: 0,
				hiddenCallbacks: null
			},
			callbacks: null
		};
	}
	function cloneUpdateQueue(current, workInProgress$1) {
		current = current.updateQueue;
		workInProgress$1.updateQueue === current && (workInProgress$1.updateQueue = {
			baseState: current.baseState,
			firstBaseUpdate: current.firstBaseUpdate,
			lastBaseUpdate: current.lastBaseUpdate,
			shared: current.shared,
			callbacks: null
		});
	}
	function createUpdate(lane) {
		return {
			lane,
			tag: 0,
			payload: null,
			callback: null,
			next: null
		};
	}
	function enqueueUpdate(fiber, update, lane) {
		var updateQueue = fiber.updateQueue;
		if (null === updateQueue) return null;
		updateQueue = updateQueue.shared;
		if (0 !== (executionContext & 2)) {
			var pending = updateQueue.pending;
			null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
			updateQueue.pending = update;
			update = getRootForUpdatedFiber(fiber);
			markUpdateLaneFromFiberToRoot(fiber, null, lane);
			return update;
		}
		enqueueUpdate$1(fiber, updateQueue, update, lane);
		return getRootForUpdatedFiber(fiber);
	}
	function entangleTransitions(root$1, fiber, lane) {
		fiber = fiber.updateQueue;
		if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
			var queueLanes = fiber.lanes;
			queueLanes &= root$1.pendingLanes;
			lane |= queueLanes;
			fiber.lanes = lane;
			markRootEntangled(root$1, lane);
		}
	}
	function enqueueCapturedUpdate(workInProgress$1, capturedUpdate) {
		var queue = workInProgress$1.updateQueue, current = workInProgress$1.alternate;
		if (null !== current && (current = current.updateQueue, queue === current)) {
			var newFirst = null, newLast = null;
			queue = queue.firstBaseUpdate;
			if (null !== queue) {
				do {
					var clone = {
						lane: queue.lane,
						tag: queue.tag,
						payload: queue.payload,
						callback: null,
						next: null
					};
					null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
					queue = queue.next;
				} while (null !== queue);
				null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
			} else newFirst = newLast = capturedUpdate;
			queue = {
				baseState: current.baseState,
				firstBaseUpdate: newFirst,
				lastBaseUpdate: newLast,
				shared: current.shared,
				callbacks: current.callbacks
			};
			workInProgress$1.updateQueue = queue;
			return;
		}
		workInProgress$1 = queue.lastBaseUpdate;
		null === workInProgress$1 ? queue.firstBaseUpdate = capturedUpdate : workInProgress$1.next = capturedUpdate;
		queue.lastBaseUpdate = capturedUpdate;
	}
	var didReadFromEntangledAsyncAction = !1;
	function suspendIfUpdateReadFromEntangledAsyncAction() {
		if (didReadFromEntangledAsyncAction) {
			var entangledActionThenable = currentEntangledActionThenable;
			if (null !== entangledActionThenable) throw entangledActionThenable;
		}
	}
	function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes$1) {
		didReadFromEntangledAsyncAction = !1;
		var queue = workInProgress$jscomp$0.updateQueue;
		hasForceUpdate = !1;
		var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
		if (null !== pendingQueue) {
			queue.shared.pending = null;
			var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
			lastPendingUpdate.next = null;
			null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
			lastBaseUpdate = lastPendingUpdate;
			var current = workInProgress$jscomp$0.alternate;
			null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
		}
		if (null !== firstBaseUpdate) {
			var newState = queue.baseState;
			lastBaseUpdate = 0;
			current = firstPendingUpdate = lastPendingUpdate = null;
			pendingQueue = firstBaseUpdate;
			do {
				var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
				if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes$1 & updateLane) === updateLane) {
					0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);
					null !== current && (current = current.next = {
						lane: 0,
						tag: pendingQueue.tag,
						payload: pendingQueue.payload,
						callback: null,
						next: null
					});
					a: {
						var workInProgress$1 = workInProgress$jscomp$0, update = pendingQueue;
						updateLane = props;
						var instance = instance$jscomp$0;
						switch (update.tag) {
							case 1:
								workInProgress$1 = update.payload;
								if ("function" === typeof workInProgress$1) {
									newState = workInProgress$1.call(instance, newState, updateLane);
									break a;
								}
								newState = workInProgress$1;
								break a;
							case 3: workInProgress$1.flags = workInProgress$1.flags & -65537 | 128;
							case 0:
								workInProgress$1 = update.payload;
								updateLane = "function" === typeof workInProgress$1 ? workInProgress$1.call(instance, newState, updateLane) : workInProgress$1;
								if (null === updateLane || void 0 === updateLane) break a;
								newState = assign({}, newState, updateLane);
								break a;
							case 2: hasForceUpdate = !0;
						}
					}
					updateLane = pendingQueue.callback;
					null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
				} else isHiddenUpdate = {
					lane: updateLane,
					tag: pendingQueue.tag,
					payload: pendingQueue.payload,
					callback: pendingQueue.callback,
					next: null
				}, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
				pendingQueue = pendingQueue.next;
				if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;
				else isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
			} while (1);
			null === current && (lastPendingUpdate = newState);
			queue.baseState = lastPendingUpdate;
			queue.firstBaseUpdate = firstPendingUpdate;
			queue.lastBaseUpdate = current;
			null === firstBaseUpdate && (queue.shared.lanes = 0);
			workInProgressRootSkippedLanes |= lastBaseUpdate;
			workInProgress$jscomp$0.lanes = lastBaseUpdate;
			workInProgress$jscomp$0.memoizedState = newState;
		}
	}
	function callCallback(callback, context) {
		if ("function" !== typeof callback) throw Error(formatProdErrorMessage(191, callback));
		callback.call(context);
	}
	function commitCallbacks(updateQueue, context) {
		var callbacks = updateQueue.callbacks;
		if (null !== callbacks) for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++) callCallback(callbacks[updateQueue], context);
	}
	var currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
	function pushHiddenContext(fiber, context) {
		fiber = entangledRenderLanes;
		push(prevEntangledRenderLanesCursor, fiber);
		push(currentTreeHiddenStackCursor, context);
		entangledRenderLanes = fiber | context.baseLanes;
	}
	function reuseHiddenContextOnStack() {
		push(prevEntangledRenderLanesCursor, entangledRenderLanes);
		push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
	}
	function popHiddenContext() {
		entangledRenderLanes = prevEntangledRenderLanesCursor.current;
		pop(currentTreeHiddenStackCursor);
		pop(prevEntangledRenderLanesCursor);
	}
	var suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
	function pushPrimaryTreeSuspenseHandler(handler) {
		var current = handler.alternate;
		push(suspenseStackCursor, suspenseStackCursor.current & 1);
		push(suspenseHandlerStackCursor, handler);
		null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
	}
	function pushDehydratedActivitySuspenseHandler(fiber) {
		push(suspenseStackCursor, suspenseStackCursor.current);
		push(suspenseHandlerStackCursor, fiber);
		null === shellBoundary && (shellBoundary = fiber);
	}
	function pushOffscreenSuspenseHandler(fiber) {
		22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack(fiber);
	}
	function reuseSuspenseHandlerOnStack() {
		push(suspenseStackCursor, suspenseStackCursor.current);
		push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
	}
	function popSuspenseHandler(fiber) {
		pop(suspenseHandlerStackCursor);
		shellBoundary === fiber && (shellBoundary = null);
		pop(suspenseStackCursor);
	}
	var suspenseStackCursor = createCursor(0);
	function findFirstSuspended(row) {
		for (var node = row; null !== node;) {
			if (13 === node.tag) {
				var state = node.memoizedState;
				if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state))) return node;
			} else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
				if (0 !== (node.flags & 128)) return node;
			} else if (null !== node.child) {
				node.child.return = node;
				node = node.child;
				continue;
			}
			if (node === row) break;
			for (; null === node.sibling;) {
				if (null === node.return || node.return === row) return null;
				node = node.return;
			}
			node.sibling.return = node.return;
			node = node.sibling;
		}
		return null;
	}
	var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1, shouldDoubleInvokeUserFnsInHooksDEV = !1, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0;
	function throwInvalidHookError() {
		throw Error(formatProdErrorMessage(321));
	}
	function areHookInputsEqual(nextDeps, prevDeps) {
		if (null === prevDeps) return !1;
		for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
		return !0;
	}
	function renderWithHooks(current, workInProgress$1, Component$1, props, secondArg, nextRenderLanes) {
		renderLanes = nextRenderLanes;
		currentlyRenderingFiber = workInProgress$1;
		workInProgress$1.memoizedState = null;
		workInProgress$1.updateQueue = null;
		workInProgress$1.lanes = 0;
		ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
		shouldDoubleInvokeUserFnsInHooksDEV = !1;
		nextRenderLanes = Component$1(props, secondArg);
		shouldDoubleInvokeUserFnsInHooksDEV = !1;
		didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(workInProgress$1, Component$1, props, secondArg));
		finishRenderingHooks(current);
		return nextRenderLanes;
	}
	function finishRenderingHooks(current) {
		ReactSharedInternals.H = ContextOnlyDispatcher;
		var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
		renderLanes = 0;
		workInProgressHook = currentHook = currentlyRenderingFiber = null;
		didScheduleRenderPhaseUpdate = !1;
		thenableIndexCounter = 0;
		thenableState = null;
		if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
		null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = !0));
	}
	function renderWithHooksAgain(workInProgress$1, Component$1, props, secondArg) {
		currentlyRenderingFiber = workInProgress$1;
		var numberOfReRenders = 0;
		do {
			didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
			thenableIndexCounter = 0;
			didScheduleRenderPhaseUpdateDuringThisPass = !1;
			if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
			numberOfReRenders += 1;
			workInProgressHook = currentHook = null;
			if (null != workInProgress$1.updateQueue) {
				var children = workInProgress$1.updateQueue;
				children.lastEffect = null;
				children.events = null;
				children.stores = null;
				null != children.memoCache && (children.memoCache.index = 0);
			}
			ReactSharedInternals.H = HooksDispatcherOnRerender;
			children = Component$1(props, secondArg);
		} while (didScheduleRenderPhaseUpdateDuringThisPass);
		return children;
	}
	function TransitionAwareHostComponent() {
		var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
		maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
		dispatcher = dispatcher.useState()[0];
		(null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
		return maybeThenable;
	}
	function checkDidRenderIdHook() {
		var didRenderIdHook = 0 !== localIdCounter;
		localIdCounter = 0;
		return didRenderIdHook;
	}
	function bailoutHooks(current, workInProgress$1, lanes) {
		workInProgress$1.updateQueue = current.updateQueue;
		workInProgress$1.flags &= -2053;
		current.lanes &= ~lanes;
	}
	function resetHooksOnUnwind(workInProgress$1) {
		if (didScheduleRenderPhaseUpdate) {
			for (workInProgress$1 = workInProgress$1.memoizedState; null !== workInProgress$1;) {
				var queue = workInProgress$1.queue;
				null !== queue && (queue.pending = null);
				workInProgress$1 = workInProgress$1.next;
			}
			didScheduleRenderPhaseUpdate = !1;
		}
		renderLanes = 0;
		workInProgressHook = currentHook = currentlyRenderingFiber = null;
		didScheduleRenderPhaseUpdateDuringThisPass = !1;
		thenableIndexCounter = localIdCounter = 0;
		thenableState = null;
	}
	function mountWorkInProgressHook() {
		var hook = {
			memoizedState: null,
			baseState: null,
			baseQueue: null,
			queue: null,
			next: null
		};
		null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
		return workInProgressHook;
	}
	function updateWorkInProgressHook() {
		if (null === currentHook) {
			var nextCurrentHook = currentlyRenderingFiber.alternate;
			nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
		} else nextCurrentHook = currentHook.next;
		var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
		if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
		else {
			if (null === nextCurrentHook) {
				if (null === currentlyRenderingFiber.alternate) throw Error(formatProdErrorMessage(467));
				throw Error(formatProdErrorMessage(310));
			}
			currentHook = nextCurrentHook;
			nextCurrentHook = {
				memoizedState: currentHook.memoizedState,
				baseState: currentHook.baseState,
				baseQueue: currentHook.baseQueue,
				queue: currentHook.queue,
				next: null
			};
			null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
		}
		return workInProgressHook;
	}
	function createFunctionComponentUpdateQueue() {
		return {
			lastEffect: null,
			events: null,
			stores: null,
			memoCache: null
		};
	}
	function useThenable(thenable) {
		var index$3 = thenableIndexCounter;
		thenableIndexCounter += 1;
		null === thenableState && (thenableState = []);
		thenable = trackUsedThenable(thenableState, thenable, index$3);
		index$3 = currentlyRenderingFiber;
		null === (null === workInProgressHook ? index$3.memoizedState : workInProgressHook.next) && (index$3 = index$3.alternate, ReactSharedInternals.H = null === index$3 || null === index$3.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
		return thenable;
	}
	function use(usable) {
		if (null !== usable && "object" === typeof usable) {
			if ("function" === typeof usable.then) return useThenable(usable);
			if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
		}
		throw Error(formatProdErrorMessage(438, String(usable)));
	}
	function useMemoCache(size$3) {
		var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
		null !== updateQueue && (memoCache = updateQueue.memoCache);
		if (null == memoCache) {
			var current = currentlyRenderingFiber.alternate;
			null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
				data: current.data.map(function(array) {
					return array.slice();
				}),
				index: 0
			})));
		}
		memoCache ??= {
			data: [],
			index: 0
		};
		null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
		updateQueue.memoCache = memoCache;
		updateQueue = memoCache.data[memoCache.index];
		if (void 0 === updateQueue) for (updateQueue = memoCache.data[memoCache.index] = Array(size$3), current = 0; current < size$3; current++) updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
		memoCache.index++;
		return updateQueue;
	}
	function basicStateReducer(state, action) {
		return "function" === typeof action ? action(state) : action;
	}
	function updateReducer(reducer) {
		return updateReducerImpl(updateWorkInProgressHook(), currentHook, reducer);
	}
	function updateReducerImpl(hook, current, reducer) {
		var queue = hook.queue;
		if (null === queue) throw Error(formatProdErrorMessage(311));
		queue.lastRenderedReducer = reducer;
		var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
		if (null !== pendingQueue) {
			if (null !== baseQueue) {
				var baseFirst = baseQueue.next;
				baseQueue.next = pendingQueue.next;
				pendingQueue.next = baseFirst;
			}
			current.baseQueue = baseQueue = pendingQueue;
			queue.pending = null;
		}
		pendingQueue = hook.baseState;
		if (null === baseQueue) hook.memoizedState = pendingQueue;
		else {
			current = baseQueue.next;
			var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$60 = !1;
			do {
				var updateLane = update.lane & -536870913;
				if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
					var revertLane = update.revertLane;
					if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
						lane: 0,
						revertLane: 0,
						gesture: null,
						action: update.action,
						hasEagerState: update.hasEagerState,
						eagerState: update.eagerState,
						next: null
					}), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = !0);
					else if ((renderLanes & revertLane) === revertLane) {
						update = update.next;
						revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = !0);
						continue;
					} else updateLane = {
						lane: 0,
						revertLane: update.revertLane,
						gesture: null,
						action: update.action,
						hasEagerState: update.hasEagerState,
						eagerState: update.eagerState,
						next: null
					}, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
					updateLane = update.action;
					shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
					pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
				} else revertLane = {
					lane: updateLane,
					revertLane: update.revertLane,
					gesture: update.gesture,
					action: update.action,
					hasEagerState: update.hasEagerState,
					eagerState: update.eagerState,
					next: null
				}, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
				update = update.next;
			} while (null !== update && update !== current);
			null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
			if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = !0, didReadFromEntangledAsyncAction$60 && (reducer = currentEntangledActionThenable, null !== reducer))) throw reducer;
			hook.memoizedState = pendingQueue;
			hook.baseState = baseFirst;
			hook.baseQueue = newBaseQueueLast;
			queue.lastRenderedState = pendingQueue;
		}
		null === baseQueue && (queue.lanes = 0);
		return [hook.memoizedState, queue.dispatch];
	}
	function rerenderReducer(reducer) {
		var hook = updateWorkInProgressHook(), queue = hook.queue;
		if (null === queue) throw Error(formatProdErrorMessage(311));
		queue.lastRenderedReducer = reducer;
		var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
		if (null !== lastRenderPhaseUpdate) {
			queue.pending = null;
			var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
			do
				newState = reducer(newState, update.action), update = update.next;
			while (update !== lastRenderPhaseUpdate);
			objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
			hook.memoizedState = newState;
			null === hook.baseQueue && (hook.baseState = newState);
			queue.lastRenderedState = newState;
		}
		return [newState, dispatch];
	}
	function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
		var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
		if (isHydrating$jscomp$0) {
			if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
			getServerSnapshot = getServerSnapshot();
		} else getServerSnapshot = getSnapshot();
		var snapshotChanged = !objectIs((currentHook || hook).memoizedState, getServerSnapshot);
		snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = !0);
		hook = hook.queue;
		updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [subscribe]);
		if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
			fiber.flags |= 2048;
			pushSimpleEffect(9, { destroy: void 0 }, updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), null);
			if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
			isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
		}
		return getServerSnapshot;
	}
	function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
		fiber.flags |= 16384;
		fiber = {
			getSnapshot,
			value: renderedSnapshot
		};
		getSnapshot = currentlyRenderingFiber.updateQueue;
		null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
	}
	function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
		inst.value = nextSnapshot;
		inst.getSnapshot = getSnapshot;
		checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
	}
	function subscribeToStore(fiber, inst, subscribe) {
		return subscribe(function() {
			checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
		});
	}
	function checkIfSnapshotChanged(inst) {
		var latestGetSnapshot = inst.getSnapshot;
		inst = inst.value;
		try {
			var nextValue = latestGetSnapshot();
			return !objectIs(inst, nextValue);
		} catch (error) {
			return !0;
		}
	}
	function forceStoreRerender(fiber) {
		var root$1 = enqueueConcurrentRenderForLane(fiber, 2);
		null !== root$1 && scheduleUpdateOnFiber(root$1, fiber, 2);
	}
	function mountStateImpl(initialState) {
		var hook = mountWorkInProgressHook();
		if ("function" === typeof initialState) {
			var initialStateInitializer = initialState;
			initialState = initialStateInitializer();
			if (shouldDoubleInvokeUserFnsInHooksDEV) {
				setIsStrictModeForDevtools(!0);
				try {
					initialStateInitializer();
				} finally {
					setIsStrictModeForDevtools(!1);
				}
			}
		}
		hook.memoizedState = hook.baseState = initialState;
		hook.queue = {
			pending: null,
			lanes: 0,
			dispatch: null,
			lastRenderedReducer: basicStateReducer,
			lastRenderedState: initialState
		};
		return hook;
	}
	function updateOptimisticImpl(hook, current, passthrough, reducer) {
		hook.baseState = passthrough;
		return updateReducerImpl(hook, currentHook, "function" === typeof reducer ? reducer : basicStateReducer);
	}
	function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
		if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
		fiber = actionQueue.action;
		if (null !== fiber) {
			var actionNode = {
				payload,
				action: fiber,
				next: null,
				isTransition: !0,
				status: "pending",
				value: null,
				reason: null,
				listeners: [],
				then: function(listener) {
					actionNode.listeners.push(listener);
				}
			};
			null !== ReactSharedInternals.T ? setPendingState(!0) : actionNode.isTransition = !1;
			setState(actionNode);
			setPendingState = actionQueue.pending;
			null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
		}
	}
	function runActionStateAction(actionQueue, node) {
		var action = node.action, payload = node.payload, prevState = actionQueue.state;
		if (node.isTransition) {
			var prevTransition = ReactSharedInternals.T, currentTransition = {};
			ReactSharedInternals.T = currentTransition;
			try {
				var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
				null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
				handleActionReturnValue(actionQueue, node, returnValue);
			} catch (error) {
				onActionError(actionQueue, node, error);
			} finally {
				null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
			}
		} else try {
			prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
		} catch (error$66) {
			onActionError(actionQueue, node, error$66);
		}
	}
	function handleActionReturnValue(actionQueue, node, returnValue) {
		null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(function(nextState) {
			onActionSuccess(actionQueue, node, nextState);
		}, function(error) {
			return onActionError(actionQueue, node, error);
		}) : onActionSuccess(actionQueue, node, returnValue);
	}
	function onActionSuccess(actionQueue, actionNode, nextState) {
		actionNode.status = "fulfilled";
		actionNode.value = nextState;
		notifyActionListeners(actionNode);
		actionQueue.state = nextState;
		actionNode = actionQueue.pending;
		null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
	}
	function onActionError(actionQueue, actionNode, error) {
		var last = actionQueue.pending;
		actionQueue.pending = null;
		if (null !== last) {
			last = last.next;
			do
				actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
			while (actionNode !== last);
		}
		actionQueue.action = null;
	}
	function notifyActionListeners(actionNode) {
		actionNode = actionNode.listeners;
		for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
	}
	function actionStateReducer(oldState, newState) {
		return newState;
	}
	function mountActionState(action, initialStateProp) {
		if (isHydrating) {
			var ssrFormState = workInProgressRoot.formState;
			if (null !== ssrFormState) {
				a: {
					var JSCompiler_inline_result = currentlyRenderingFiber;
					if (isHydrating) {
						if (nextHydratableInstance) {
							b: {
								var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
								for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType;) {
									if (!inRootOrSingleton) {
										JSCompiler_inline_result$jscomp$0 = null;
										break b;
									}
									JSCompiler_inline_result$jscomp$0 = getNextHydratable(JSCompiler_inline_result$jscomp$0.nextSibling);
									if (null === JSCompiler_inline_result$jscomp$0) {
										JSCompiler_inline_result$jscomp$0 = null;
										break b;
									}
								}
								inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
								JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
							}
							if (JSCompiler_inline_result$jscomp$0) {
								nextHydratableInstance = getNextHydratable(JSCompiler_inline_result$jscomp$0.nextSibling);
								JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
								break a;
							}
						}
						throwOnHydrationMismatch(JSCompiler_inline_result);
					}
					JSCompiler_inline_result = !1;
				}
				JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
			}
		}
		ssrFormState = mountWorkInProgressHook();
		ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
		JSCompiler_inline_result = {
			pending: null,
			lanes: 0,
			dispatch: null,
			lastRenderedReducer: actionStateReducer,
			lastRenderedState: initialStateProp
		};
		ssrFormState.queue = JSCompiler_inline_result;
		ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber, JSCompiler_inline_result);
		JSCompiler_inline_result.dispatch = ssrFormState;
		JSCompiler_inline_result = mountStateImpl(!1);
		inRootOrSingleton = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, !1, JSCompiler_inline_result.queue);
		JSCompiler_inline_result = mountWorkInProgressHook();
		JSCompiler_inline_result$jscomp$0 = {
			state: initialStateProp,
			dispatch: null,
			action,
			pending: null
		};
		JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
		ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber, JSCompiler_inline_result$jscomp$0, inRootOrSingleton, ssrFormState);
		JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
		JSCompiler_inline_result.memoizedState = action;
		return [
			initialStateProp,
			ssrFormState,
			!1
		];
	}
	function updateActionState(action) {
		return updateActionStateImpl(updateWorkInProgressHook(), currentHook, action);
	}
	function updateActionStateImpl(stateHook, currentStateHook, action) {
		currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];
		stateHook = updateReducer(basicStateReducer)[0];
		if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then) try {
			var state = useThenable(currentStateHook);
		} catch (x) {
			if (x === SuspenseException) throw SuspenseActionException;
			throw x;
		}
		else state = currentStateHook;
		currentStateHook = updateWorkInProgressHook();
		var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
		action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(9, { destroy: void 0 }, actionStateActionEffect.bind(null, actionQueue, action), null));
		return [
			state,
			dispatch,
			stateHook
		];
	}
	function actionStateActionEffect(actionQueue, action) {
		actionQueue.action = action;
	}
	function rerenderActionState(action) {
		var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
		if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);
		updateWorkInProgressHook();
		stateHook = stateHook.memoizedState;
		currentStateHook = updateWorkInProgressHook();
		var dispatch = currentStateHook.queue.dispatch;
		currentStateHook.memoizedState = action;
		return [
			stateHook,
			dispatch,
			!1
		];
	}
	function pushSimpleEffect(tag, inst, create$1, deps) {
		tag = {
			tag,
			create: create$1,
			deps,
			inst,
			next: null
		};
		inst = currentlyRenderingFiber.updateQueue;
		null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
		create$1 = inst.lastEffect;
		null === create$1 ? inst.lastEffect = tag.next = tag : (deps = create$1.next, create$1.next = tag, tag.next = deps, inst.lastEffect = tag);
		return tag;
	}
	function updateRef() {
		return updateWorkInProgressHook().memoizedState;
	}
	function mountEffectImpl(fiberFlags, hookFlags, create$1, deps) {
		var hook = mountWorkInProgressHook();
		currentlyRenderingFiber.flags |= fiberFlags;
		hook.memoizedState = pushSimpleEffect(1 | hookFlags, { destroy: void 0 }, create$1, void 0 === deps ? null : deps);
	}
	function updateEffectImpl(fiberFlags, hookFlags, create$1, deps) {
		var hook = updateWorkInProgressHook();
		deps = void 0 === deps ? null : deps;
		var inst = hook.memoizedState.inst;
		null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create$1, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(1 | hookFlags, inst, create$1, deps));
	}
	function mountEffect(create$1, deps) {
		mountEffectImpl(8390656, 8, create$1, deps);
	}
	function updateEffect(create$1, deps) {
		updateEffectImpl(2048, 8, create$1, deps);
	}
	function useEffectEventImpl(payload) {
		currentlyRenderingFiber.flags |= 4;
		var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
		if (null === componentUpdateQueue) componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
		else {
			var events = componentUpdateQueue.events;
			null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
		}
	}
	function updateEvent(callback) {
		var ref = updateWorkInProgressHook().memoizedState;
		useEffectEventImpl({
			ref,
			nextImpl: callback
		});
		return function() {
			if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
			return ref.impl.apply(void 0, arguments);
		};
	}
	function updateInsertionEffect(create$1, deps) {
		return updateEffectImpl(4, 2, create$1, deps);
	}
	function updateLayoutEffect(create$1, deps) {
		return updateEffectImpl(4, 4, create$1, deps);
	}
	function imperativeHandleEffect(create$1, ref) {
		if ("function" === typeof ref) {
			create$1 = create$1();
			var refCleanup = ref(create$1);
			return function() {
				"function" === typeof refCleanup ? refCleanup() : ref(null);
			};
		}
		if (null !== ref && void 0 !== ref) return create$1 = create$1(), ref.current = create$1, function() {
			ref.current = null;
		};
	}
	function updateImperativeHandle(ref, create$1, deps) {
		deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
		updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create$1, ref), deps);
	}
	function mountDebugValue() {}
	function updateCallback(callback, deps) {
		var hook = updateWorkInProgressHook();
		deps = void 0 === deps ? null : deps;
		var prevState = hook.memoizedState;
		if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
		hook.memoizedState = [callback, deps];
		return callback;
	}
	function updateMemo(nextCreate, deps) {
		var hook = updateWorkInProgressHook();
		deps = void 0 === deps ? null : deps;
		var prevState = hook.memoizedState;
		if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
		prevState = nextCreate();
		if (shouldDoubleInvokeUserFnsInHooksDEV) {
			setIsStrictModeForDevtools(!0);
			try {
				nextCreate();
			} finally {
				setIsStrictModeForDevtools(!1);
			}
		}
		hook.memoizedState = [prevState, deps];
		return prevState;
	}
	function mountDeferredValueImpl(hook, value, initialValue) {
		if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930)) return hook.memoizedState = value;
		hook.memoizedState = initialValue;
		hook = requestDeferredLane();
		currentlyRenderingFiber.lanes |= hook;
		workInProgressRootSkippedLanes |= hook;
		return initialValue;
	}
	function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
		if (objectIs(value, prevValue)) return value;
		if (null !== currentTreeHiddenStackCursor.current) return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = !0), hook;
		if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930)) return didReceiveUpdate = !0, hook.memoizedState = value;
		hook = requestDeferredLane();
		currentlyRenderingFiber.lanes |= hook;
		workInProgressRootSkippedLanes |= hook;
		return prevValue;
	}
	function startTransition(fiber, queue, pendingState, finishedState, callback) {
		var previousPriority = ReactDOMSharedInternals.p;
		ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
		var prevTransition = ReactSharedInternals.T, currentTransition = {};
		ReactSharedInternals.T = currentTransition;
		dispatchOptimisticSetState(fiber, !1, queue, pendingState);
		try {
			var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
			null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
			if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) dispatchSetStateInternal(fiber, queue, chainThenableValue(returnValue, finishedState), requestUpdateLane(fiber));
			else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));
		} catch (error) {
			dispatchSetStateInternal(fiber, queue, {
				then: function() {},
				status: "rejected",
				reason: error
			}, requestUpdateLane());
		} finally {
			ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
		}
	}
	function noop$2() {}
	function startHostTransition(formFiber, pendingState, action, formData) {
		if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
		var queue = ensureFormComponentIsStateful(formFiber).queue;
		startTransition(formFiber, queue, pendingState, sharedNotPendingObject, null === action ? noop$2 : function() {
			requestFormReset$1(formFiber);
			return action(formData);
		});
	}
	function ensureFormComponentIsStateful(formFiber) {
		var existingStateHook = formFiber.memoizedState;
		if (null !== existingStateHook) return existingStateHook;
		existingStateHook = {
			memoizedState: sharedNotPendingObject,
			baseState: sharedNotPendingObject,
			baseQueue: null,
			queue: {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: basicStateReducer,
				lastRenderedState: sharedNotPendingObject
			},
			next: null
		};
		var initialResetState = {};
		existingStateHook.next = {
			memoizedState: initialResetState,
			baseState: initialResetState,
			baseQueue: null,
			queue: {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: basicStateReducer,
				lastRenderedState: initialResetState
			},
			next: null
		};
		formFiber.memoizedState = existingStateHook;
		formFiber = formFiber.alternate;
		null !== formFiber && (formFiber.memoizedState = existingStateHook);
		return existingStateHook;
	}
	function requestFormReset$1(formFiber) {
		var stateHook = ensureFormComponentIsStateful(formFiber);
		null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
		dispatchSetStateInternal(formFiber, stateHook.next.queue, {}, requestUpdateLane());
	}
	function useHostTransitionStatus() {
		return readContext(HostTransitionContext);
	}
	function updateId() {
		return updateWorkInProgressHook().memoizedState;
	}
	function updateRefresh() {
		return updateWorkInProgressHook().memoizedState;
	}
	function refreshCache(fiber) {
		for (var provider = fiber.return; null !== provider;) {
			switch (provider.tag) {
				case 24:
				case 3:
					var lane = requestUpdateLane();
					fiber = createUpdate(lane);
					var root$69 = enqueueUpdate(provider, fiber, lane);
					null !== root$69 && (scheduleUpdateOnFiber(root$69, provider, lane), entangleTransitions(root$69, provider, lane));
					provider = { cache: createCache() };
					fiber.payload = provider;
					return;
			}
			provider = provider.return;
		}
	}
	function dispatchReducerAction(fiber, queue, action) {
		var lane = requestUpdateLane();
		action = {
			lane,
			revertLane: 0,
			gesture: null,
			action,
			hasEagerState: !1,
			eagerState: null,
			next: null
		};
		isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
	}
	function dispatchSetState(fiber, queue, action) {
		dispatchSetStateInternal(fiber, queue, action, requestUpdateLane());
	}
	function dispatchSetStateInternal(fiber, queue, action, lane) {
		var update = {
			lane,
			revertLane: 0,
			gesture: null,
			action,
			hasEagerState: !1,
			eagerState: null,
			next: null
		};
		if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
		else {
			var alternate = fiber.alternate;
			if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) try {
				var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
				update.hasEagerState = !0;
				update.eagerState = eagerState;
				if (objectIs(eagerState, currentState)) return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), !1;
			} catch (error) {}
			action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
			if (null !== action) return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), !0;
		}
		return !1;
	}
	function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
		action = {
			lane: 2,
			revertLane: requestTransitionLane(),
			gesture: null,
			action,
			hasEagerState: !1,
			eagerState: null,
			next: null
		};
		if (isRenderPhaseUpdate(fiber)) {
			if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
		} else throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
	}
	function isRenderPhaseUpdate(fiber) {
		var alternate = fiber.alternate;
		return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
	}
	function enqueueRenderPhaseUpdate(queue, update) {
		didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;
		var pending = queue.pending;
		null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
		queue.pending = update;
	}
	function entangleTransitionUpdate(root$1, queue, lane) {
		if (0 !== (lane & 4194048)) {
			var queueLanes = queue.lanes;
			queueLanes &= root$1.pendingLanes;
			lane |= queueLanes;
			queue.lanes = lane;
			markRootEntangled(root$1, lane);
		}
	}
	var ContextOnlyDispatcher = {
		readContext,
		use,
		useCallback: throwInvalidHookError,
		useContext: throwInvalidHookError,
		useEffect: throwInvalidHookError,
		useImperativeHandle: throwInvalidHookError,
		useLayoutEffect: throwInvalidHookError,
		useInsertionEffect: throwInvalidHookError,
		useMemo: throwInvalidHookError,
		useReducer: throwInvalidHookError,
		useRef: throwInvalidHookError,
		useState: throwInvalidHookError,
		useDebugValue: throwInvalidHookError,
		useDeferredValue: throwInvalidHookError,
		useTransition: throwInvalidHookError,
		useSyncExternalStore: throwInvalidHookError,
		useId: throwInvalidHookError,
		useHostTransitionStatus: throwInvalidHookError,
		useFormState: throwInvalidHookError,
		useActionState: throwInvalidHookError,
		useOptimistic: throwInvalidHookError,
		useMemoCache: throwInvalidHookError,
		useCacheRefresh: throwInvalidHookError
	};
	ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
	var HooksDispatcherOnMount = {
		readContext,
		use,
		useCallback: function(callback, deps) {
			mountWorkInProgressHook().memoizedState = [callback, void 0 === deps ? null : deps];
			return callback;
		},
		useContext: readContext,
		useEffect: mountEffect,
		useImperativeHandle: function(ref, create$1, deps) {
			deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
			mountEffectImpl(4194308, 4, imperativeHandleEffect.bind(null, create$1, ref), deps);
		},
		useLayoutEffect: function(create$1, deps) {
			return mountEffectImpl(4194308, 4, create$1, deps);
		},
		useInsertionEffect: function(create$1, deps) {
			mountEffectImpl(4, 2, create$1, deps);
		},
		useMemo: function(nextCreate, deps) {
			var hook = mountWorkInProgressHook();
			deps = void 0 === deps ? null : deps;
			var nextValue = nextCreate();
			if (shouldDoubleInvokeUserFnsInHooksDEV) {
				setIsStrictModeForDevtools(!0);
				try {
					nextCreate();
				} finally {
					setIsStrictModeForDevtools(!1);
				}
			}
			hook.memoizedState = [nextValue, deps];
			return nextValue;
		},
		useReducer: function(reducer, initialArg, init) {
			var hook = mountWorkInProgressHook();
			if (void 0 !== init) {
				var initialState = init(initialArg);
				if (shouldDoubleInvokeUserFnsInHooksDEV) {
					setIsStrictModeForDevtools(!0);
					try {
						init(initialArg);
					} finally {
						setIsStrictModeForDevtools(!1);
					}
				}
			} else initialState = initialArg;
			hook.memoizedState = hook.baseState = initialState;
			reducer = {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: reducer,
				lastRenderedState: initialState
			};
			hook.queue = reducer;
			reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, reducer);
			return [hook.memoizedState, reducer];
		},
		useRef: function(initialValue) {
			var hook = mountWorkInProgressHook();
			initialValue = { current: initialValue };
			return hook.memoizedState = initialValue;
		},
		useState: function(initialState) {
			initialState = mountStateImpl(initialState);
			var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
			queue.dispatch = dispatch;
			return [initialState.memoizedState, dispatch];
		},
		useDebugValue: mountDebugValue,
		useDeferredValue: function(value, initialValue) {
			return mountDeferredValueImpl(mountWorkInProgressHook(), value, initialValue);
		},
		useTransition: function() {
			var stateHook = mountStateImpl(!1);
			stateHook = startTransition.bind(null, currentlyRenderingFiber, stateHook.queue, !0, !1);
			mountWorkInProgressHook().memoizedState = stateHook;
			return [!1, stateHook];
		},
		useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
			var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
			if (isHydrating) {
				if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
				getServerSnapshot = getServerSnapshot();
			} else {
				getServerSnapshot = getSnapshot();
				if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
				0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
			}
			hook.memoizedState = getServerSnapshot;
			var inst = {
				value: getServerSnapshot,
				getSnapshot
			};
			hook.queue = inst;
			mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
			fiber.flags |= 2048;
			pushSimpleEffect(9, { destroy: void 0 }, updateStoreInstance.bind(null, fiber, inst, getServerSnapshot, getSnapshot), null);
			return getServerSnapshot;
		},
		useId: function() {
			var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
			if (isHydrating) {
				var JSCompiler_inline_result = treeContextOverflow;
				var idWithLeadingBit = treeContextId;
				JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
				identifierPrefix = "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
				JSCompiler_inline_result = localIdCounter++;
				0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
				identifierPrefix += "_";
			} else JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + JSCompiler_inline_result.toString(32) + "_";
			return hook.memoizedState = identifierPrefix;
		},
		useHostTransitionStatus,
		useFormState: mountActionState,
		useActionState: mountActionState,
		useOptimistic: function(passthrough) {
			var hook = mountWorkInProgressHook();
			hook.memoizedState = hook.baseState = passthrough;
			var queue = {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: null,
				lastRenderedState: null
			};
			hook.queue = queue;
			hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, !0, queue);
			queue.dispatch = hook;
			return [passthrough, hook];
		},
		useMemoCache,
		useCacheRefresh: function() {
			return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber);
		},
		useEffectEvent: function(callback) {
			var hook = mountWorkInProgressHook(), ref = { impl: callback };
			hook.memoizedState = ref;
			return function() {
				if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
				return ref.impl.apply(void 0, arguments);
			};
		}
	}, HooksDispatcherOnUpdate = {
		readContext,
		use,
		useCallback: updateCallback,
		useContext: readContext,
		useEffect: updateEffect,
		useImperativeHandle: updateImperativeHandle,
		useInsertionEffect: updateInsertionEffect,
		useLayoutEffect: updateLayoutEffect,
		useMemo: updateMemo,
		useReducer: updateReducer,
		useRef: updateRef,
		useState: function() {
			return updateReducer(basicStateReducer);
		},
		useDebugValue: mountDebugValue,
		useDeferredValue: function(value, initialValue) {
			return updateDeferredValueImpl(updateWorkInProgressHook(), currentHook.memoizedState, value, initialValue);
		},
		useTransition: function() {
			var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
			return ["boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable), start];
		},
		useSyncExternalStore: updateSyncExternalStore,
		useId: updateId,
		useHostTransitionStatus,
		useFormState: updateActionState,
		useActionState: updateActionState,
		useOptimistic: function(passthrough, reducer) {
			return updateOptimisticImpl(updateWorkInProgressHook(), currentHook, passthrough, reducer);
		},
		useMemoCache,
		useCacheRefresh: updateRefresh
	};
	HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
	var HooksDispatcherOnRerender = {
		readContext,
		use,
		useCallback: updateCallback,
		useContext: readContext,
		useEffect: updateEffect,
		useImperativeHandle: updateImperativeHandle,
		useInsertionEffect: updateInsertionEffect,
		useLayoutEffect: updateLayoutEffect,
		useMemo: updateMemo,
		useReducer: rerenderReducer,
		useRef: updateRef,
		useState: function() {
			return rerenderReducer(basicStateReducer);
		},
		useDebugValue: mountDebugValue,
		useDeferredValue: function(value, initialValue) {
			var hook = updateWorkInProgressHook();
			return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
		},
		useTransition: function() {
			var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
			return ["boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable), start];
		},
		useSyncExternalStore: updateSyncExternalStore,
		useId: updateId,
		useHostTransitionStatus,
		useFormState: rerenderActionState,
		useActionState: rerenderActionState,
		useOptimistic: function(passthrough, reducer) {
			var hook = updateWorkInProgressHook();
			if (null !== currentHook) return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
			hook.baseState = passthrough;
			return [passthrough, hook.queue.dispatch];
		},
		useMemoCache,
		useCacheRefresh: updateRefresh
	};
	HooksDispatcherOnRerender.useEffectEvent = updateEvent;
	function applyDerivedStateFromProps(workInProgress$1, ctor, getDerivedStateFromProps, nextProps) {
		ctor = workInProgress$1.memoizedState;
		getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
		getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
		workInProgress$1.memoizedState = getDerivedStateFromProps;
		0 === workInProgress$1.lanes && (workInProgress$1.updateQueue.baseState = getDerivedStateFromProps);
	}
	var classComponentUpdater = {
		enqueueSetState: function(inst, payload, callback) {
			inst = inst._reactInternals;
			var lane = requestUpdateLane(), update = createUpdate(lane);
			update.payload = payload;
			void 0 !== callback && null !== callback && (update.callback = callback);
			payload = enqueueUpdate(inst, update, lane);
			null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
		},
		enqueueReplaceState: function(inst, payload, callback) {
			inst = inst._reactInternals;
			var lane = requestUpdateLane(), update = createUpdate(lane);
			update.tag = 1;
			update.payload = payload;
			void 0 !== callback && null !== callback && (update.callback = callback);
			payload = enqueueUpdate(inst, update, lane);
			null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
		},
		enqueueForceUpdate: function(inst, callback) {
			inst = inst._reactInternals;
			var lane = requestUpdateLane(), update = createUpdate(lane);
			update.tag = 2;
			void 0 !== callback && null !== callback && (update.callback = callback);
			callback = enqueueUpdate(inst, update, lane);
			null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
		}
	};
	function checkShouldComponentUpdate(workInProgress$1, ctor, oldProps, newProps, oldState, newState, nextContext) {
		workInProgress$1 = workInProgress$1.stateNode;
		return "function" === typeof workInProgress$1.shouldComponentUpdate ? workInProgress$1.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;
	}
	function callComponentWillReceiveProps(workInProgress$1, instance, newProps, nextContext) {
		workInProgress$1 = instance.state;
		"function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
		"function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
		instance.state !== workInProgress$1 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
	}
	function resolveClassComponentProps(Component$1, baseProps) {
		var newProps = baseProps;
		if ("ref" in baseProps) {
			newProps = {};
			for (var propName in baseProps) "ref" !== propName && (newProps[propName] = baseProps[propName]);
		}
		if (Component$1 = Component$1.defaultProps) {
			newProps === baseProps && (newProps = assign({}, newProps));
			for (var propName$73 in Component$1) void 0 === newProps[propName$73] && (newProps[propName$73] = Component$1[propName$73]);
		}
		return newProps;
	}
	function defaultOnUncaughtError(error) {
		reportGlobalError(error);
	}
	function defaultOnCaughtError(error) {
		console.error(error);
	}
	function defaultOnRecoverableError(error) {
		reportGlobalError(error);
	}
	function logUncaughtError(root$1, errorInfo) {
		try {
			var onUncaughtError = root$1.onUncaughtError;
			onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
		} catch (e$74) {
			setTimeout(function() {
				throw e$74;
			});
		}
	}
	function logCaughtError(root$1, boundary, errorInfo) {
		try {
			var onCaughtError = root$1.onCaughtError;
			onCaughtError(errorInfo.value, {
				componentStack: errorInfo.stack,
				errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
			});
		} catch (e$75) {
			setTimeout(function() {
				throw e$75;
			});
		}
	}
	function createRootErrorUpdate(root$1, errorInfo, lane) {
		lane = createUpdate(lane);
		lane.tag = 3;
		lane.payload = { element: null };
		lane.callback = function() {
			logUncaughtError(root$1, errorInfo);
		};
		return lane;
	}
	function createClassErrorUpdate(lane) {
		lane = createUpdate(lane);
		lane.tag = 3;
		return lane;
	}
	function initializeClassErrorUpdate(update, root$1, fiber, errorInfo) {
		var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
		if ("function" === typeof getDerivedStateFromError) {
			var error = errorInfo.value;
			update.payload = function() {
				return getDerivedStateFromError(error);
			};
			update.callback = function() {
				logCaughtError(root$1, fiber, errorInfo);
			};
		}
		var inst = fiber.stateNode;
		null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
			logCaughtError(root$1, fiber, errorInfo);
			"function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
			var stack = errorInfo.stack;
			this.componentDidCatch(errorInfo.value, { componentStack: null !== stack ? stack : "" });
		});
	}
	function throwException(root$1, returnFiber, sourceFiber, value, rootRenderLanes) {
		sourceFiber.flags |= 32768;
		if (null !== value && "object" === typeof value && "function" === typeof value.then) {
			returnFiber = sourceFiber.alternate;
			null !== returnFiber && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, !0);
			sourceFiber = suspenseHandlerStackCursor.current;
			if (null !== sourceFiber) {
				switch (sourceFiber.tag) {
					case 31:
					case 13: return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([value]) : returnFiber.add(value), attachPingListener(root$1, value, rootRenderLanes)), !1;
					case 22: return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
						transitions: null,
						markerInstances: null,
						retryQueue: new Set([value])
					}, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([value]) : sourceFiber.add(value)), attachPingListener(root$1, value, rootRenderLanes)), !1;
				}
				throw Error(formatProdErrorMessage(435, sourceFiber.tag));
			}
			attachPingListener(root$1, value, rootRenderLanes);
			renderDidSuspendDelayIfPossible();
			return !1;
		}
		if (isHydrating) return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root$1 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root$1, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), { cause: value }), queueHydrationError(createCapturedValueAtFiber(returnFiber, sourceFiber))), root$1 = root$1.current.alternate, root$1.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root$1.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root$1.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root$1, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), !1;
		var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
		wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
		null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
		4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
		if (null === returnFiber) return !0;
		value = createCapturedValueAtFiber(value, sourceFiber);
		sourceFiber = returnFiber;
		do {
			switch (sourceFiber.tag) {
				case 3: return sourceFiber.flags |= 65536, root$1 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root$1, root$1 = createRootErrorUpdate(sourceFiber.stateNode, value, root$1), enqueueCapturedUpdate(sourceFiber, root$1), !1;
				case 1: if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))) return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root$1, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), !1;
			}
			sourceFiber = sourceFiber.return;
		} while (null !== sourceFiber);
		return !1;
	}
	var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = !1;
	function reconcileChildren(current, workInProgress$1, nextChildren, renderLanes$1) {
		workInProgress$1.child = null === current ? mountChildFibers(workInProgress$1, null, nextChildren, renderLanes$1) : reconcileChildFibers(workInProgress$1, current.child, nextChildren, renderLanes$1);
	}
	function updateForwardRef(current, workInProgress$1, Component$1, nextProps, renderLanes$1) {
		Component$1 = Component$1.render;
		var ref = workInProgress$1.ref;
		if ("ref" in nextProps) {
			var propsWithoutRef = {};
			for (var key in nextProps) "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
		} else propsWithoutRef = nextProps;
		prepareToReadContext(workInProgress$1);
		nextProps = renderWithHooks(current, workInProgress$1, Component$1, propsWithoutRef, ref, renderLanes$1);
		key = checkDidRenderIdHook();
		if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress$1, renderLanes$1), bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
		isHydrating && key && pushMaterializedTreeId(workInProgress$1);
		workInProgress$1.flags |= 1;
		reconcileChildren(current, workInProgress$1, nextProps, renderLanes$1);
		return workInProgress$1.child;
	}
	function updateMemoComponent(current, workInProgress$1, Component$1, nextProps, renderLanes$1) {
		if (null === current) {
			var type = Component$1.type;
			if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component$1.compare) return workInProgress$1.tag = 15, workInProgress$1.type = type, updateSimpleMemoComponent(current, workInProgress$1, type, nextProps, renderLanes$1);
			current = createFiberFromTypeAndProps(Component$1.type, null, nextProps, workInProgress$1, workInProgress$1.mode, renderLanes$1);
			current.ref = workInProgress$1.ref;
			current.return = workInProgress$1;
			return workInProgress$1.child = current;
		}
		type = current.child;
		if (!checkScheduledUpdateOrContext(current, renderLanes$1)) {
			var prevProps = type.memoizedProps;
			Component$1 = Component$1.compare;
			Component$1 = null !== Component$1 ? Component$1 : shallowEqual;
			if (Component$1(prevProps, nextProps) && current.ref === workInProgress$1.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
		}
		workInProgress$1.flags |= 1;
		current = createWorkInProgress(type, nextProps);
		current.ref = workInProgress$1.ref;
		current.return = workInProgress$1;
		return workInProgress$1.child = current;
	}
	function updateSimpleMemoComponent(current, workInProgress$1, Component$1, nextProps, renderLanes$1) {
		if (null !== current) {
			var prevProps = current.memoizedProps;
			if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress$1.ref) if (didReceiveUpdate = !1, workInProgress$1.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes$1)) 0 !== (current.flags & 131072) && (didReceiveUpdate = !0);
			else return workInProgress$1.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
		}
		return updateFunctionComponent(current, workInProgress$1, Component$1, nextProps, renderLanes$1);
	}
	function updateOffscreenComponent(current, workInProgress$1, renderLanes$1, nextProps) {
		var nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
		null === current && null === workInProgress$1.stateNode && (workInProgress$1.stateNode = {
			_visibility: 1,
			_pendingMarkers: null,
			_retryCache: null,
			_transitions: null
		});
		if ("hidden" === nextProps.mode) {
			if (0 !== (workInProgress$1.flags & 128)) {
				prevState = null !== prevState ? prevState.baseLanes | renderLanes$1 : renderLanes$1;
				if (null !== current) {
					nextProps = workInProgress$1.child = current.child;
					for (nextChildren = 0; null !== nextProps;) nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
					nextProps = nextChildren & ~prevState;
				} else nextProps = 0, workInProgress$1.child = null;
				return deferHiddenOffscreenComponent(current, workInProgress$1, prevState, renderLanes$1, nextProps);
			}
			if (0 !== (renderLanes$1 & 536870912)) workInProgress$1.memoizedState = {
				baseLanes: 0,
				cachePool: null
			}, null !== current && pushTransition(workInProgress$1, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(workInProgress$1, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress$1);
			else return nextProps = workInProgress$1.lanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress$1, null !== prevState ? prevState.baseLanes | renderLanes$1 : renderLanes$1, renderLanes$1, nextProps);
		} else null !== prevState ? (pushTransition(workInProgress$1, prevState.cachePool), pushHiddenContext(workInProgress$1, prevState), reuseSuspenseHandlerOnStack(workInProgress$1), workInProgress$1.memoizedState = null) : (null !== current && pushTransition(workInProgress$1, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack(workInProgress$1));
		reconcileChildren(current, workInProgress$1, nextChildren, renderLanes$1);
		return workInProgress$1.child;
	}
	function bailoutOffscreenComponent(current, workInProgress$1) {
		null !== current && 22 === current.tag || null !== workInProgress$1.stateNode || (workInProgress$1.stateNode = {
			_visibility: 1,
			_pendingMarkers: null,
			_retryCache: null,
			_transitions: null
		});
		return workInProgress$1.sibling;
	}
	function deferHiddenOffscreenComponent(current, workInProgress$1, nextBaseLanes, renderLanes$1, remainingChildLanes) {
		var JSCompiler_inline_result = peekCacheFromPool();
		JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
			parent: CacheContext._currentValue,
			pool: JSCompiler_inline_result
		};
		workInProgress$1.memoizedState = {
			baseLanes: nextBaseLanes,
			cachePool: JSCompiler_inline_result
		};
		null !== current && pushTransition(workInProgress$1, null);
		reuseHiddenContextOnStack();
		pushOffscreenSuspenseHandler(workInProgress$1);
		null !== current && propagateParentContextChanges(current, workInProgress$1, renderLanes$1, !0);
		workInProgress$1.childLanes = remainingChildLanes;
		return null;
	}
	function mountActivityChildren(workInProgress$1, nextProps) {
		nextProps = mountWorkInProgressOffscreenFiber({
			mode: nextProps.mode,
			children: nextProps.children
		}, workInProgress$1.mode);
		nextProps.ref = workInProgress$1.ref;
		workInProgress$1.child = nextProps;
		nextProps.return = workInProgress$1;
		return nextProps;
	}
	function retryActivityComponentWithoutHydrating(current, workInProgress$1, renderLanes$1) {
		reconcileChildFibers(workInProgress$1, current.child, null, renderLanes$1);
		current = mountActivityChildren(workInProgress$1, workInProgress$1.pendingProps);
		current.flags |= 2;
		popSuspenseHandler(workInProgress$1);
		workInProgress$1.memoizedState = null;
		return current;
	}
	function updateActivityComponent(current, workInProgress$1, renderLanes$1) {
		var nextProps = workInProgress$1.pendingProps, didSuspend = 0 !== (workInProgress$1.flags & 128);
		workInProgress$1.flags &= -129;
		if (null === current) {
			if (isHydrating) {
				if ("hidden" === nextProps.mode) return current = mountActivityChildren(workInProgress$1, nextProps), workInProgress$1.lanes = 536870912, bailoutOffscreenComponent(null, current);
				pushDehydratedActivitySuspenseHandler(workInProgress$1);
				(current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(current, rootOrSingletonContext), current = null !== current && "&" === current.data ? current : null, null !== current && (workInProgress$1.memoizedState = {
					dehydrated: current,
					treeContext: null !== treeContextProvider ? {
						id: treeContextId,
						overflow: treeContextOverflow
					} : null,
					retryLane: 536870912,
					hydrationErrors: null
				}, renderLanes$1 = createFiberFromDehydratedFragment(current), renderLanes$1.return = workInProgress$1, workInProgress$1.child = renderLanes$1, hydrationParentFiber = workInProgress$1, nextHydratableInstance = null)) : current = null;
				if (null === current) throw throwOnHydrationMismatch(workInProgress$1);
				workInProgress$1.lanes = 536870912;
				return null;
			}
			return mountActivityChildren(workInProgress$1, nextProps);
		}
		var prevState = current.memoizedState;
		if (null !== prevState) {
			var dehydrated = prevState.dehydrated;
			pushDehydratedActivitySuspenseHandler(workInProgress$1);
			if (didSuspend) if (workInProgress$1.flags & 256) workInProgress$1.flags &= -257, workInProgress$1 = retryActivityComponentWithoutHydrating(current, workInProgress$1, renderLanes$1);
			else if (null !== workInProgress$1.memoizedState) workInProgress$1.child = current.child, workInProgress$1.flags |= 128, workInProgress$1 = null;
			else throw Error(formatProdErrorMessage(558));
			else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress$1, renderLanes$1, !1), didSuspend = 0 !== (renderLanes$1 & current.childLanes), didReceiveUpdate || didSuspend) {
				nextProps = workInProgressRoot;
				if (null !== nextProps && (dehydrated = getBumpedLaneForHydration(nextProps, renderLanes$1), 0 !== dehydrated && dehydrated !== prevState.retryLane)) throw prevState.retryLane = dehydrated, enqueueConcurrentRenderForLane(current, dehydrated), scheduleUpdateOnFiber(nextProps, current, dehydrated), SelectiveHydrationException;
				renderDidSuspendDelayIfPossible();
				workInProgress$1 = retryActivityComponentWithoutHydrating(current, workInProgress$1, renderLanes$1);
			} else current = prevState.treeContext, nextHydratableInstance = getNextHydratable(dehydrated.nextSibling), hydrationParentFiber = workInProgress$1, isHydrating = !0, hydrationErrors = null, rootOrSingletonContext = !1, null !== current && restoreSuspendedTreeContext(workInProgress$1, current), workInProgress$1 = mountActivityChildren(workInProgress$1, nextProps), workInProgress$1.flags |= 4096;
			return workInProgress$1;
		}
		current = createWorkInProgress(current.child, {
			mode: nextProps.mode,
			children: nextProps.children
		});
		current.ref = workInProgress$1.ref;
		workInProgress$1.child = current;
		current.return = workInProgress$1;
		return current;
	}
	function markRef(current, workInProgress$1) {
		var ref = workInProgress$1.ref;
		if (null === ref) null !== current && null !== current.ref && (workInProgress$1.flags |= 4194816);
		else {
			if ("function" !== typeof ref && "object" !== typeof ref) throw Error(formatProdErrorMessage(284));
			if (null === current || current.ref !== ref) workInProgress$1.flags |= 4194816;
		}
	}
	function updateFunctionComponent(current, workInProgress$1, Component$1, nextProps, renderLanes$1) {
		prepareToReadContext(workInProgress$1);
		Component$1 = renderWithHooks(current, workInProgress$1, Component$1, nextProps, void 0, renderLanes$1);
		nextProps = checkDidRenderIdHook();
		if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress$1, renderLanes$1), bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
		isHydrating && nextProps && pushMaterializedTreeId(workInProgress$1);
		workInProgress$1.flags |= 1;
		reconcileChildren(current, workInProgress$1, Component$1, renderLanes$1);
		return workInProgress$1.child;
	}
	function replayFunctionComponent(current, workInProgress$1, nextProps, Component$1, secondArg, renderLanes$1) {
		prepareToReadContext(workInProgress$1);
		workInProgress$1.updateQueue = null;
		nextProps = renderWithHooksAgain(workInProgress$1, Component$1, nextProps, secondArg);
		finishRenderingHooks(current);
		Component$1 = checkDidRenderIdHook();
		if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress$1, renderLanes$1), bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
		isHydrating && Component$1 && pushMaterializedTreeId(workInProgress$1);
		workInProgress$1.flags |= 1;
		reconcileChildren(current, workInProgress$1, nextProps, renderLanes$1);
		return workInProgress$1.child;
	}
	function updateClassComponent(current, workInProgress$1, Component$1, nextProps, renderLanes$1) {
		prepareToReadContext(workInProgress$1);
		if (null === workInProgress$1.stateNode) {
			var context = emptyContextObject, contextType = Component$1.contextType;
			"object" === typeof contextType && null !== contextType && (context = readContext(contextType));
			context = new Component$1(nextProps, context);
			workInProgress$1.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
			context.updater = classComponentUpdater;
			workInProgress$1.stateNode = context;
			context._reactInternals = workInProgress$1;
			context = workInProgress$1.stateNode;
			context.props = nextProps;
			context.state = workInProgress$1.memoizedState;
			context.refs = {};
			initializeUpdateQueue(workInProgress$1);
			contextType = Component$1.contextType;
			context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
			context.state = workInProgress$1.memoizedState;
			contextType = Component$1.getDerivedStateFromProps;
			"function" === typeof contextType && (applyDerivedStateFromProps(workInProgress$1, Component$1, contextType, nextProps), context.state = workInProgress$1.memoizedState);
			"function" === typeof Component$1.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress$1, nextProps, context, renderLanes$1), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress$1.memoizedState);
			"function" === typeof context.componentDidMount && (workInProgress$1.flags |= 4194308);
			nextProps = !0;
		} else if (null === current) {
			context = workInProgress$1.stateNode;
			var unresolvedOldProps = workInProgress$1.memoizedProps, oldProps = resolveClassComponentProps(Component$1, unresolvedOldProps);
			context.props = oldProps;
			var oldContext = context.context, contextType$jscomp$0 = Component$1.contextType;
			contextType = emptyContextObject;
			"object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
			var getDerivedStateFromProps = Component$1.getDerivedStateFromProps;
			contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
			unresolvedOldProps = workInProgress$1.pendingProps !== unresolvedOldProps;
			contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(workInProgress$1, context, nextProps, contextType);
			hasForceUpdate = !1;
			var oldState = workInProgress$1.memoizedState;
			context.state = oldState;
			processUpdateQueue(workInProgress$1, nextProps, context, renderLanes$1);
			suspendIfUpdateReadFromEntangledAsyncAction();
			oldContext = workInProgress$1.memoizedState;
			unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(workInProgress$1, Component$1, getDerivedStateFromProps, nextProps), oldContext = workInProgress$1.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(workInProgress$1, Component$1, oldProps, nextProps, oldState, oldContext, contextType)) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress$1.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress$1.flags |= 4194308), workInProgress$1.memoizedProps = nextProps, workInProgress$1.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress$1.flags |= 4194308), nextProps = !1);
		} else {
			context = workInProgress$1.stateNode;
			cloneUpdateQueue(current, workInProgress$1);
			contextType = workInProgress$1.memoizedProps;
			contextType$jscomp$0 = resolveClassComponentProps(Component$1, contextType);
			context.props = contextType$jscomp$0;
			getDerivedStateFromProps = workInProgress$1.pendingProps;
			oldState = context.context;
			oldContext = Component$1.contextType;
			oldProps = emptyContextObject;
			"object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
			unresolvedOldProps = Component$1.getDerivedStateFromProps;
			(oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(workInProgress$1, context, nextProps, oldProps);
			hasForceUpdate = !1;
			oldState = workInProgress$1.memoizedState;
			context.state = oldState;
			processUpdateQueue(workInProgress$1, nextProps, context, renderLanes$1);
			suspendIfUpdateReadFromEntangledAsyncAction();
			var newState = workInProgress$1.memoizedState;
			contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress$1, Component$1, unresolvedOldProps, nextProps), newState = workInProgress$1.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(workInProgress$1, Component$1, contextType$jscomp$0, nextProps, oldState, newState, oldProps) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(nextProps, newState, oldProps)), "function" === typeof context.componentDidUpdate && (workInProgress$1.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress$1.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress$1.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress$1.flags |= 1024), workInProgress$1.memoizedProps = nextProps, workInProgress$1.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress$1.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress$1.flags |= 1024), nextProps = !1);
		}
		context = nextProps;
		markRef(current, workInProgress$1);
		nextProps = 0 !== (workInProgress$1.flags & 128);
		context || nextProps ? (context = workInProgress$1.stateNode, Component$1 = nextProps && "function" !== typeof Component$1.getDerivedStateFromError ? null : context.render(), workInProgress$1.flags |= 1, null !== current && nextProps ? (workInProgress$1.child = reconcileChildFibers(workInProgress$1, current.child, null, renderLanes$1), workInProgress$1.child = reconcileChildFibers(workInProgress$1, null, Component$1, renderLanes$1)) : reconcileChildren(current, workInProgress$1, Component$1, renderLanes$1), workInProgress$1.memoizedState = context.state, current = workInProgress$1.child) : current = bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
		return current;
	}
	function mountHostRootWithoutHydrating(current, workInProgress$1, nextChildren, renderLanes$1) {
		resetHydrationState();
		workInProgress$1.flags |= 256;
		reconcileChildren(current, workInProgress$1, nextChildren, renderLanes$1);
		return workInProgress$1.child;
	}
	var SUSPENDED_MARKER = {
		dehydrated: null,
		treeContext: null,
		retryLane: 0,
		hydrationErrors: null
	};
	function mountSuspenseOffscreenState(renderLanes$1) {
		return {
			baseLanes: renderLanes$1,
			cachePool: getSuspendedCache()
		};
	}
	function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes$1) {
		current = null !== current ? current.childLanes & ~renderLanes$1 : 0;
		primaryTreeDidDefer && (current |= workInProgressDeferredLane);
		return current;
	}
	function updateSuspenseComponent(current, workInProgress$1, renderLanes$1) {
		var nextProps = workInProgress$1.pendingProps, showFallback = !1, didSuspend = 0 !== (workInProgress$1.flags & 128), JSCompiler_temp;
		(JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? !1 : 0 !== (suspenseStackCursor.current & 2));
		JSCompiler_temp && (showFallback = !0, workInProgress$1.flags &= -129);
		JSCompiler_temp = 0 !== (workInProgress$1.flags & 32);
		workInProgress$1.flags &= -33;
		if (null === current) {
			if (isHydrating) {
				showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress$1) : reuseSuspenseHandlerOnStack(workInProgress$1);
				(current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(current, rootOrSingletonContext), current = null !== current && "&" !== current.data ? current : null, null !== current && (workInProgress$1.memoizedState = {
					dehydrated: current,
					treeContext: null !== treeContextProvider ? {
						id: treeContextId,
						overflow: treeContextOverflow
					} : null,
					retryLane: 536870912,
					hydrationErrors: null
				}, renderLanes$1 = createFiberFromDehydratedFragment(current), renderLanes$1.return = workInProgress$1, workInProgress$1.child = renderLanes$1, hydrationParentFiber = workInProgress$1, nextHydratableInstance = null)) : current = null;
				if (null === current) throw throwOnHydrationMismatch(workInProgress$1);
				isSuspenseInstanceFallback(current) ? workInProgress$1.lanes = 32 : workInProgress$1.lanes = 536870912;
				return null;
			}
			var nextPrimaryChildren = nextProps.children;
			nextProps = nextProps.fallback;
			if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress$1), showFallback = workInProgress$1.mode, nextPrimaryChildren = mountWorkInProgressOffscreenFiber({
				mode: "hidden",
				children: nextPrimaryChildren
			}, showFallback), nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes$1, null), nextPrimaryChildren.return = workInProgress$1, nextProps.return = workInProgress$1, nextPrimaryChildren.sibling = nextProps, workInProgress$1.child = nextPrimaryChildren, nextProps = workInProgress$1.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes$1), nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes$1), workInProgress$1.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(null, nextProps);
			pushPrimaryTreeSuspenseHandler(workInProgress$1);
			return mountSuspensePrimaryChildren(workInProgress$1, nextPrimaryChildren);
		}
		var prevState = current.memoizedState;
		if (null !== prevState && (nextPrimaryChildren = prevState.dehydrated, null !== nextPrimaryChildren)) {
			if (didSuspend) workInProgress$1.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress$1), workInProgress$1.flags &= -257, workInProgress$1 = retrySuspenseComponentWithoutHydrating(current, workInProgress$1, renderLanes$1)) : null !== workInProgress$1.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress$1), workInProgress$1.child = current.child, workInProgress$1.flags |= 128, workInProgress$1 = null) : (reuseSuspenseHandlerOnStack(workInProgress$1), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress$1.mode, nextProps = mountWorkInProgressOffscreenFiber({
				mode: "visible",
				children: nextProps.children
			}, showFallback), nextPrimaryChildren = createFiberFromFragment(nextPrimaryChildren, showFallback, renderLanes$1, null), nextPrimaryChildren.flags |= 2, nextProps.return = workInProgress$1, nextPrimaryChildren.return = workInProgress$1, nextProps.sibling = nextPrimaryChildren, workInProgress$1.child = nextProps, reconcileChildFibers(workInProgress$1, current.child, null, renderLanes$1), nextProps = workInProgress$1.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes$1), nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes$1), workInProgress$1.memoizedState = SUSPENDED_MARKER, workInProgress$1 = bailoutOffscreenComponent(null, nextProps));
			else if (pushPrimaryTreeSuspenseHandler(workInProgress$1), isSuspenseInstanceFallback(nextPrimaryChildren)) {
				JSCompiler_temp = nextPrimaryChildren.nextSibling && nextPrimaryChildren.nextSibling.dataset;
				if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
				JSCompiler_temp = digest;
				nextProps = Error(formatProdErrorMessage(419));
				nextProps.stack = "";
				nextProps.digest = JSCompiler_temp;
				queueHydrationError({
					value: nextProps,
					source: null,
					stack: null
				});
				workInProgress$1 = retrySuspenseComponentWithoutHydrating(current, workInProgress$1, renderLanes$1);
			} else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress$1, renderLanes$1, !1), JSCompiler_temp = 0 !== (renderLanes$1 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
				JSCompiler_temp = workInProgressRoot;
				if (null !== JSCompiler_temp && (nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes$1), 0 !== nextProps && nextProps !== prevState.retryLane)) throw prevState.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
				isSuspenseInstancePending(nextPrimaryChildren) || renderDidSuspendDelayIfPossible();
				workInProgress$1 = retrySuspenseComponentWithoutHydrating(current, workInProgress$1, renderLanes$1);
			} else isSuspenseInstancePending(nextPrimaryChildren) ? (workInProgress$1.flags |= 192, workInProgress$1.child = current.child, workInProgress$1 = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(nextPrimaryChildren.nextSibling), hydrationParentFiber = workInProgress$1, isHydrating = !0, hydrationErrors = null, rootOrSingletonContext = !1, null !== current && restoreSuspendedTreeContext(workInProgress$1, current), workInProgress$1 = mountSuspensePrimaryChildren(workInProgress$1, nextProps.children), workInProgress$1.flags |= 4096);
			return workInProgress$1;
		}
		if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress$1), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress$1.mode, prevState = current.child, digest = prevState.sibling, nextProps = createWorkInProgress(prevState, {
			mode: "hidden",
			children: nextProps.children
		}), nextProps.subtreeFlags = prevState.subtreeFlags & 65011712, null !== digest ? nextPrimaryChildren = createWorkInProgress(digest, nextPrimaryChildren) : (nextPrimaryChildren = createFiberFromFragment(nextPrimaryChildren, showFallback, renderLanes$1, null), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress$1, nextProps.return = workInProgress$1, nextProps.sibling = nextPrimaryChildren, workInProgress$1.child = nextProps, bailoutOffscreenComponent(null, nextProps), nextProps = workInProgress$1.child, nextPrimaryChildren = current.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes$1) : (showFallback = nextPrimaryChildren.cachePool, null !== showFallback ? (prevState = CacheContext._currentValue, showFallback = showFallback.parent !== prevState ? {
			parent: prevState,
			pool: prevState
		} : showFallback) : showFallback = getSuspendedCache(), nextPrimaryChildren = {
			baseLanes: nextPrimaryChildren.baseLanes | renderLanes$1,
			cachePool: showFallback
		}), nextProps.memoizedState = nextPrimaryChildren, nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes$1), workInProgress$1.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current.child, nextProps);
		pushPrimaryTreeSuspenseHandler(workInProgress$1);
		renderLanes$1 = current.child;
		current = renderLanes$1.sibling;
		renderLanes$1 = createWorkInProgress(renderLanes$1, {
			mode: "visible",
			children: nextProps.children
		});
		renderLanes$1.return = workInProgress$1;
		renderLanes$1.sibling = null;
		null !== current && (JSCompiler_temp = workInProgress$1.deletions, null === JSCompiler_temp ? (workInProgress$1.deletions = [current], workInProgress$1.flags |= 16) : JSCompiler_temp.push(current));
		workInProgress$1.child = renderLanes$1;
		workInProgress$1.memoizedState = null;
		return renderLanes$1;
	}
	function mountSuspensePrimaryChildren(workInProgress$1, primaryChildren) {
		primaryChildren = mountWorkInProgressOffscreenFiber({
			mode: "visible",
			children: primaryChildren
		}, workInProgress$1.mode);
		primaryChildren.return = workInProgress$1;
		return workInProgress$1.child = primaryChildren;
	}
	function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
		offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
		offscreenProps.lanes = 0;
		return offscreenProps;
	}
	function retrySuspenseComponentWithoutHydrating(current, workInProgress$1, renderLanes$1) {
		reconcileChildFibers(workInProgress$1, current.child, null, renderLanes$1);
		current = mountSuspensePrimaryChildren(workInProgress$1, workInProgress$1.pendingProps.children);
		current.flags |= 2;
		workInProgress$1.memoizedState = null;
		return current;
	}
	function scheduleSuspenseWorkOnFiber(fiber, renderLanes$1, propagationRoot) {
		fiber.lanes |= renderLanes$1;
		var alternate = fiber.alternate;
		null !== alternate && (alternate.lanes |= renderLanes$1);
		scheduleContextWorkOnParentPath(fiber.return, renderLanes$1, propagationRoot);
	}
	function initSuspenseListRenderState(workInProgress$1, isBackwards, tail, lastContentRow, tailMode, treeForkCount$1) {
		var renderState = workInProgress$1.memoizedState;
		null === renderState ? workInProgress$1.memoizedState = {
			isBackwards,
			rendering: null,
			renderingStartTime: 0,
			last: lastContentRow,
			tail,
			tailMode,
			treeForkCount: treeForkCount$1
		} : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount$1);
	}
	function updateSuspenseListComponent(current, workInProgress$1, renderLanes$1) {
		var nextProps = workInProgress$1.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
		nextProps = nextProps.children;
		var suspenseContext = suspenseStackCursor.current, shouldForceFallback = 0 !== (suspenseContext & 2);
		shouldForceFallback ? (suspenseContext = suspenseContext & 1 | 2, workInProgress$1.flags |= 128) : suspenseContext &= 1;
		push(suspenseStackCursor, suspenseContext);
		reconcileChildren(current, workInProgress$1, nextProps, renderLanes$1);
		nextProps = isHydrating ? treeForkCount : 0;
		if (!shouldForceFallback && null !== current && 0 !== (current.flags & 128)) a: for (current = workInProgress$1.child; null !== current;) {
			if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes$1, workInProgress$1);
			else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes$1, workInProgress$1);
			else if (null !== current.child) {
				current.child.return = current;
				current = current.child;
				continue;
			}
			if (current === workInProgress$1) break a;
			for (; null === current.sibling;) {
				if (null === current.return || current.return === workInProgress$1) break a;
				current = current.return;
			}
			current.sibling.return = current.return;
			current = current.sibling;
		}
		switch (revealOrder) {
			case "forwards":
				renderLanes$1 = workInProgress$1.child;
				for (revealOrder = null; null !== renderLanes$1;) current = renderLanes$1.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes$1), renderLanes$1 = renderLanes$1.sibling;
				renderLanes$1 = revealOrder;
				null === renderLanes$1 ? (revealOrder = workInProgress$1.child, workInProgress$1.child = null) : (revealOrder = renderLanes$1.sibling, renderLanes$1.sibling = null);
				initSuspenseListRenderState(workInProgress$1, !1, revealOrder, renderLanes$1, tailMode, nextProps);
				break;
			case "backwards":
			case "unstable_legacy-backwards":
				renderLanes$1 = null;
				revealOrder = workInProgress$1.child;
				for (workInProgress$1.child = null; null !== revealOrder;) {
					current = revealOrder.alternate;
					if (null !== current && null === findFirstSuspended(current)) {
						workInProgress$1.child = revealOrder;
						break;
					}
					current = revealOrder.sibling;
					revealOrder.sibling = renderLanes$1;
					renderLanes$1 = revealOrder;
					revealOrder = current;
				}
				initSuspenseListRenderState(workInProgress$1, !0, renderLanes$1, null, tailMode, nextProps);
				break;
			case "together":
				initSuspenseListRenderState(workInProgress$1, !1, null, null, void 0, nextProps);
				break;
			default: workInProgress$1.memoizedState = null;
		}
		return workInProgress$1.child;
	}
	function bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1) {
		null !== current && (workInProgress$1.dependencies = current.dependencies);
		workInProgressRootSkippedLanes |= workInProgress$1.lanes;
		if (0 === (renderLanes$1 & workInProgress$1.childLanes)) if (null !== current) {
			if (propagateParentContextChanges(current, workInProgress$1, renderLanes$1, !1), 0 === (renderLanes$1 & workInProgress$1.childLanes)) return null;
		} else return null;
		if (null !== current && workInProgress$1.child !== current.child) throw Error(formatProdErrorMessage(153));
		if (null !== workInProgress$1.child) {
			current = workInProgress$1.child;
			renderLanes$1 = createWorkInProgress(current, current.pendingProps);
			workInProgress$1.child = renderLanes$1;
			for (renderLanes$1.return = workInProgress$1; null !== current.sibling;) current = current.sibling, renderLanes$1 = renderLanes$1.sibling = createWorkInProgress(current, current.pendingProps), renderLanes$1.return = workInProgress$1;
			renderLanes$1.sibling = null;
		}
		return workInProgress$1.child;
	}
	function checkScheduledUpdateOrContext(current, renderLanes$1) {
		if (0 !== (current.lanes & renderLanes$1)) return !0;
		current = current.dependencies;
		return null !== current && checkIfContextChanged(current) ? !0 : !1;
	}
	function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress$1, renderLanes$1) {
		switch (workInProgress$1.tag) {
			case 3:
				pushHostContainer(workInProgress$1, workInProgress$1.stateNode.containerInfo);
				pushProvider(workInProgress$1, CacheContext, current.memoizedState.cache);
				resetHydrationState();
				break;
			case 27:
			case 5:
				pushHostContext(workInProgress$1);
				break;
			case 4:
				pushHostContainer(workInProgress$1, workInProgress$1.stateNode.containerInfo);
				break;
			case 10:
				pushProvider(workInProgress$1, workInProgress$1.type, workInProgress$1.memoizedProps.value);
				break;
			case 31:
				if (null !== workInProgress$1.memoizedState) return workInProgress$1.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress$1), null;
				break;
			case 13:
				var state$102 = workInProgress$1.memoizedState;
				if (null !== state$102) {
					if (null !== state$102.dehydrated) return pushPrimaryTreeSuspenseHandler(workInProgress$1), workInProgress$1.flags |= 128, null;
					if (0 !== (renderLanes$1 & workInProgress$1.child.childLanes)) return updateSuspenseComponent(current, workInProgress$1, renderLanes$1);
					pushPrimaryTreeSuspenseHandler(workInProgress$1);
					current = bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
					return null !== current ? current.sibling : null;
				}
				pushPrimaryTreeSuspenseHandler(workInProgress$1);
				break;
			case 19:
				var didSuspendBefore = 0 !== (current.flags & 128);
				state$102 = 0 !== (renderLanes$1 & workInProgress$1.childLanes);
				state$102 || (propagateParentContextChanges(current, workInProgress$1, renderLanes$1, !1), state$102 = 0 !== (renderLanes$1 & workInProgress$1.childLanes));
				if (didSuspendBefore) {
					if (state$102) return updateSuspenseListComponent(current, workInProgress$1, renderLanes$1);
					workInProgress$1.flags |= 128;
				}
				didSuspendBefore = workInProgress$1.memoizedState;
				null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
				push(suspenseStackCursor, suspenseStackCursor.current);
				if (state$102) break;
				else return null;
			case 22: return workInProgress$1.lanes = 0, updateOffscreenComponent(current, workInProgress$1, renderLanes$1, workInProgress$1.pendingProps);
			case 24: pushProvider(workInProgress$1, CacheContext, current.memoizedState.cache);
		}
		return bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
	}
	function beginWork(current, workInProgress$1, renderLanes$1) {
		if (null !== current) if (current.memoizedProps !== workInProgress$1.pendingProps) didReceiveUpdate = !0;
		else {
			if (!checkScheduledUpdateOrContext(current, renderLanes$1) && 0 === (workInProgress$1.flags & 128)) return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress$1, renderLanes$1);
			didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
		}
		else didReceiveUpdate = !1, isHydrating && 0 !== (workInProgress$1.flags & 1048576) && pushTreeId(workInProgress$1, treeForkCount, workInProgress$1.index);
		workInProgress$1.lanes = 0;
		switch (workInProgress$1.tag) {
			case 16:
				a: {
					var props = workInProgress$1.pendingProps;
					current = resolveLazy(workInProgress$1.elementType);
					workInProgress$1.type = current;
					if ("function" === typeof current) shouldConstruct(current) ? (props = resolveClassComponentProps(current, props), workInProgress$1.tag = 1, workInProgress$1 = updateClassComponent(null, workInProgress$1, current, props, renderLanes$1)) : (workInProgress$1.tag = 0, workInProgress$1 = updateFunctionComponent(null, workInProgress$1, current, props, renderLanes$1));
					else {
						if (void 0 !== current && null !== current) {
							var $$typeof = current.$$typeof;
							if ($$typeof === REACT_FORWARD_REF_TYPE) {
								workInProgress$1.tag = 11;
								workInProgress$1 = updateForwardRef(null, workInProgress$1, current, props, renderLanes$1);
								break a;
							} else if ($$typeof === REACT_MEMO_TYPE) {
								workInProgress$1.tag = 14;
								workInProgress$1 = updateMemoComponent(null, workInProgress$1, current, props, renderLanes$1);
								break a;
							}
						}
						workInProgress$1 = getComponentNameFromType(current) || current;
						throw Error(formatProdErrorMessage(306, workInProgress$1, ""));
					}
				}
				return workInProgress$1;
			case 0: return updateFunctionComponent(current, workInProgress$1, workInProgress$1.type, workInProgress$1.pendingProps, renderLanes$1);
			case 1: return props = workInProgress$1.type, $$typeof = resolveClassComponentProps(props, workInProgress$1.pendingProps), updateClassComponent(current, workInProgress$1, props, $$typeof, renderLanes$1);
			case 3:
				a: {
					pushHostContainer(workInProgress$1, workInProgress$1.stateNode.containerInfo);
					if (null === current) throw Error(formatProdErrorMessage(387));
					props = workInProgress$1.pendingProps;
					var prevState = workInProgress$1.memoizedState;
					$$typeof = prevState.element;
					cloneUpdateQueue(current, workInProgress$1);
					processUpdateQueue(workInProgress$1, props, null, renderLanes$1);
					var nextState = workInProgress$1.memoizedState;
					props = nextState.cache;
					pushProvider(workInProgress$1, CacheContext, props);
					props !== prevState.cache && propagateContextChanges(workInProgress$1, [CacheContext], renderLanes$1, !0);
					suspendIfUpdateReadFromEntangledAsyncAction();
					props = nextState.element;
					if (prevState.isDehydrated) if (prevState = {
						element: props,
						isDehydrated: !1,
						cache: nextState.cache
					}, workInProgress$1.updateQueue.baseState = prevState, workInProgress$1.memoizedState = prevState, workInProgress$1.flags & 256) {
						workInProgress$1 = mountHostRootWithoutHydrating(current, workInProgress$1, props, renderLanes$1);
						break a;
					} else if (props !== $$typeof) {
						$$typeof = createCapturedValueAtFiber(Error(formatProdErrorMessage(424)), workInProgress$1);
						queueHydrationError($$typeof);
						workInProgress$1 = mountHostRootWithoutHydrating(current, workInProgress$1, props, renderLanes$1);
						break a;
					} else {
						current = workInProgress$1.stateNode.containerInfo;
						switch (current.nodeType) {
							case 9:
								current = current.body;
								break;
							default: current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
						}
						nextHydratableInstance = getNextHydratable(current.firstChild);
						hydrationParentFiber = workInProgress$1;
						isHydrating = !0;
						hydrationErrors = null;
						rootOrSingletonContext = !0;
						renderLanes$1 = mountChildFibers(workInProgress$1, null, props, renderLanes$1);
						for (workInProgress$1.child = renderLanes$1; renderLanes$1;) renderLanes$1.flags = renderLanes$1.flags & -3 | 4096, renderLanes$1 = renderLanes$1.sibling;
					}
					else {
						resetHydrationState();
						if (props === $$typeof) {
							workInProgress$1 = bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1);
							break a;
						}
						reconcileChildren(current, workInProgress$1, props, renderLanes$1);
					}
					workInProgress$1 = workInProgress$1.child;
				}
				return workInProgress$1;
			case 26: return markRef(current, workInProgress$1), null === current ? (renderLanes$1 = getResource(workInProgress$1.type, null, workInProgress$1.pendingProps, null)) ? workInProgress$1.memoizedState = renderLanes$1 : isHydrating || (renderLanes$1 = workInProgress$1.type, current = workInProgress$1.pendingProps, props = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current).createElement(renderLanes$1), props[internalInstanceKey] = workInProgress$1, props[internalPropsKey] = current, setInitialProperties(props, renderLanes$1, current), markNodeAsHoistable(props), workInProgress$1.stateNode = props) : workInProgress$1.memoizedState = getResource(workInProgress$1.type, current.memoizedProps, workInProgress$1.pendingProps, current.memoizedState), null;
			case 27: return pushHostContext(workInProgress$1), null === current && isHydrating && (props = workInProgress$1.stateNode = resolveSingletonInstance(workInProgress$1.type, workInProgress$1.pendingProps, rootInstanceStackCursor.current), hydrationParentFiber = workInProgress$1, rootOrSingletonContext = !0, $$typeof = nextHydratableInstance, isSingletonScope(workInProgress$1.type) ? (previousHydratableOnEnteringScopedSingleton = $$typeof, nextHydratableInstance = getNextHydratable(props.firstChild)) : nextHydratableInstance = $$typeof), reconcileChildren(current, workInProgress$1, workInProgress$1.pendingProps.children, renderLanes$1), markRef(current, workInProgress$1), null === current && (workInProgress$1.flags |= 4194304), workInProgress$1.child;
			case 5:
				if (null === current && isHydrating) {
					if ($$typeof = props = nextHydratableInstance) props = canHydrateInstance(props, workInProgress$1.type, workInProgress$1.pendingProps, rootOrSingletonContext), null !== props ? (workInProgress$1.stateNode = props, hydrationParentFiber = workInProgress$1, nextHydratableInstance = getNextHydratable(props.firstChild), rootOrSingletonContext = !1, $$typeof = !0) : $$typeof = !1;
					$$typeof || throwOnHydrationMismatch(workInProgress$1);
				}
				pushHostContext(workInProgress$1);
				$$typeof = workInProgress$1.type;
				prevState = workInProgress$1.pendingProps;
				nextState = null !== current ? current.memoizedProps : null;
				props = prevState.children;
				shouldSetTextContent($$typeof, prevState) ? props = null : null !== nextState && shouldSetTextContent($$typeof, nextState) && (workInProgress$1.flags |= 32);
				null !== workInProgress$1.memoizedState && ($$typeof = renderWithHooks(current, workInProgress$1, TransitionAwareHostComponent, null, null, renderLanes$1), HostTransitionContext._currentValue = $$typeof);
				markRef(current, workInProgress$1);
				reconcileChildren(current, workInProgress$1, props, renderLanes$1);
				return workInProgress$1.child;
			case 6:
				if (null === current && isHydrating) {
					if (current = renderLanes$1 = nextHydratableInstance) renderLanes$1 = canHydrateTextInstance(renderLanes$1, workInProgress$1.pendingProps, rootOrSingletonContext), null !== renderLanes$1 ? (workInProgress$1.stateNode = renderLanes$1, hydrationParentFiber = workInProgress$1, nextHydratableInstance = null, current = !0) : current = !1;
					current || throwOnHydrationMismatch(workInProgress$1);
				}
				return null;
			case 13: return updateSuspenseComponent(current, workInProgress$1, renderLanes$1);
			case 4: return pushHostContainer(workInProgress$1, workInProgress$1.stateNode.containerInfo), props = workInProgress$1.pendingProps, null === current ? workInProgress$1.child = reconcileChildFibers(workInProgress$1, null, props, renderLanes$1) : reconcileChildren(current, workInProgress$1, props, renderLanes$1), workInProgress$1.child;
			case 11: return updateForwardRef(current, workInProgress$1, workInProgress$1.type, workInProgress$1.pendingProps, renderLanes$1);
			case 7: return reconcileChildren(current, workInProgress$1, workInProgress$1.pendingProps, renderLanes$1), workInProgress$1.child;
			case 8: return reconcileChildren(current, workInProgress$1, workInProgress$1.pendingProps.children, renderLanes$1), workInProgress$1.child;
			case 12: return reconcileChildren(current, workInProgress$1, workInProgress$1.pendingProps.children, renderLanes$1), workInProgress$1.child;
			case 10: return props = workInProgress$1.pendingProps, pushProvider(workInProgress$1, workInProgress$1.type, props.value), reconcileChildren(current, workInProgress$1, props.children, renderLanes$1), workInProgress$1.child;
			case 9: return $$typeof = workInProgress$1.type._context, props = workInProgress$1.pendingProps.children, prepareToReadContext(workInProgress$1), $$typeof = readContext($$typeof), props = props($$typeof), workInProgress$1.flags |= 1, reconcileChildren(current, workInProgress$1, props, renderLanes$1), workInProgress$1.child;
			case 14: return updateMemoComponent(current, workInProgress$1, workInProgress$1.type, workInProgress$1.pendingProps, renderLanes$1);
			case 15: return updateSimpleMemoComponent(current, workInProgress$1, workInProgress$1.type, workInProgress$1.pendingProps, renderLanes$1);
			case 19: return updateSuspenseListComponent(current, workInProgress$1, renderLanes$1);
			case 31: return updateActivityComponent(current, workInProgress$1, renderLanes$1);
			case 22: return updateOffscreenComponent(current, workInProgress$1, renderLanes$1, workInProgress$1.pendingProps);
			case 24: return prepareToReadContext(workInProgress$1), props = readContext(CacheContext), null === current ? ($$typeof = peekCacheFromPool(), null === $$typeof && ($$typeof = workInProgressRoot, prevState = createCache(), $$typeof.pooledCache = prevState, prevState.refCount++, null !== prevState && ($$typeof.pooledCacheLanes |= renderLanes$1), $$typeof = prevState), workInProgress$1.memoizedState = {
				parent: props,
				cache: $$typeof
			}, initializeUpdateQueue(workInProgress$1), pushProvider(workInProgress$1, CacheContext, $$typeof)) : (0 !== (current.lanes & renderLanes$1) && (cloneUpdateQueue(current, workInProgress$1), processUpdateQueue(workInProgress$1, null, null, renderLanes$1), suspendIfUpdateReadFromEntangledAsyncAction()), $$typeof = current.memoizedState, prevState = workInProgress$1.memoizedState, $$typeof.parent !== props ? ($$typeof = {
				parent: props,
				cache: props
			}, workInProgress$1.memoizedState = $$typeof, 0 === workInProgress$1.lanes && (workInProgress$1.memoizedState = workInProgress$1.updateQueue.baseState = $$typeof), pushProvider(workInProgress$1, CacheContext, props)) : (props = prevState.cache, pushProvider(workInProgress$1, CacheContext, props), props !== $$typeof.cache && propagateContextChanges(workInProgress$1, [CacheContext], renderLanes$1, !0))), reconcileChildren(current, workInProgress$1, workInProgress$1.pendingProps.children, renderLanes$1), workInProgress$1.child;
			case 29: throw workInProgress$1.pendingProps;
		}
		throw Error(formatProdErrorMessage(156, workInProgress$1.tag));
	}
	function markUpdate(workInProgress$1) {
		workInProgress$1.flags |= 4;
	}
	function preloadInstanceAndSuspendIfNeeded(workInProgress$1, type, oldProps, newProps, renderLanes$1) {
		if (type = 0 !== (workInProgress$1.mode & 32)) type = !1;
		if (type) {
			if (workInProgress$1.flags |= 16777216, (renderLanes$1 & 335544128) === renderLanes$1) if (workInProgress$1.stateNode.complete) workInProgress$1.flags |= 8192;
			else if (shouldRemainOnPreviousScreen()) workInProgress$1.flags |= 8192;
			else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
		} else workInProgress$1.flags &= -16777217;
	}
	function preloadResourceAndSuspendIfNeeded(workInProgress$1, resource) {
		if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4)) workInProgress$1.flags &= -16777217;
		else if (workInProgress$1.flags |= 16777216, !preloadResource(resource)) if (shouldRemainOnPreviousScreen()) workInProgress$1.flags |= 8192;
		else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
	}
	function scheduleRetryEffect(workInProgress$1, retryQueue) {
		null !== retryQueue && (workInProgress$1.flags |= 4);
		workInProgress$1.flags & 16384 && (retryQueue = 22 !== workInProgress$1.tag ? claimNextRetryLane() : 536870912, workInProgress$1.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
	}
	function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
		if (!isHydrating) switch (renderState.tailMode) {
			case "hidden":
				hasRenderedATailFallback = renderState.tail;
				for (var lastTailNode = null; null !== hasRenderedATailFallback;) null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
				null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
				break;
			case "collapsed":
				lastTailNode = renderState.tail;
				for (var lastTailNode$106 = null; null !== lastTailNode;) null !== lastTailNode.alternate && (lastTailNode$106 = lastTailNode), lastTailNode = lastTailNode.sibling;
				null === lastTailNode$106 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$106.sibling = null;
		}
	}
	function bubbleProperties(completedWork) {
		var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
		if (didBailout) for (var child$107 = completedWork.child; null !== child$107;) newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags & 65011712, subtreeFlags |= child$107.flags & 65011712, child$107.return = completedWork, child$107 = child$107.sibling;
		else for (child$107 = completedWork.child; null !== child$107;) newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags, subtreeFlags |= child$107.flags, child$107.return = completedWork, child$107 = child$107.sibling;
		completedWork.subtreeFlags |= subtreeFlags;
		completedWork.childLanes = newChildLanes;
		return didBailout;
	}
	function completeWork(current, workInProgress$1, renderLanes$1) {
		var newProps = workInProgress$1.pendingProps;
		popTreeContext(workInProgress$1);
		switch (workInProgress$1.tag) {
			case 16:
			case 15:
			case 0:
			case 11:
			case 7:
			case 8:
			case 12:
			case 9:
			case 14: return bubbleProperties(workInProgress$1), null;
			case 1: return bubbleProperties(workInProgress$1), null;
			case 3:
				renderLanes$1 = workInProgress$1.stateNode;
				newProps = null;
				null !== current && (newProps = current.memoizedState.cache);
				workInProgress$1.memoizedState.cache !== newProps && (workInProgress$1.flags |= 2048);
				popProvider(CacheContext);
				popHostContainer();
				renderLanes$1.pendingContext && (renderLanes$1.context = renderLanes$1.pendingContext, renderLanes$1.pendingContext = null);
				if (null === current || null === current.child) popHydrationState(workInProgress$1) ? markUpdate(workInProgress$1) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress$1.flags & 256) || (workInProgress$1.flags |= 1024, upgradeHydrationErrorsToRecoverable());
				bubbleProperties(workInProgress$1);
				return null;
			case 26:
				var type = workInProgress$1.type, nextResource = workInProgress$1.memoizedState;
				null === current ? (markUpdate(workInProgress$1), null !== nextResource ? (bubbleProperties(workInProgress$1), preloadResourceAndSuspendIfNeeded(workInProgress$1, nextResource)) : (bubbleProperties(workInProgress$1), preloadInstanceAndSuspendIfNeeded(workInProgress$1, type, null, newProps, renderLanes$1))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress$1), bubbleProperties(workInProgress$1), preloadResourceAndSuspendIfNeeded(workInProgress$1, nextResource)) : (bubbleProperties(workInProgress$1), workInProgress$1.flags &= -16777217) : (current = current.memoizedProps, current !== newProps && markUpdate(workInProgress$1), bubbleProperties(workInProgress$1), preloadInstanceAndSuspendIfNeeded(workInProgress$1, type, current, newProps, renderLanes$1));
				return null;
			case 27:
				popHostContext(workInProgress$1);
				renderLanes$1 = rootInstanceStackCursor.current;
				type = workInProgress$1.type;
				if (null !== current && null != workInProgress$1.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress$1);
				else {
					if (!newProps) {
						if (null === workInProgress$1.stateNode) throw Error(formatProdErrorMessage(166));
						bubbleProperties(workInProgress$1);
						return null;
					}
					current = contextStackCursor.current;
					popHydrationState(workInProgress$1) ? prepareToHydrateHostInstance(workInProgress$1, current) : (current = resolveSingletonInstance(type, newProps, renderLanes$1), workInProgress$1.stateNode = current, markUpdate(workInProgress$1));
				}
				bubbleProperties(workInProgress$1);
				return null;
			case 5:
				popHostContext(workInProgress$1);
				type = workInProgress$1.type;
				if (null !== current && null != workInProgress$1.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress$1);
				else {
					if (!newProps) {
						if (null === workInProgress$1.stateNode) throw Error(formatProdErrorMessage(166));
						bubbleProperties(workInProgress$1);
						return null;
					}
					nextResource = contextStackCursor.current;
					if (popHydrationState(workInProgress$1)) prepareToHydrateHostInstance(workInProgress$1, nextResource);
					else {
						var ownerDocument = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current);
						switch (nextResource) {
							case 1:
								nextResource = ownerDocument.createElementNS("http://www.w3.org/2000/svg", type);
								break;
							case 2:
								nextResource = ownerDocument.createElementNS("http://www.w3.org/1998/Math/MathML", type);
								break;
							default: switch (type) {
								case "svg":
									nextResource = ownerDocument.createElementNS("http://www.w3.org/2000/svg", type);
									break;
								case "math":
									nextResource = ownerDocument.createElementNS("http://www.w3.org/1998/Math/MathML", type);
									break;
								case "script":
									nextResource = ownerDocument.createElement("div");
									nextResource.innerHTML = "<script><\/script>";
									nextResource = nextResource.removeChild(nextResource.firstChild);
									break;
								case "select":
									nextResource = "string" === typeof newProps.is ? ownerDocument.createElement("select", { is: newProps.is }) : ownerDocument.createElement("select");
									newProps.multiple ? nextResource.multiple = !0 : newProps.size && (nextResource.size = newProps.size);
									break;
								default: nextResource = "string" === typeof newProps.is ? ownerDocument.createElement(type, { is: newProps.is }) : ownerDocument.createElement(type);
							}
						}
						nextResource[internalInstanceKey] = workInProgress$1;
						nextResource[internalPropsKey] = newProps;
						a: for (ownerDocument = workInProgress$1.child; null !== ownerDocument;) {
							if (5 === ownerDocument.tag || 6 === ownerDocument.tag) nextResource.appendChild(ownerDocument.stateNode);
							else if (4 !== ownerDocument.tag && 27 !== ownerDocument.tag && null !== ownerDocument.child) {
								ownerDocument.child.return = ownerDocument;
								ownerDocument = ownerDocument.child;
								continue;
							}
							if (ownerDocument === workInProgress$1) break a;
							for (; null === ownerDocument.sibling;) {
								if (null === ownerDocument.return || ownerDocument.return === workInProgress$1) break a;
								ownerDocument = ownerDocument.return;
							}
							ownerDocument.sibling.return = ownerDocument.return;
							ownerDocument = ownerDocument.sibling;
						}
						workInProgress$1.stateNode = nextResource;
						a: switch (setInitialProperties(nextResource, type, newProps), type) {
							case "button":
							case "input":
							case "select":
							case "textarea":
								newProps = !!newProps.autoFocus;
								break a;
							case "img":
								newProps = !0;
								break a;
							default: newProps = !1;
						}
						newProps && markUpdate(workInProgress$1);
					}
				}
				bubbleProperties(workInProgress$1);
				preloadInstanceAndSuspendIfNeeded(workInProgress$1, workInProgress$1.type, null === current ? null : current.memoizedProps, workInProgress$1.pendingProps, renderLanes$1);
				return null;
			case 6:
				if (current && null != workInProgress$1.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress$1);
				else {
					if ("string" !== typeof newProps && null === workInProgress$1.stateNode) throw Error(formatProdErrorMessage(166));
					current = rootInstanceStackCursor.current;
					if (popHydrationState(workInProgress$1)) {
						current = workInProgress$1.stateNode;
						renderLanes$1 = workInProgress$1.memoizedProps;
						newProps = null;
						type = hydrationParentFiber;
						if (null !== type) switch (type.tag) {
							case 27:
							case 5: newProps = type.memoizedProps;
						}
						current[internalInstanceKey] = workInProgress$1;
						current = current.nodeValue === renderLanes$1 || null !== newProps && !0 === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes$1) ? !0 : !1;
						current || throwOnHydrationMismatch(workInProgress$1, !0);
					} else current = getOwnerDocumentFromRootContainer(current).createTextNode(newProps), current[internalInstanceKey] = workInProgress$1, workInProgress$1.stateNode = current;
				}
				bubbleProperties(workInProgress$1);
				return null;
			case 31:
				renderLanes$1 = workInProgress$1.memoizedState;
				if (null === current || null !== current.memoizedState) {
					newProps = popHydrationState(workInProgress$1);
					if (null !== renderLanes$1) {
						if (null === current) {
							if (!newProps) throw Error(formatProdErrorMessage(318));
							current = workInProgress$1.memoizedState;
							current = null !== current ? current.dehydrated : null;
							if (!current) throw Error(formatProdErrorMessage(557));
							current[internalInstanceKey] = workInProgress$1;
						} else resetHydrationState(), 0 === (workInProgress$1.flags & 128) && (workInProgress$1.memoizedState = null), workInProgress$1.flags |= 4;
						bubbleProperties(workInProgress$1);
						current = !1;
					} else renderLanes$1 = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = renderLanes$1), current = !0;
					if (!current) {
						if (workInProgress$1.flags & 256) return popSuspenseHandler(workInProgress$1), workInProgress$1;
						popSuspenseHandler(workInProgress$1);
						return null;
					}
					if (0 !== (workInProgress$1.flags & 128)) throw Error(formatProdErrorMessage(558));
				}
				bubbleProperties(workInProgress$1);
				return null;
			case 13:
				newProps = workInProgress$1.memoizedState;
				if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
					type = popHydrationState(workInProgress$1);
					if (null !== newProps && null !== newProps.dehydrated) {
						if (null === current) {
							if (!type) throw Error(formatProdErrorMessage(318));
							type = workInProgress$1.memoizedState;
							type = null !== type ? type.dehydrated : null;
							if (!type) throw Error(formatProdErrorMessage(317));
							type[internalInstanceKey] = workInProgress$1;
						} else resetHydrationState(), 0 === (workInProgress$1.flags & 128) && (workInProgress$1.memoizedState = null), workInProgress$1.flags |= 4;
						bubbleProperties(workInProgress$1);
						type = !1;
					} else type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = !0;
					if (!type) {
						if (workInProgress$1.flags & 256) return popSuspenseHandler(workInProgress$1), workInProgress$1;
						popSuspenseHandler(workInProgress$1);
						return null;
					}
				}
				popSuspenseHandler(workInProgress$1);
				if (0 !== (workInProgress$1.flags & 128)) return workInProgress$1.lanes = renderLanes$1, workInProgress$1;
				renderLanes$1 = null !== newProps;
				current = null !== current && null !== current.memoizedState;
				renderLanes$1 && (newProps = workInProgress$1.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
				renderLanes$1 !== current && renderLanes$1 && (workInProgress$1.child.flags |= 8192);
				scheduleRetryEffect(workInProgress$1, workInProgress$1.updateQueue);
				bubbleProperties(workInProgress$1);
				return null;
			case 4: return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress$1.stateNode.containerInfo), bubbleProperties(workInProgress$1), null;
			case 10: return popProvider(workInProgress$1.type), bubbleProperties(workInProgress$1), null;
			case 19:
				pop(suspenseStackCursor);
				newProps = workInProgress$1.memoizedState;
				if (null === newProps) return bubbleProperties(workInProgress$1), null;
				type = 0 !== (workInProgress$1.flags & 128);
				nextResource = newProps.rendering;
				if (null === nextResource) if (type) cutOffTailIfNeeded(newProps, !1);
				else {
					if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128)) for (current = workInProgress$1.child; null !== current;) {
						nextResource = findFirstSuspended(current);
						if (null !== nextResource) {
							workInProgress$1.flags |= 128;
							cutOffTailIfNeeded(newProps, !1);
							current = nextResource.updateQueue;
							workInProgress$1.updateQueue = current;
							scheduleRetryEffect(workInProgress$1, current);
							workInProgress$1.subtreeFlags = 0;
							current = renderLanes$1;
							for (renderLanes$1 = workInProgress$1.child; null !== renderLanes$1;) resetWorkInProgress(renderLanes$1, current), renderLanes$1 = renderLanes$1.sibling;
							push(suspenseStackCursor, suspenseStackCursor.current & 1 | 2);
							isHydrating && pushTreeFork(workInProgress$1, newProps.treeForkCount);
							return workInProgress$1.child;
						}
						current = current.sibling;
					}
					null !== newProps.tail && now() > workInProgressRootRenderTargetTime && (workInProgress$1.flags |= 128, type = !0, cutOffTailIfNeeded(newProps, !1), workInProgress$1.lanes = 4194304);
				}
				else {
					if (!type) if (current = findFirstSuspended(nextResource), null !== current) {
						if (workInProgress$1.flags |= 128, type = !0, current = current.updateQueue, workInProgress$1.updateQueue = current, scheduleRetryEffect(workInProgress$1, current), cutOffTailIfNeeded(newProps, !0), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating) return bubbleProperties(workInProgress$1), null;
					} else 2 * now() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes$1 && (workInProgress$1.flags |= 128, type = !0, cutOffTailIfNeeded(newProps, !1), workInProgress$1.lanes = 4194304);
					newProps.isBackwards ? (nextResource.sibling = workInProgress$1.child, workInProgress$1.child = nextResource) : (current = newProps.last, null !== current ? current.sibling = nextResource : workInProgress$1.child = nextResource, newProps.last = nextResource);
				}
				if (null !== newProps.tail) return current = newProps.tail, newProps.rendering = current, newProps.tail = current.sibling, newProps.renderingStartTime = now(), current.sibling = null, renderLanes$1 = suspenseStackCursor.current, push(suspenseStackCursor, type ? renderLanes$1 & 1 | 2 : renderLanes$1 & 1), isHydrating && pushTreeFork(workInProgress$1, newProps.treeForkCount), current;
				bubbleProperties(workInProgress$1);
				return null;
			case 22:
			case 23: return popSuspenseHandler(workInProgress$1), popHiddenContext(), newProps = null !== workInProgress$1.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress$1.flags |= 8192) : newProps && (workInProgress$1.flags |= 8192), newProps ? 0 !== (renderLanes$1 & 536870912) && 0 === (workInProgress$1.flags & 128) && (bubbleProperties(workInProgress$1), workInProgress$1.subtreeFlags & 6 && (workInProgress$1.flags |= 8192)) : bubbleProperties(workInProgress$1), renderLanes$1 = workInProgress$1.updateQueue, null !== renderLanes$1 && scheduleRetryEffect(workInProgress$1, renderLanes$1.retryQueue), renderLanes$1 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes$1 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress$1.memoizedState && null !== workInProgress$1.memoizedState.cachePool && (newProps = workInProgress$1.memoizedState.cachePool.pool), newProps !== renderLanes$1 && (workInProgress$1.flags |= 2048), null !== current && pop(resumedCache), null;
			case 24: return renderLanes$1 = null, null !== current && (renderLanes$1 = current.memoizedState.cache), workInProgress$1.memoizedState.cache !== renderLanes$1 && (workInProgress$1.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress$1), null;
			case 25: return null;
			case 30: return null;
		}
		throw Error(formatProdErrorMessage(156, workInProgress$1.tag));
	}
	function unwindWork(current, workInProgress$1) {
		popTreeContext(workInProgress$1);
		switch (workInProgress$1.tag) {
			case 1: return current = workInProgress$1.flags, current & 65536 ? (workInProgress$1.flags = current & -65537 | 128, workInProgress$1) : null;
			case 3: return popProvider(CacheContext), popHostContainer(), current = workInProgress$1.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress$1.flags = current & -65537 | 128, workInProgress$1) : null;
			case 26:
			case 27:
			case 5: return popHostContext(workInProgress$1), null;
			case 31:
				if (null !== workInProgress$1.memoizedState) {
					popSuspenseHandler(workInProgress$1);
					if (null === workInProgress$1.alternate) throw Error(formatProdErrorMessage(340));
					resetHydrationState();
				}
				current = workInProgress$1.flags;
				return current & 65536 ? (workInProgress$1.flags = current & -65537 | 128, workInProgress$1) : null;
			case 13:
				popSuspenseHandler(workInProgress$1);
				current = workInProgress$1.memoizedState;
				if (null !== current && null !== current.dehydrated) {
					if (null === workInProgress$1.alternate) throw Error(formatProdErrorMessage(340));
					resetHydrationState();
				}
				current = workInProgress$1.flags;
				return current & 65536 ? (workInProgress$1.flags = current & -65537 | 128, workInProgress$1) : null;
			case 19: return pop(suspenseStackCursor), null;
			case 4: return popHostContainer(), null;
			case 10: return popProvider(workInProgress$1.type), null;
			case 22:
			case 23: return popSuspenseHandler(workInProgress$1), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress$1.flags, current & 65536 ? (workInProgress$1.flags = current & -65537 | 128, workInProgress$1) : null;
			case 24: return popProvider(CacheContext), null;
			case 25: return null;
			default: return null;
		}
	}
	function unwindInterruptedWork(current, interruptedWork) {
		popTreeContext(interruptedWork);
		switch (interruptedWork.tag) {
			case 3:
				popProvider(CacheContext);
				popHostContainer();
				break;
			case 26:
			case 27:
			case 5:
				popHostContext(interruptedWork);
				break;
			case 4:
				popHostContainer();
				break;
			case 31:
				null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
				break;
			case 13:
				popSuspenseHandler(interruptedWork);
				break;
			case 19:
				pop(suspenseStackCursor);
				break;
			case 10:
				popProvider(interruptedWork.type);
				break;
			case 22:
			case 23:
				popSuspenseHandler(interruptedWork);
				popHiddenContext();
				null !== current && pop(resumedCache);
				break;
			case 24: popProvider(CacheContext);
		}
	}
	function commitHookEffectListMount(flags, finishedWork) {
		try {
			var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
			if (null !== lastEffect) {
				var firstEffect = lastEffect.next;
				updateQueue = firstEffect;
				do {
					if ((updateQueue.tag & flags) === flags) {
						lastEffect = void 0;
						var create$1 = updateQueue.create, inst = updateQueue.inst;
						lastEffect = create$1();
						inst.destroy = lastEffect;
					}
					updateQueue = updateQueue.next;
				} while (updateQueue !== firstEffect);
			}
		} catch (error) {
			captureCommitPhaseError(finishedWork, finishedWork.return, error);
		}
	}
	function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
		try {
			var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
			if (null !== lastEffect) {
				var firstEffect = lastEffect.next;
				updateQueue = firstEffect;
				do {
					if ((updateQueue.tag & flags) === flags) {
						var inst = updateQueue.inst, destroy = inst.destroy;
						if (void 0 !== destroy) {
							inst.destroy = void 0;
							lastEffect = finishedWork;
							var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
							try {
								destroy_();
							} catch (error) {
								captureCommitPhaseError(lastEffect, nearestMountedAncestor, error);
							}
						}
					}
					updateQueue = updateQueue.next;
				} while (updateQueue !== firstEffect);
			}
		} catch (error) {
			captureCommitPhaseError(finishedWork, finishedWork.return, error);
		}
	}
	function commitClassCallbacks(finishedWork) {
		var updateQueue = finishedWork.updateQueue;
		if (null !== updateQueue) {
			var instance = finishedWork.stateNode;
			try {
				commitCallbacks(updateQueue, instance);
			} catch (error) {
				captureCommitPhaseError(finishedWork, finishedWork.return, error);
			}
		}
	}
	function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
		instance.props = resolveClassComponentProps(current.type, current.memoizedProps);
		instance.state = current.memoizedState;
		try {
			instance.componentWillUnmount();
		} catch (error) {
			captureCommitPhaseError(current, nearestMountedAncestor, error);
		}
	}
	function safelyAttachRef(current, nearestMountedAncestor) {
		try {
			var ref = current.ref;
			if (null !== ref) {
				switch (current.tag) {
					case 26:
					case 27:
					case 5:
						var instanceToUse = current.stateNode;
						break;
					case 30:
						instanceToUse = current.stateNode;
						break;
					default: instanceToUse = current.stateNode;
				}
				"function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
			}
		} catch (error) {
			captureCommitPhaseError(current, nearestMountedAncestor, error);
		}
	}
	function safelyDetachRef(current, nearestMountedAncestor) {
		var ref = current.ref, refCleanup = current.refCleanup;
		if (null !== ref) if ("function" === typeof refCleanup) try {
			refCleanup();
		} catch (error) {
			captureCommitPhaseError(current, nearestMountedAncestor, error);
		} finally {
			current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
		}
		else if ("function" === typeof ref) try {
			ref(null);
		} catch (error$140) {
			captureCommitPhaseError(current, nearestMountedAncestor, error$140);
		}
		else ref.current = null;
	}
	function commitHostMount(finishedWork) {
		var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
		try {
			a: switch (type) {
				case "button":
				case "input":
				case "select":
				case "textarea":
					props.autoFocus && instance.focus();
					break a;
				case "img": props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
			}
		} catch (error) {
			captureCommitPhaseError(finishedWork, finishedWork.return, error);
		}
	}
	function commitHostUpdate(finishedWork, newProps, oldProps) {
		try {
			var domElement = finishedWork.stateNode;
			updateProperties(domElement, finishedWork.type, oldProps, newProps);
			domElement[internalPropsKey] = newProps;
		} catch (error) {
			captureCommitPhaseError(finishedWork, finishedWork.return, error);
		}
	}
	function isHostParent(fiber) {
		return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
	}
	function getHostSibling(fiber) {
		a: for (;;) {
			for (; null === fiber.sibling;) {
				if (null === fiber.return || isHostParent(fiber.return)) return null;
				fiber = fiber.return;
			}
			fiber.sibling.return = fiber.return;
			for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;) {
				if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
				if (fiber.flags & 2) continue a;
				if (null === fiber.child || 4 === fiber.tag) continue a;
				else fiber.child.return = fiber, fiber = fiber.child;
			}
			if (!(fiber.flags & 2)) return fiber.stateNode;
		}
	}
	function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
		var tag = node.tag;
		if (5 === tag || 6 === tag) node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1$1));
		else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node)) for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;) insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
	}
	function insertOrAppendPlacementNode(node, before, parent) {
		var tag = node.tag;
		if (5 === tag || 6 === tag) node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
		else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node)) for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;) insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
	}
	function commitHostSingletonAcquisition(finishedWork) {
		var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
		try {
			for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length;) singleton.removeAttributeNode(attributes[0]);
			setInitialProperties(singleton, type, props);
			singleton[internalInstanceKey] = finishedWork;
			singleton[internalPropsKey] = props;
		} catch (error) {
			captureCommitPhaseError(finishedWork, finishedWork.return, error);
		}
	}
	var offscreenSubtreeIsHidden = !1, offscreenSubtreeWasHidden = !1, needsFormReset = !1, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null;
	function commitBeforeMutationEffects(root$1, firstChild) {
		root$1 = root$1.containerInfo;
		eventsEnabled = _enabled;
		root$1 = getActiveElementDeep(root$1);
		if (hasSelectionCapabilities(root$1)) {
			if ("selectionStart" in root$1) var JSCompiler_temp = {
				start: root$1.selectionStart,
				end: root$1.selectionEnd
			};
			else a: {
				JSCompiler_temp = (JSCompiler_temp = root$1.ownerDocument) && JSCompiler_temp.defaultView || window;
				var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
				if (selection && 0 !== selection.rangeCount) {
					JSCompiler_temp = selection.anchorNode;
					var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
					selection = selection.focusOffset;
					try {
						JSCompiler_temp.nodeType, focusNode.nodeType;
					} catch (e$20) {
						JSCompiler_temp = null;
						break a;
					}
					var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root$1, parentNode = null;
					b: for (;;) {
						for (var next;;) {
							node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
							node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
							3 === node.nodeType && (length += node.nodeValue.length);
							if (null === (next = node.firstChild)) break;
							parentNode = node;
							node = next;
						}
						for (;;) {
							if (node === root$1) break b;
							parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
							parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
							if (null !== (next = node.nextSibling)) break;
							node = parentNode;
							parentNode = node.parentNode;
						}
						node = next;
					}
					JSCompiler_temp = -1 === start || -1 === end ? null : {
						start,
						end
					};
				} else JSCompiler_temp = null;
			}
			JSCompiler_temp = JSCompiler_temp || {
				start: 0,
				end: 0
			};
		} else JSCompiler_temp = null;
		selectionInformation = {
			focusedElem: root$1,
			selectionRange: JSCompiler_temp
		};
		_enabled = !1;
		for (nextEffect = firstChild; null !== nextEffect;) if (firstChild = nextEffect, root$1 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root$1) root$1.return = firstChild, nextEffect = root$1;
		else for (; null !== nextEffect;) {
			firstChild = nextEffect;
			focusNode = firstChild.alternate;
			root$1 = firstChild.flags;
			switch (firstChild.tag) {
				case 0:
					if (0 !== (root$1 & 4) && (root$1 = firstChild.updateQueue, root$1 = null !== root$1 ? root$1.events : null, null !== root$1)) for (JSCompiler_temp = 0; JSCompiler_temp < root$1.length; JSCompiler_temp++) anchorOffset = root$1[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
					break;
				case 11:
				case 15: break;
				case 1:
					if (0 !== (root$1 & 1024) && null !== focusNode) {
						root$1 = void 0;
						JSCompiler_temp = firstChild;
						anchorOffset = focusNode.memoizedProps;
						focusNode = focusNode.memoizedState;
						selection = JSCompiler_temp.stateNode;
						try {
							var resolvedPrevProps = resolveClassComponentProps(JSCompiler_temp.type, anchorOffset);
							root$1 = selection.getSnapshotBeforeUpdate(resolvedPrevProps, focusNode);
							selection.__reactInternalSnapshotBeforeUpdate = root$1;
						} catch (error) {
							captureCommitPhaseError(JSCompiler_temp, JSCompiler_temp.return, error);
						}
					}
					break;
				case 3:
					if (0 !== (root$1 & 1024)) {
						if (root$1 = firstChild.stateNode.containerInfo, JSCompiler_temp = root$1.nodeType, 9 === JSCompiler_temp) clearContainerSparingly(root$1);
						else if (1 === JSCompiler_temp) switch (root$1.nodeName) {
							case "HEAD":
							case "HTML":
							case "BODY":
								clearContainerSparingly(root$1);
								break;
							default: root$1.textContent = "";
						}
					}
					break;
				case 5:
				case 26:
				case 27:
				case 6:
				case 4:
				case 17: break;
				default: if (0 !== (root$1 & 1024)) throw Error(formatProdErrorMessage(163));
			}
			root$1 = firstChild.sibling;
			if (null !== root$1) {
				root$1.return = firstChild.return;
				nextEffect = root$1;
				break;
			}
			nextEffect = firstChild.return;
		}
	}
	function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
		var flags = finishedWork.flags;
		switch (finishedWork.tag) {
			case 0:
			case 11:
			case 15:
				recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
				flags & 4 && commitHookEffectListMount(5, finishedWork);
				break;
			case 1:
				recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
				if (flags & 4) if (finishedRoot = finishedWork.stateNode, null === current) try {
					finishedRoot.componentDidMount();
				} catch (error) {
					captureCommitPhaseError(finishedWork, finishedWork.return, error);
				}
				else {
					var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);
					current = current.memoizedState;
					try {
						finishedRoot.componentDidUpdate(prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);
					} catch (error$139) {
						captureCommitPhaseError(finishedWork, finishedWork.return, error$139);
					}
				}
				flags & 64 && commitClassCallbacks(finishedWork);
				flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
				break;
			case 3:
				recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
				if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
					current = null;
					if (null !== finishedWork.child) switch (finishedWork.child.tag) {
						case 27:
						case 5:
							current = finishedWork.child.stateNode;
							break;
						case 1: current = finishedWork.child.stateNode;
					}
					try {
						commitCallbacks(finishedRoot, current);
					} catch (error) {
						captureCommitPhaseError(finishedWork, finishedWork.return, error);
					}
				}
				break;
			case 27: null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
			case 26:
			case 5:
				recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
				null === current && flags & 4 && commitHostMount(finishedWork);
				flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
				break;
			case 12:
				recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
				break;
			case 31:
				recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
				flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
				break;
			case 13:
				recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
				flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
				flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(null, finishedWork), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
				break;
			case 22:
				flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
				if (!flags) {
					current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
					prevProps = offscreenSubtreeIsHidden;
					var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
					offscreenSubtreeIsHidden = flags;
					(offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
					offscreenSubtreeIsHidden = prevProps;
					offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
				}
				break;
			case 30: break;
			default: recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
		}
	}
	function detachFiberAfterEffects(fiber) {
		var alternate = fiber.alternate;
		null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
		fiber.child = null;
		fiber.deletions = null;
		fiber.sibling = null;
		5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
		fiber.stateNode = null;
		fiber.return = null;
		fiber.dependencies = null;
		fiber.memoizedProps = null;
		fiber.memoizedState = null;
		fiber.pendingProps = null;
		fiber.stateNode = null;
		fiber.updateQueue = null;
	}
	var hostParent = null, hostParentIsContainer = !1;
	function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
		for (parent = parent.child; null !== parent;) commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
	}
	function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
		if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount) try {
			injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
		} catch (err) {}
		switch (deletedFiber.tag) {
			case 26:
				offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
				recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
				deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
				break;
			case 27:
				offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
				var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
				isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = !1);
				recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
				releaseSingletonInstance(deletedFiber.stateNode);
				hostParent = prevHostParent;
				hostParentIsContainer = prevHostParentIsContainer;
				break;
			case 5: offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
			case 6:
				prevHostParent = hostParent;
				prevHostParentIsContainer = hostParentIsContainer;
				hostParent = null;
				recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
				hostParent = prevHostParent;
				hostParentIsContainer = prevHostParentIsContainer;
				if (null !== hostParent) if (hostParentIsContainer) try {
					(9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
				} catch (error) {
					captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
				}
				else try {
					hostParent.removeChild(deletedFiber.stateNode);
				} catch (error) {
					captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
				}
				break;
			case 18:
				null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot, deletedFiber.stateNode), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
				break;
			case 4:
				prevHostParent = hostParent;
				prevHostParentIsContainer = hostParentIsContainer;
				hostParent = deletedFiber.stateNode.containerInfo;
				hostParentIsContainer = !0;
				recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
				hostParent = prevHostParent;
				hostParentIsContainer = prevHostParentIsContainer;
				break;
			case 0:
			case 11:
			case 14:
			case 15:
				commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
				offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
				recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
				break;
			case 1:
				offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));
				recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
				break;
			case 21:
				recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
				break;
			case 22:
				offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
				recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
				offscreenSubtreeWasHidden = prevHostParent;
				break;
			default: recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
		}
	}
	function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
		if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
			finishedRoot = finishedRoot.dehydrated;
			try {
				retryIfBlockedOn(finishedRoot);
			} catch (error) {
				captureCommitPhaseError(finishedWork, finishedWork.return, error);
			}
		}
	}
	function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
		if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot)))) try {
			retryIfBlockedOn(finishedRoot);
		} catch (error) {
			captureCommitPhaseError(finishedWork, finishedWork.return, error);
		}
	}
	function getRetryCache(finishedWork) {
		switch (finishedWork.tag) {
			case 31:
			case 13:
			case 19:
				var retryCache = finishedWork.stateNode;
				null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
				return retryCache;
			case 22: return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
			default: throw Error(formatProdErrorMessage(435, finishedWork.tag));
		}
	}
	function attachSuspenseRetryListeners(finishedWork, wakeables) {
		var retryCache = getRetryCache(finishedWork);
		wakeables.forEach(function(wakeable) {
			if (!retryCache.has(wakeable)) {
				retryCache.add(wakeable);
				var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
				wakeable.then(retry, retry);
			}
		});
	}
	function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
		var deletions = parentFiber.deletions;
		if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
			var childToDelete = deletions[i], root$1 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
			a: for (; null !== parent;) {
				switch (parent.tag) {
					case 27:
						if (isSingletonScope(parent.type)) {
							hostParent = parent.stateNode;
							hostParentIsContainer = !1;
							break a;
						}
						break;
					case 5:
						hostParent = parent.stateNode;
						hostParentIsContainer = !1;
						break a;
					case 3:
					case 4:
						hostParent = parent.stateNode.containerInfo;
						hostParentIsContainer = !0;
						break a;
				}
				parent = parent.return;
			}
			if (null === hostParent) throw Error(formatProdErrorMessage(160));
			commitDeletionEffectsOnFiber(root$1, returnFiber, childToDelete);
			hostParent = null;
			hostParentIsContainer = !1;
			root$1 = childToDelete.alternate;
			null !== root$1 && (root$1.return = null);
			childToDelete.return = null;
		}
		if (parentFiber.subtreeFlags & 13886) for (parentFiber = parentFiber.child; null !== parentFiber;) commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
	}
	var currentHoistableRoot = null;
	function commitMutationEffectsOnFiber(finishedWork, root$1) {
		var current = finishedWork.alternate, flags = finishedWork.flags;
		switch (finishedWork.tag) {
			case 0:
			case 11:
			case 14:
			case 15:
				recursivelyTraverseMutationEffects(root$1, finishedWork);
				commitReconciliationEffects(finishedWork);
				flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
				break;
			case 1:
				recursivelyTraverseMutationEffects(root$1, finishedWork);
				commitReconciliationEffects(finishedWork);
				flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
				flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
				break;
			case 26:
				var hoistableRoot = currentHoistableRoot;
				recursivelyTraverseMutationEffects(root$1, finishedWork);
				commitReconciliationEffects(finishedWork);
				flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
				if (flags & 4) {
					var currentResource = null !== current ? current.memoizedState : null;
					flags = finishedWork.memoizedState;
					if (null === current) if (null === flags) if (null === finishedWork.stateNode) {
						a: {
							flags = finishedWork.type;
							current = finishedWork.memoizedProps;
							hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
							b: switch (flags) {
								case "title":
									currentResource = hoistableRoot.getElementsByTagName("title")[0];
									if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop")) currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(currentResource, hoistableRoot.querySelector("head > title"));
									setInitialProperties(currentResource, flags, current);
									currentResource[internalInstanceKey] = finishedWork;
									markNodeAsHoistable(currentResource);
									flags = currentResource;
									break a;
								case "link":
									var maybeNodes = getHydratableHoistableCache("link", "href", hoistableRoot).get(flags + (current.href || ""));
									if (maybeNodes) {
										for (var i = 0; i < maybeNodes.length; i++) if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
											maybeNodes.splice(i, 1);
											break b;
										}
									}
									currentResource = hoistableRoot.createElement(flags);
									setInitialProperties(currentResource, flags, current);
									hoistableRoot.head.appendChild(currentResource);
									break;
								case "meta":
									if (maybeNodes = getHydratableHoistableCache("meta", "content", hoistableRoot).get(flags + (current.content || ""))) {
										for (i = 0; i < maybeNodes.length; i++) if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
											maybeNodes.splice(i, 1);
											break b;
										}
									}
									currentResource = hoistableRoot.createElement(flags);
									setInitialProperties(currentResource, flags, current);
									hoistableRoot.head.appendChild(currentResource);
									break;
								default: throw Error(formatProdErrorMessage(468, flags));
							}
							currentResource[internalInstanceKey] = finishedWork;
							markNodeAsHoistable(currentResource);
							flags = currentResource;
						}
						finishedWork.stateNode = flags;
					} else mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);
					else finishedWork.stateNode = acquireResource(hoistableRoot, flags, finishedWork.memoizedProps);
					else currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, flags, finishedWork.memoizedProps)) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
				}
				break;
			case 27:
				recursivelyTraverseMutationEffects(root$1, finishedWork);
				commitReconciliationEffects(finishedWork);
				flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
				null !== current && flags & 4 && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
				break;
			case 5:
				recursivelyTraverseMutationEffects(root$1, finishedWork);
				commitReconciliationEffects(finishedWork);
				flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
				if (finishedWork.flags & 32) {
					hoistableRoot = finishedWork.stateNode;
					try {
						setTextContent(hoistableRoot, "");
					} catch (error) {
						captureCommitPhaseError(finishedWork, finishedWork.return, error);
					}
				}
				flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(finishedWork, hoistableRoot, null !== current ? current.memoizedProps : hoistableRoot));
				flags & 1024 && (needsFormReset = !0);
				break;
			case 6:
				recursivelyTraverseMutationEffects(root$1, finishedWork);
				commitReconciliationEffects(finishedWork);
				if (flags & 4) {
					if (null === finishedWork.stateNode) throw Error(formatProdErrorMessage(162));
					flags = finishedWork.memoizedProps;
					current = finishedWork.stateNode;
					try {
						current.nodeValue = flags;
					} catch (error) {
						captureCommitPhaseError(finishedWork, finishedWork.return, error);
					}
				}
				break;
			case 3:
				tagCaches = null;
				hoistableRoot = currentHoistableRoot;
				currentHoistableRoot = getHoistableRoot(root$1.containerInfo);
				recursivelyTraverseMutationEffects(root$1, finishedWork);
				currentHoistableRoot = hoistableRoot;
				commitReconciliationEffects(finishedWork);
				if (flags & 4 && null !== current && current.memoizedState.isDehydrated) try {
					retryIfBlockedOn(root$1.containerInfo);
				} catch (error) {
					captureCommitPhaseError(finishedWork, finishedWork.return, error);
				}
				needsFormReset && (needsFormReset = !1, recursivelyResetForms(finishedWork));
				break;
			case 4:
				flags = currentHoistableRoot;
				currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);
				recursivelyTraverseMutationEffects(root$1, finishedWork);
				commitReconciliationEffects(finishedWork);
				currentHoistableRoot = flags;
				break;
			case 12:
				recursivelyTraverseMutationEffects(root$1, finishedWork);
				commitReconciliationEffects(finishedWork);
				break;
			case 31:
				recursivelyTraverseMutationEffects(root$1, finishedWork);
				commitReconciliationEffects(finishedWork);
				flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
				break;
			case 13:
				recursivelyTraverseMutationEffects(root$1, finishedWork);
				commitReconciliationEffects(finishedWork);
				finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
				flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
				break;
			case 22:
				hoistableRoot = null !== finishedWork.memoizedState;
				var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
				offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
				offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
				recursivelyTraverseMutationEffects(root$1, finishedWork);
				offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
				offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
				commitReconciliationEffects(finishedWork);
				if (flags & 8192) a: for (root$1 = finishedWork.stateNode, root$1._visibility = hoistableRoot ? root$1._visibility & -2 : root$1._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root$1 = finishedWork;;) {
					if (5 === root$1.tag || 26 === root$1.tag) {
						if (null === current) {
							wasHidden = current = root$1;
							try {
								if (currentResource = wasHidden.stateNode, hoistableRoot) maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
								else {
									i = wasHidden.stateNode;
									var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
									i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
								}
							} catch (error) {
								captureCommitPhaseError(wasHidden, wasHidden.return, error);
							}
						}
					} else if (6 === root$1.tag) {
						if (null === current) {
							wasHidden = root$1;
							try {
								wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
							} catch (error) {
								captureCommitPhaseError(wasHidden, wasHidden.return, error);
							}
						}
					} else if (18 === root$1.tag) {
						if (null === current) {
							wasHidden = root$1;
							try {
								var instance = wasHidden.stateNode;
								hoistableRoot ? hideOrUnhideDehydratedBoundary(instance, !0) : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, !1);
							} catch (error) {
								captureCommitPhaseError(wasHidden, wasHidden.return, error);
							}
						}
					} else if ((22 !== root$1.tag && 23 !== root$1.tag || null === root$1.memoizedState || root$1 === finishedWork) && null !== root$1.child) {
						root$1.child.return = root$1;
						root$1 = root$1.child;
						continue;
					}
					if (root$1 === finishedWork) break a;
					for (; null === root$1.sibling;) {
						if (null === root$1.return || root$1.return === finishedWork) break a;
						current === root$1 && (current = null);
						root$1 = root$1.return;
					}
					current === root$1 && (current = null);
					root$1.sibling.return = root$1.return;
					root$1 = root$1.sibling;
				}
				flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
				break;
			case 19:
				recursivelyTraverseMutationEffects(root$1, finishedWork);
				commitReconciliationEffects(finishedWork);
				flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
				break;
			case 30: break;
			case 21: break;
			default: recursivelyTraverseMutationEffects(root$1, finishedWork), commitReconciliationEffects(finishedWork);
		}
	}
	function commitReconciliationEffects(finishedWork) {
		var flags = finishedWork.flags;
		if (flags & 2) {
			try {
				for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber;) {
					if (isHostParent(parentFiber)) {
						hostParentFiber = parentFiber;
						break;
					}
					parentFiber = parentFiber.return;
				}
				if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
				switch (hostParentFiber.tag) {
					case 27:
						var parent = hostParentFiber.stateNode;
						insertOrAppendPlacementNode(finishedWork, getHostSibling(finishedWork), parent);
						break;
					case 5:
						var parent$141 = hostParentFiber.stateNode;
						hostParentFiber.flags & 32 && (setTextContent(parent$141, ""), hostParentFiber.flags &= -33);
						insertOrAppendPlacementNode(finishedWork, getHostSibling(finishedWork), parent$141);
						break;
					case 3:
					case 4:
						var parent$143 = hostParentFiber.stateNode.containerInfo;
						insertOrAppendPlacementNodeIntoContainer(finishedWork, getHostSibling(finishedWork), parent$143);
						break;
					default: throw Error(formatProdErrorMessage(161));
				}
			} catch (error) {
				captureCommitPhaseError(finishedWork, finishedWork.return, error);
			}
			finishedWork.flags &= -3;
		}
		flags & 4096 && (finishedWork.flags &= -4097);
	}
	function recursivelyResetForms(parentFiber) {
		if (parentFiber.subtreeFlags & 1024) for (parentFiber = parentFiber.child; null !== parentFiber;) {
			var fiber = parentFiber;
			recursivelyResetForms(fiber);
			5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
			parentFiber = parentFiber.sibling;
		}
	}
	function recursivelyTraverseLayoutEffects(root$1, parentFiber) {
		if (parentFiber.subtreeFlags & 8772) for (parentFiber = parentFiber.child; null !== parentFiber;) commitLayoutEffectOnFiber(root$1, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
	}
	function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
		for (parentFiber = parentFiber.child; null !== parentFiber;) {
			var finishedWork = parentFiber;
			switch (finishedWork.tag) {
				case 0:
				case 11:
				case 14:
				case 15:
					commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
					recursivelyTraverseDisappearLayoutEffects(finishedWork);
					break;
				case 1:
					safelyDetachRef(finishedWork, finishedWork.return);
					var instance = finishedWork.stateNode;
					"function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);
					recursivelyTraverseDisappearLayoutEffects(finishedWork);
					break;
				case 27: releaseSingletonInstance(finishedWork.stateNode);
				case 26:
				case 5:
					safelyDetachRef(finishedWork, finishedWork.return);
					recursivelyTraverseDisappearLayoutEffects(finishedWork);
					break;
				case 22:
					null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
					break;
				case 30:
					recursivelyTraverseDisappearLayoutEffects(finishedWork);
					break;
				default: recursivelyTraverseDisappearLayoutEffects(finishedWork);
			}
			parentFiber = parentFiber.sibling;
		}
	}
	function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
		includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
		for (parentFiber = parentFiber.child; null !== parentFiber;) {
			var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
			switch (finishedWork.tag) {
				case 0:
				case 11:
				case 15:
					recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
					commitHookEffectListMount(4, finishedWork);
					break;
				case 1:
					recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
					current = finishedWork;
					finishedRoot = current.stateNode;
					if ("function" === typeof finishedRoot.componentDidMount) try {
						finishedRoot.componentDidMount();
					} catch (error) {
						captureCommitPhaseError(current, current.return, error);
					}
					current = finishedWork;
					finishedRoot = current.updateQueue;
					if (null !== finishedRoot) {
						var instance = current.stateNode;
						try {
							var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
							if (null !== hiddenCallbacks) for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++) callCallback(hiddenCallbacks[finishedRoot], instance);
						} catch (error) {
							captureCommitPhaseError(current, current.return, error);
						}
					}
					includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
					safelyAttachRef(finishedWork, finishedWork.return);
					break;
				case 27: commitHostSingletonAcquisition(finishedWork);
				case 26:
				case 5:
					recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
					includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
					safelyAttachRef(finishedWork, finishedWork.return);
					break;
				case 12:
					recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
					break;
				case 31:
					recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
					includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
					break;
				case 13:
					recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
					includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
					break;
				case 22:
					null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
					safelyAttachRef(finishedWork, finishedWork.return);
					break;
				case 30: break;
				default: recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
			}
			parentFiber = parentFiber.sibling;
		}
	}
	function commitOffscreenPassiveMountEffects(current, finishedWork) {
		var previousCache = null;
		null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
		current = null;
		null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
		current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
	}
	function commitCachePassiveMountEffect(current, finishedWork) {
		current = null;
		null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
		finishedWork = finishedWork.memoizedState.cache;
		finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
	}
	function recursivelyTraversePassiveMountEffects(root$1, parentFiber, committedLanes, committedTransitions) {
		if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) commitPassiveMountOnFiber(root$1, parentFiber, committedLanes, committedTransitions), parentFiber = parentFiber.sibling;
	}
	function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
		var flags = finishedWork.flags;
		switch (finishedWork.tag) {
			case 0:
			case 11:
			case 15:
				recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
				flags & 2048 && commitHookEffectListMount(9, finishedWork);
				break;
			case 1:
				recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
				break;
			case 3:
				recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
				flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
				break;
			case 12:
				if (flags & 2048) {
					recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
					finishedRoot = finishedWork.stateNode;
					try {
						var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
						"function" === typeof onPostCommit && onPostCommit(id, null === finishedWork.alternate ? "mount" : "update", finishedRoot.passiveEffectDuration, -0);
					} catch (error) {
						captureCommitPhaseError(finishedWork, finishedWork.return, error);
					}
				} else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
				break;
			case 31:
				recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
				break;
			case 13:
				recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
				break;
			case 23: break;
			case 22:
				_finishedWork$memoize2 = finishedWork.stateNode;
				id = finishedWork.alternate;
				null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, 0 !== (finishedWork.subtreeFlags & 10256) || !1));
				flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
				break;
			case 24:
				recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
				flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
				break;
			default: recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
		}
	}
	function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
		includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || !1);
		for (parentFiber = parentFiber.child; null !== parentFiber;) {
			var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
			switch (finishedWork.tag) {
				case 0:
				case 11:
				case 15:
					recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
					commitHookEffectListMount(8, finishedWork);
					break;
				case 23: break;
				case 22:
					var instance = finishedWork.stateNode;
					null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects));
					includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
					break;
				case 24:
					recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
					includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
					break;
				default: recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
			}
			parentFiber = parentFiber.sibling;
		}
	}
	function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
		if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) {
			var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
			switch (finishedWork.tag) {
				case 22:
					recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
					flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
					break;
				case 24:
					recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
					flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
					break;
				default: recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
			}
			parentFiber = parentFiber.sibling;
		}
	}
	var suspenseyCommitFlag = 8192;
	function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
		if (parentFiber.subtreeFlags & suspenseyCommitFlag) for (parentFiber = parentFiber.child; null !== parentFiber;) accumulateSuspenseyCommitOnFiber(parentFiber, committedLanes, suspendedState), parentFiber = parentFiber.sibling;
	}
	function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
		switch (fiber.tag) {
			case 26:
				recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);
				fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(suspendedState, currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);
				break;
			case 5:
				recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);
				break;
			case 3:
			case 4:
				var previousHoistableRoot = currentHoistableRoot;
				currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
				recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);
				currentHoistableRoot = previousHoistableRoot;
				break;
			case 22:
				null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState));
				break;
			default: recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);
		}
	}
	function detachAlternateSiblings(parentFiber) {
		var previousFiber = parentFiber.alternate;
		if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
			previousFiber.child = null;
			do
				previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
			while (null !== parentFiber);
		}
	}
	function recursivelyTraversePassiveUnmountEffects(parentFiber) {
		var deletions = parentFiber.deletions;
		if (0 !== (parentFiber.flags & 16)) {
			if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
				var childToDelete = deletions[i];
				nextEffect = childToDelete;
				commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
			}
			detachAlternateSiblings(parentFiber);
		}
		if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
	}
	function commitPassiveUnmountOnFiber(finishedWork) {
		switch (finishedWork.tag) {
			case 0:
			case 11:
			case 15:
				recursivelyTraversePassiveUnmountEffects(finishedWork);
				finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
				break;
			case 3:
				recursivelyTraversePassiveUnmountEffects(finishedWork);
				break;
			case 12:
				recursivelyTraversePassiveUnmountEffects(finishedWork);
				break;
			case 22:
				var instance = finishedWork.stateNode;
				null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
				break;
			default: recursivelyTraversePassiveUnmountEffects(finishedWork);
		}
	}
	function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
		var deletions = parentFiber.deletions;
		if (0 !== (parentFiber.flags & 16)) {
			if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
				var childToDelete = deletions[i];
				nextEffect = childToDelete;
				commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
			}
			detachAlternateSiblings(parentFiber);
		}
		for (parentFiber = parentFiber.child; null !== parentFiber;) {
			deletions = parentFiber;
			switch (deletions.tag) {
				case 0:
				case 11:
				case 15:
					commitHookEffectListUnmount(8, deletions, deletions.return);
					recursivelyTraverseDisconnectPassiveEffects(deletions);
					break;
				case 22:
					i = deletions.stateNode;
					i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
					break;
				default: recursivelyTraverseDisconnectPassiveEffects(deletions);
			}
			parentFiber = parentFiber.sibling;
		}
	}
	function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
		for (; null !== nextEffect;) {
			var fiber = nextEffect;
			switch (fiber.tag) {
				case 0:
				case 11:
				case 15:
					commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
					break;
				case 23:
				case 22:
					if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
						var cache = fiber.memoizedState.cachePool.pool;
						null != cache && cache.refCount++;
					}
					break;
				case 24: releaseCache(fiber.memoizedState.cache);
			}
			cache = fiber.child;
			if (null !== cache) cache.return = fiber, nextEffect = cache;
			else a: for (fiber = deletedSubtreeRoot; null !== nextEffect;) {
				cache = nextEffect;
				var sibling = cache.sibling, returnFiber = cache.return;
				detachFiberAfterEffects(cache);
				if (cache === fiber) {
					nextEffect = null;
					break a;
				}
				if (null !== sibling) {
					sibling.return = returnFiber;
					nextEffect = sibling;
					break a;
				}
				nextEffect = returnFiber;
			}
		}
	}
	var DefaultAsyncDispatcher = {
		getCacheForType: function(resourceType) {
			var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
			void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
			return cacheForType;
		},
		cacheSignal: function() {
			return readContext(CacheContext).controller.signal;
		}
	}, PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = !1, workInProgressRootIsPrerendering = !1, workInProgressRootDidAttachPingListener = !1, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = !1, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
	function requestUpdateLane() {
		return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes : null !== ReactSharedInternals.T ? requestTransitionLane() : resolveUpdatePriority();
	}
	function requestDeferredLane() {
		if (0 === workInProgressDeferredLane) if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
			var lane = nextTransitionDeferredLane;
			nextTransitionDeferredLane <<= 1;
			0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
			workInProgressDeferredLane = lane;
		} else workInProgressDeferredLane = 536870912;
		lane = suspenseHandlerStackCursor.current;
		null !== lane && (lane.flags |= 32);
		return workInProgressDeferredLane;
	}
	function scheduleUpdateOnFiber(root$1, fiber, lane) {
		if (root$1 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root$1.cancelPendingCommit) prepareFreshStack(root$1, 0), markRootSuspended(root$1, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);
		markRootUpdated$1(root$1, lane);
		if (0 === (executionContext & 2) || root$1 !== workInProgressRoot) root$1 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(root$1, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)), ensureRootIsScheduled(root$1);
	}
	function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
		if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
		var shouldTimeSlice = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, !0), renderWasConcurrent = shouldTimeSlice;
		do {
			if (0 === exitStatus) {
				workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, !1);
				break;
			} else {
				forceSync = root$jscomp$0.current.alternate;
				if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
					exitStatus = renderRootSync(root$jscomp$0, lanes, !1);
					renderWasConcurrent = !1;
					continue;
				}
				if (2 === exitStatus) {
					renderWasConcurrent = lanes;
					if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent) var JSCompiler_inline_result = 0;
					else JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
					if (0 !== JSCompiler_inline_result) {
						lanes = JSCompiler_inline_result;
						a: {
							var root$1 = root$jscomp$0;
							exitStatus = workInProgressRootConcurrentErrors;
							var wasRootDehydrated = root$1.current.memoizedState.isDehydrated;
							wasRootDehydrated && (prepareFreshStack(root$1, JSCompiler_inline_result).flags |= 256);
							JSCompiler_inline_result = renderRootSync(root$1, JSCompiler_inline_result, !1);
							if (2 !== JSCompiler_inline_result) {
								if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
									root$1.errorRecoveryDisabledLanes |= renderWasConcurrent;
									workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
									exitStatus = 4;
									break a;
								}
								renderWasConcurrent = workInProgressRootRecoverableErrors;
								workInProgressRootRecoverableErrors = exitStatus;
								null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, renderWasConcurrent));
							}
							exitStatus = JSCompiler_inline_result;
						}
						renderWasConcurrent = !1;
						if (2 !== exitStatus) continue;
					}
				}
				if (1 === exitStatus) {
					prepareFreshStack(root$jscomp$0, 0);
					markRootSuspended(root$jscomp$0, lanes, 0, !0);
					break;
				}
				a: {
					shouldTimeSlice = root$jscomp$0;
					renderWasConcurrent = exitStatus;
					switch (renderWasConcurrent) {
						case 0:
						case 1: throw Error(formatProdErrorMessage(345));
						case 4: if ((lanes & 4194048) !== lanes) break;
						case 6:
							markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
							break a;
						case 2:
							workInProgressRootRecoverableErrors = null;
							break;
						case 3:
						case 5: break;
						default: throw Error(formatProdErrorMessage(329));
					}
					if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
						markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
						if (0 !== getNextLanes(shouldTimeSlice, 0, !0)) break a;
						pendingEffectsLanes = lanes;
						shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, renderWasConcurrent, "Throttled", -0, 0), exitStatus);
						break a;
					}
					commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, renderWasConcurrent, null, -0, 0);
				}
			}
			break;
		} while (1);
		ensureRootIsScheduled(root$jscomp$0);
	}
	function commitRootWhenReady(root$1, finishedWork, recoverableErrors, transitions$1, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
		root$1.timeoutHandle = -1;
		suspendedCommitReason = finishedWork.subtreeFlags;
		if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
			suspendedCommitReason = {
				stylesheets: null,
				count: 0,
				imgCount: 0,
				imgBytes: 0,
				suspenseyImages: [],
				waitingForImages: !0,
				waitingForViewTransition: !1,
				unsuspend: noop$1$1
			};
			accumulateSuspenseyCommitOnFiber(finishedWork, lanes, suspendedCommitReason);
			var timeoutOffset = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now() : 0;
			timeoutOffset = waitForCommitToBeReady(suspendedCommitReason, timeoutOffset);
			if (null !== timeoutOffset) {
				pendingEffectsLanes = lanes;
				root$1.cancelPendingCommit = timeoutOffset(commitRoot.bind(null, root$1, finishedWork, lanes, recoverableErrors, transitions$1, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedCommitReason, null, completedRenderStartTime, completedRenderEndTime));
				markRootSuspended(root$1, lanes, spawnedLane, !didSkipSuspendedSiblings);
				return;
			}
		}
		commitRoot(root$1, finishedWork, lanes, recoverableErrors, transitions$1, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
	}
	function isRenderConsistentWithExternalStores(finishedWork) {
		for (var node = finishedWork;;) {
			var tag = node.tag;
			if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag))) for (var i = 0; i < tag.length; i++) {
				var check = tag[i], getSnapshot = check.getSnapshot;
				check = check.value;
				try {
					if (!objectIs(getSnapshot(), check)) return !1;
				} catch (error) {
					return !1;
				}
			}
			tag = node.child;
			if (node.subtreeFlags & 16384 && null !== tag) tag.return = node, node = tag;
			else {
				if (node === finishedWork) break;
				for (; null === node.sibling;) {
					if (null === node.return || node.return === finishedWork) return !0;
					node = node.return;
				}
				node.sibling.return = node.return;
				node = node.sibling;
			}
		}
		return !0;
	}
	function markRootSuspended(root$1, suspendedLanes, spawnedLane, didAttemptEntireTree) {
		suspendedLanes &= ~workInProgressRootPingedLanes;
		suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
		root$1.suspendedLanes |= suspendedLanes;
		root$1.pingedLanes &= ~suspendedLanes;
		didAttemptEntireTree && (root$1.warmLanes |= suspendedLanes);
		didAttemptEntireTree = root$1.expirationTimes;
		for (var lanes = suspendedLanes; 0 < lanes;) {
			var index$6 = 31 - clz32(lanes), lane = 1 << index$6;
			didAttemptEntireTree[index$6] = -1;
			lanes &= ~lane;
		}
		0 !== spawnedLane && markSpawnedDeferredLane(root$1, spawnedLane, suspendedLanes);
	}
	function flushSyncWork$1() {
		return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0, !1), !1) : !0;
	}
	function resetWorkInProgressStack() {
		if (null !== workInProgress) {
			if (0 === workInProgressSuspendedReason) var interruptedWork = workInProgress.return;
			else interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
			for (; null !== interruptedWork;) unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
			workInProgress = null;
		}
	}
	function prepareFreshStack(root$1, lanes) {
		var timeoutHandle = root$1.timeoutHandle;
		-1 !== timeoutHandle && (root$1.timeoutHandle = -1, cancelTimeout(timeoutHandle));
		timeoutHandle = root$1.cancelPendingCommit;
		null !== timeoutHandle && (root$1.cancelPendingCommit = null, timeoutHandle());
		pendingEffectsLanes = 0;
		resetWorkInProgressStack();
		workInProgressRoot = root$1;
		workInProgress = timeoutHandle = createWorkInProgress(root$1.current, null);
		workInProgressRootRenderLanes = lanes;
		workInProgressSuspendedReason = 0;
		workInProgressThrownValue = null;
		workInProgressRootDidSkipSuspendedSiblings = !1;
		workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root$1, lanes);
		workInProgressRootDidAttachPingListener = !1;
		workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
		workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
		workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
		0 !== (lanes & 8) && (lanes |= lanes & 32);
		var allEntangledLanes = root$1.entangledLanes;
		if (0 !== allEntangledLanes) for (root$1 = root$1.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;) {
			var index$4 = 31 - clz32(allEntangledLanes), lane = 1 << index$4;
			lanes |= root$1[index$4];
			allEntangledLanes &= ~lane;
		}
		entangledRenderLanes = lanes;
		finishQueueingConcurrentUpdates();
		return timeoutHandle;
	}
	function handleThrow(root$1, thrownValue) {
		currentlyRenderingFiber = null;
		ReactSharedInternals.H = ContextOnlyDispatcher;
		thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
		workInProgressThrownValue = thrownValue;
		null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(root$1, createCapturedValueAtFiber(thrownValue, root$1.current)));
	}
	function shouldRemainOnPreviousScreen() {
		var handler = suspenseHandlerStackCursor.current;
		return null === handler ? !0 : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? !0 : !1 : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : !1;
	}
	function pushDispatcher() {
		var prevDispatcher = ReactSharedInternals.H;
		ReactSharedInternals.H = ContextOnlyDispatcher;
		return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
	}
	function pushAsyncDispatcher() {
		var prevAsyncDispatcher = ReactSharedInternals.A;
		ReactSharedInternals.A = DefaultAsyncDispatcher;
		return prevAsyncDispatcher;
	}
	function renderDidSuspendDelayIfPossible() {
		workInProgressRootExitStatus = 4;
		workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = !0);
		0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);
	}
	function renderRootSync(root$1, lanes, shouldYieldForPrerendering) {
		var prevExecutionContext = executionContext;
		executionContext |= 2;
		var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
		if (workInProgressRoot !== root$1 || workInProgressRootRenderLanes !== lanes) workInProgressTransitions = null, prepareFreshStack(root$1, lanes);
		lanes = !1;
		var exitStatus = workInProgressRootExitStatus;
		a: do
			try {
				if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
					var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
					switch (workInProgressSuspendedReason) {
						case 8:
							resetWorkInProgressStack();
							exitStatus = 6;
							break a;
						case 3:
						case 2:
						case 9:
						case 6:
							null === suspenseHandlerStackCursor.current && (lanes = !0);
							var reason = workInProgressSuspendedReason;
							workInProgressSuspendedReason = 0;
							workInProgressThrownValue = null;
							throwAndUnwindWorkLoop(root$1, unitOfWork, thrownValue, reason);
							if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
								exitStatus = 0;
								break a;
							}
							break;
						default: reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root$1, unitOfWork, thrownValue, reason);
					}
				}
				workLoopSync();
				exitStatus = workInProgressRootExitStatus;
				break;
			} catch (thrownValue$165) {
				handleThrow(root$1, thrownValue$165);
			}
		while (1);
		lanes && root$1.shellSuspendCounter++;
		lastContextDependency = currentlyRenderingFiber$1 = null;
		executionContext = prevExecutionContext;
		ReactSharedInternals.H = prevDispatcher;
		ReactSharedInternals.A = prevAsyncDispatcher;
		null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
		return exitStatus;
	}
	function workLoopSync() {
		for (; null !== workInProgress;) performUnitOfWork(workInProgress);
	}
	function renderRootConcurrent(root$1, lanes) {
		var prevExecutionContext = executionContext;
		executionContext |= 2;
		var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
		workInProgressRoot !== root$1 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root$1, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root$1, lanes);
		a: do
			try {
				if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
					lanes = workInProgress;
					var thrownValue = workInProgressThrownValue;
					b: switch (workInProgressSuspendedReason) {
						case 1:
							workInProgressSuspendedReason = 0;
							workInProgressThrownValue = null;
							throwAndUnwindWorkLoop(root$1, lanes, thrownValue, 1);
							break;
						case 2:
						case 9:
							if (isThenableResolved(thrownValue)) {
								workInProgressSuspendedReason = 0;
								workInProgressThrownValue = null;
								replaySuspendedUnitOfWork(lanes);
								break;
							}
							lanes = function() {
								2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root$1 || (workInProgressSuspendedReason = 7);
								ensureRootIsScheduled(root$1);
							};
							thrownValue.then(lanes, lanes);
							break a;
						case 3:
							workInProgressSuspendedReason = 7;
							break a;
						case 4:
							workInProgressSuspendedReason = 5;
							break a;
						case 7:
							isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root$1, lanes, thrownValue, 7));
							break;
						case 5:
							var resource = null;
							switch (workInProgress.tag) {
								case 26: resource = workInProgress.memoizedState;
								case 5:
								case 27:
									var hostFiber = workInProgress;
									if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
										workInProgressSuspendedReason = 0;
										workInProgressThrownValue = null;
										var sibling = hostFiber.sibling;
										if (null !== sibling) workInProgress = sibling;
										else {
											var returnFiber = hostFiber.return;
											null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
										}
										break b;
									}
							}
							workInProgressSuspendedReason = 0;
							workInProgressThrownValue = null;
							throwAndUnwindWorkLoop(root$1, lanes, thrownValue, 5);
							break;
						case 6:
							workInProgressSuspendedReason = 0;
							workInProgressThrownValue = null;
							throwAndUnwindWorkLoop(root$1, lanes, thrownValue, 6);
							break;
						case 8:
							resetWorkInProgressStack();
							workInProgressRootExitStatus = 6;
							break a;
						default: throw Error(formatProdErrorMessage(462));
					}
				}
				workLoopConcurrentByScheduler();
				break;
			} catch (thrownValue$167) {
				handleThrow(root$1, thrownValue$167);
			}
		while (1);
		lastContextDependency = currentlyRenderingFiber$1 = null;
		ReactSharedInternals.H = prevDispatcher;
		ReactSharedInternals.A = prevAsyncDispatcher;
		executionContext = prevExecutionContext;
		if (null !== workInProgress) return 0;
		workInProgressRoot = null;
		workInProgressRootRenderLanes = 0;
		finishQueueingConcurrentUpdates();
		return workInProgressRootExitStatus;
	}
	function workLoopConcurrentByScheduler() {
		for (; null !== workInProgress && !shouldYield();) performUnitOfWork(workInProgress);
	}
	function performUnitOfWork(unitOfWork) {
		var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
		unitOfWork.memoizedProps = unitOfWork.pendingProps;
		null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
	}
	function replaySuspendedUnitOfWork(unitOfWork) {
		var next = unitOfWork;
		var current = next.alternate;
		switch (next.tag) {
			case 15:
			case 0:
				next = replayFunctionComponent(current, next, next.pendingProps, next.type, void 0, workInProgressRootRenderLanes);
				break;
			case 11:
				next = replayFunctionComponent(current, next, next.pendingProps, next.type.render, next.ref, workInProgressRootRenderLanes);
				break;
			case 5: resetHooksOnUnwind(next);
			default: unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
		}
		unitOfWork.memoizedProps = unitOfWork.pendingProps;
		null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
	}
	function throwAndUnwindWorkLoop(root$1, unitOfWork, thrownValue, suspendedReason) {
		lastContextDependency = currentlyRenderingFiber$1 = null;
		resetHooksOnUnwind(unitOfWork);
		thenableState$1 = null;
		thenableIndexCounter$1 = 0;
		var returnFiber = unitOfWork.return;
		try {
			if (throwException(root$1, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {
				workInProgressRootExitStatus = 1;
				logUncaughtError(root$1, createCapturedValueAtFiber(thrownValue, root$1.current));
				workInProgress = null;
				return;
			}
		} catch (error) {
			if (null !== returnFiber) throw workInProgress = returnFiber, error;
			workInProgressRootExitStatus = 1;
			logUncaughtError(root$1, createCapturedValueAtFiber(thrownValue, root$1.current));
			workInProgress = null;
			return;
		}
		if (unitOfWork.flags & 32768) {
			if (isHydrating || 1 === suspendedReason) root$1 = !0;
			else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root$1 = !1;
			else if (workInProgressRootDidSkipSuspendedSiblings = root$1 = !0, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason) suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
			unwindUnitOfWork(unitOfWork, root$1);
		} else completeUnitOfWork(unitOfWork);
	}
	function completeUnitOfWork(unitOfWork) {
		var completedWork = unitOfWork;
		do {
			if (0 !== (completedWork.flags & 32768)) {
				unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);
				return;
			}
			unitOfWork = completedWork.return;
			var next = completeWork(completedWork.alternate, completedWork, entangledRenderLanes);
			if (null !== next) {
				workInProgress = next;
				return;
			}
			completedWork = completedWork.sibling;
			if (null !== completedWork) {
				workInProgress = completedWork;
				return;
			}
			workInProgress = completedWork = unitOfWork;
		} while (null !== completedWork);
		0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
	}
	function unwindUnitOfWork(unitOfWork, skipSiblings) {
		do {
			var next = unwindWork(unitOfWork.alternate, unitOfWork);
			if (null !== next) {
				next.flags &= 32767;
				workInProgress = next;
				return;
			}
			next = unitOfWork.return;
			null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
			if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
				workInProgress = unitOfWork;
				return;
			}
			workInProgress = unitOfWork = next;
		} while (null !== unitOfWork);
		workInProgressRootExitStatus = 6;
		workInProgress = null;
	}
	function commitRoot(root$1, finishedWork, lanes, recoverableErrors, transitions$1, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
		root$1.cancelPendingCommit = null;
		do
			flushPendingEffects();
		while (0 !== pendingEffectsStatus);
		if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
		if (null !== finishedWork) {
			if (finishedWork === root$1.current) throw Error(formatProdErrorMessage(177));
			didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
			didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
			markRootFinished(root$1, lanes, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
			root$1 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
			pendingFinishedWork = finishedWork;
			pendingEffectsRoot = root$1;
			pendingEffectsLanes = lanes;
			pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
			pendingPassiveTransitions = transitions$1;
			pendingRecoverableErrors = recoverableErrors;
			0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root$1.callbackNode = null, root$1.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
				flushPassiveEffects();
				return null;
			})) : (root$1.callbackNode = null, root$1.callbackPriority = 0);
			recoverableErrors = 0 !== (finishedWork.flags & 13878);
			if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
				recoverableErrors = ReactSharedInternals.T;
				ReactSharedInternals.T = null;
				transitions$1 = ReactDOMSharedInternals.p;
				ReactDOMSharedInternals.p = 2;
				spawnedLane = executionContext;
				executionContext |= 4;
				try {
					commitBeforeMutationEffects(root$1, finishedWork, lanes);
				} finally {
					executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions$1, ReactSharedInternals.T = recoverableErrors;
				}
			}
			pendingEffectsStatus = 1;
			flushMutationEffects();
			flushLayoutEffects();
			flushSpawnedWork();
		}
	}
	function flushMutationEffects() {
		if (1 === pendingEffectsStatus) {
			pendingEffectsStatus = 0;
			var root$1 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
			if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
				rootMutationHasEffect = ReactSharedInternals.T;
				ReactSharedInternals.T = null;
				var previousPriority = ReactDOMSharedInternals.p;
				ReactDOMSharedInternals.p = 2;
				var prevExecutionContext = executionContext;
				executionContext |= 4;
				try {
					commitMutationEffectsOnFiber(finishedWork, root$1);
					var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root$1.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
					if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(priorFocusedElem.ownerDocument.documentElement, priorFocusedElem)) {
						if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
							var start = priorSelectionRange.start, end = priorSelectionRange.end;
							void 0 === end && (end = start);
							if ("selectionStart" in priorFocusedElem) priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(end, priorFocusedElem.value.length);
							else {
								var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
								if (win.getSelection) {
									var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
									!selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
									var startMarker = getNodeForCharacterOffset(priorFocusedElem, start$jscomp$0), endMarker = getNodeForCharacterOffset(priorFocusedElem, end$jscomp$0);
									if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
										var range = doc.createRange();
										range.setStart(startMarker.node, startMarker.offset);
										selection.removeAllRanges();
										start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
									}
								}
							}
						}
						doc = [];
						for (selection = priorFocusedElem; selection = selection.parentNode;) 1 === selection.nodeType && doc.push({
							element: selection,
							left: selection.scrollLeft,
							top: selection.scrollTop
						});
						"function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
						for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
							var info = doc[priorFocusedElem];
							info.element.scrollLeft = info.left;
							info.element.scrollTop = info.top;
						}
					}
					_enabled = !!eventsEnabled;
					selectionInformation = eventsEnabled = null;
				} finally {
					executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
				}
			}
			root$1.current = finishedWork;
			pendingEffectsStatus = 2;
		}
	}
	function flushLayoutEffects() {
		if (2 === pendingEffectsStatus) {
			pendingEffectsStatus = 0;
			var root$1 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
			if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
				rootHasLayoutEffect = ReactSharedInternals.T;
				ReactSharedInternals.T = null;
				var previousPriority = ReactDOMSharedInternals.p;
				ReactDOMSharedInternals.p = 2;
				var prevExecutionContext = executionContext;
				executionContext |= 4;
				try {
					commitLayoutEffectOnFiber(root$1, finishedWork.alternate, finishedWork);
				} finally {
					executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
				}
			}
			pendingEffectsStatus = 3;
		}
	}
	function flushSpawnedWork() {
		if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
			pendingEffectsStatus = 0;
			requestPaint();
			var root$1 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
			0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root$1, root$1.pendingLanes));
			var remainingLanes = root$1.pendingLanes;
			0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
			lanesToEventPriority(lanes);
			finishedWork = finishedWork.stateNode;
			if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot) try {
				injectedHook.onCommitFiberRoot(rendererID, finishedWork, void 0, 128 === (finishedWork.current.flags & 128));
			} catch (err) {}
			if (null !== recoverableErrors) {
				finishedWork = ReactSharedInternals.T;
				remainingLanes = ReactDOMSharedInternals.p;
				ReactDOMSharedInternals.p = 2;
				ReactSharedInternals.T = null;
				try {
					for (var onRecoverableError = root$1.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
						var recoverableError = recoverableErrors[i];
						onRecoverableError(recoverableError.value, { componentStack: recoverableError.stack });
					}
				} finally {
					ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
				}
			}
			0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
			ensureRootIsScheduled(root$1);
			remainingLanes = root$1.pendingLanes;
			0 !== (lanes & 261930) && 0 !== (remainingLanes & 42) ? root$1 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root$1) : nestedUpdateCount = 0;
			flushSyncWorkAcrossRoots_impl(0, !1);
		}
	}
	function releaseRootPooledCache(root$1, remainingLanes) {
		0 === (root$1.pooledCacheLanes &= remainingLanes) && (remainingLanes = root$1.pooledCache, null != remainingLanes && (root$1.pooledCache = null, releaseCache(remainingLanes)));
	}
	function flushPendingEffects() {
		flushMutationEffects();
		flushLayoutEffects();
		flushSpawnedWork();
		return flushPassiveEffects();
	}
	function flushPassiveEffects() {
		if (5 !== pendingEffectsStatus) return !1;
		var root$1 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
		pendingEffectsRemainingLanes = 0;
		var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
		try {
			ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
			ReactSharedInternals.T = null;
			renderPriority = pendingPassiveTransitions;
			pendingPassiveTransitions = null;
			var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
			pendingEffectsStatus = 0;
			pendingFinishedWork = pendingEffectsRoot = null;
			pendingEffectsLanes = 0;
			if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
			var prevExecutionContext = executionContext;
			executionContext |= 4;
			commitPassiveUnmountOnFiber(root$jscomp$0.current);
			commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, renderPriority);
			executionContext = prevExecutionContext;
			flushSyncWorkAcrossRoots_impl(0, !1);
			if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot) try {
				injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
			} catch (err) {}
			return !0;
		} finally {
			ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root$1, remainingLanes);
		}
	}
	function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
		sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
		sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
		rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
		null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
	}
	function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
		if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
		else for (; null !== nearestMountedAncestor;) {
			if (3 === nearestMountedAncestor.tag) {
				captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
				break;
			} else if (1 === nearestMountedAncestor.tag) {
				var instance = nearestMountedAncestor.stateNode;
				if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
					sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
					error = createClassErrorUpdate(2);
					instance = enqueueUpdate(nearestMountedAncestor, error, 2);
					null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
					break;
				}
			}
			nearestMountedAncestor = nearestMountedAncestor.return;
		}
	}
	function attachPingListener(root$1, wakeable, lanes) {
		var pingCache = root$1.pingCache;
		if (null === pingCache) {
			pingCache = root$1.pingCache = new PossiblyWeakMap();
			var threadIDs = /* @__PURE__ */ new Set();
			pingCache.set(wakeable, threadIDs);
		} else threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
		threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = !0, threadIDs.add(lanes), root$1 = pingSuspendedRoot.bind(null, root$1, wakeable, lanes), wakeable.then(root$1, root$1));
	}
	function pingSuspendedRoot(root$1, wakeable, pingedLanes) {
		var pingCache = root$1.pingCache;
		null !== pingCache && pingCache.delete(wakeable);
		root$1.pingedLanes |= root$1.suspendedLanes & pingedLanes;
		root$1.warmLanes &= ~pingedLanes;
		workInProgressRoot === root$1 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root$1, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
		ensureRootIsScheduled(root$1);
	}
	function retryTimedOutBoundary(boundaryFiber, retryLane) {
		0 === retryLane && (retryLane = claimNextRetryLane());
		boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
		null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
	}
	function retryDehydratedSuspenseBoundary(boundaryFiber) {
		var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
		null !== suspenseState && (retryLane = suspenseState.retryLane);
		retryTimedOutBoundary(boundaryFiber, retryLane);
	}
	function resolveRetryWakeable(boundaryFiber, wakeable) {
		var retryLane = 0;
		switch (boundaryFiber.tag) {
			case 31:
			case 13:
				var retryCache = boundaryFiber.stateNode;
				var suspenseState = boundaryFiber.memoizedState;
				null !== suspenseState && (retryLane = suspenseState.retryLane);
				break;
			case 19:
				retryCache = boundaryFiber.stateNode;
				break;
			case 22:
				retryCache = boundaryFiber.stateNode._retryCache;
				break;
			default: throw Error(formatProdErrorMessage(314));
		}
		null !== retryCache && retryCache.delete(wakeable);
		retryTimedOutBoundary(boundaryFiber, retryLane);
	}
	function scheduleCallback$1(priorityLevel, callback) {
		return scheduleCallback$3(priorityLevel, callback);
	}
	var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = !1, mightHavePendingSyncWork = !1, isFlushingWork = !1, currentEventTransitionLane = 0;
	function ensureRootIsScheduled(root$1) {
		root$1 !== lastScheduledRoot && null === root$1.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root$1 : lastScheduledRoot = lastScheduledRoot.next = root$1);
		mightHavePendingSyncWork = !0;
		didScheduleMicrotask || (didScheduleMicrotask = !0, scheduleImmediateRootScheduleTask());
	}
	function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
		if (!isFlushingWork && mightHavePendingSyncWork) {
			isFlushingWork = !0;
			do {
				var didPerformSomeWork = !1;
				for (var root$170 = firstScheduledRoot; null !== root$170;) {
					if (!onlyLegacy) if (0 !== syncTransitionLanes) {
						var pendingLanes = root$170.pendingLanes;
						if (0 === pendingLanes) var JSCompiler_inline_result = 0;
						else {
							var suspendedLanes = root$170.suspendedLanes, pingedLanes = root$170.pingedLanes;
							JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
							JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
							JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
						}
						0 !== JSCompiler_inline_result && (didPerformSomeWork = !0, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
					} else JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(root$170, root$170 === workInProgressRoot ? JSCompiler_inline_result : 0, null !== root$170.cancelPendingCommit || -1 !== root$170.timeoutHandle), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$170, JSCompiler_inline_result) || (didPerformSomeWork = !0, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
					root$170 = root$170.next;
				}
			} while (didPerformSomeWork);
			isFlushingWork = !1;
		}
	}
	function processRootScheduleInImmediateTask() {
		processRootScheduleInMicrotask();
	}
	function processRootScheduleInMicrotask() {
		mightHavePendingSyncWork = didScheduleMicrotask = !1;
		var syncTransitionLanes = 0;
		0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
		for (var currentTime = now(), prev = null, root$1 = firstScheduledRoot; null !== root$1;) {
			var next = root$1.next, nextLanes = scheduleTaskForRootDuringMicrotask(root$1, currentTime);
			if (0 === nextLanes) root$1.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
			else if (prev = root$1, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)) mightHavePendingSyncWork = !0;
			root$1 = next;
		}
		0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus || flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
		0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
	}
	function scheduleTaskForRootDuringMicrotask(root$1, currentTime) {
		for (var suspendedLanes = root$1.suspendedLanes, pingedLanes = root$1.pingedLanes, expirationTimes = root$1.expirationTimes, lanes = root$1.pendingLanes & -62914561; 0 < lanes;) {
			var index$5 = 31 - clz32(lanes), lane = 1 << index$5, expirationTime = expirationTimes[index$5];
			if (-1 === expirationTime) {
				if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
			} else expirationTime <= currentTime && (root$1.expiredLanes |= lane);
			lanes &= ~lane;
		}
		currentTime = workInProgressRoot;
		suspendedLanes = workInProgressRootRenderLanes;
		suspendedLanes = getNextLanes(root$1, root$1 === currentTime ? suspendedLanes : 0, null !== root$1.cancelPendingCommit || -1 !== root$1.timeoutHandle);
		pingedLanes = root$1.callbackNode;
		if (0 === suspendedLanes || root$1 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root$1.cancelPendingCommit) return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root$1.callbackNode = null, root$1.callbackPriority = 0;
		if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root$1, suspendedLanes)) {
			currentTime = suspendedLanes & -suspendedLanes;
			if (currentTime === root$1.callbackPriority) return currentTime;
			null !== pingedLanes && cancelCallback$1(pingedLanes);
			switch (lanesToEventPriority(suspendedLanes)) {
				case 2:
				case 8:
					suspendedLanes = UserBlockingPriority;
					break;
				case 32:
					suspendedLanes = NormalPriority$1;
					break;
				case 268435456:
					suspendedLanes = IdlePriority;
					break;
				default: suspendedLanes = NormalPriority$1;
			}
			pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root$1);
			suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
			root$1.callbackPriority = currentTime;
			root$1.callbackNode = suspendedLanes;
			return currentTime;
		}
		null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
		root$1.callbackPriority = 2;
		root$1.callbackNode = null;
		return 2;
	}
	function performWorkOnRootViaSchedulerTask(root$1, didTimeout) {
		if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus) return root$1.callbackNode = null, root$1.callbackPriority = 0, null;
		var originalCallbackNode = root$1.callbackNode;
		if (flushPendingEffects() && root$1.callbackNode !== originalCallbackNode) return null;
		var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
		workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root$1, root$1 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0, null !== root$1.cancelPendingCommit || -1 !== root$1.timeoutHandle);
		if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
		performWorkOnRoot(root$1, workInProgressRootRenderLanes$jscomp$0, didTimeout);
		scheduleTaskForRootDuringMicrotask(root$1, now());
		return null != root$1.callbackNode && root$1.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root$1) : null;
	}
	function performSyncWorkOnRoot(root$1, lanes) {
		if (flushPendingEffects()) return null;
		performWorkOnRoot(root$1, lanes, !0);
	}
	function scheduleImmediateRootScheduleTask() {
		scheduleMicrotask(function() {
			0 !== (executionContext & 6) ? scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask) : processRootScheduleInMicrotask();
		});
	}
	function requestTransitionLane() {
		if (0 === currentEventTransitionLane) {
			var actionScopeLane = currentEntangledLane;
			0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
			currentEventTransitionLane = actionScopeLane;
		}
		return currentEventTransitionLane;
	}
	function coerceFormActionProp(actionProp) {
		return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
	}
	function createFormDataWithSubmitter(form, submitter) {
		var temp = submitter.ownerDocument.createElement("input");
		temp.name = submitter.name;
		temp.value = submitter.value;
		form.id && temp.setAttribute("form", form.id);
		submitter.parentNode.insertBefore(temp, submitter);
		form = new FormData(form);
		temp.parentNode.removeChild(temp);
		return form;
	}
	function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
		if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
			var action = coerceFormActionProp((nativeEventTarget[internalPropsKey] || null).action), submitter = nativeEvent.submitter;
			submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
			var event = new SyntheticEvent("action", "action", null, nativeEvent, nativeEventTarget);
			dispatchQueue.push({
				event,
				listeners: [{
					instance: null,
					listener: function() {
						if (nativeEvent.defaultPrevented) {
							if (0 !== currentEventTransitionLane) {
								var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
								startHostTransition(maybeTargetInst, {
									pending: !0,
									data: formData,
									method: nativeEventTarget.method,
									action
								}, null, formData);
							}
						} else "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(maybeTargetInst, {
							pending: !0,
							data: formData,
							method: nativeEventTarget.method,
							action
						}, action, formData));
					},
					currentTarget: nativeEventTarget
				}]
			});
		}
	}
	for (var i$jscomp$inline_1577 = 0; i$jscomp$inline_1577 < simpleEventPluginEvents.length; i$jscomp$inline_1577++) {
		var eventName$jscomp$inline_1578 = simpleEventPluginEvents[i$jscomp$inline_1577];
		registerSimpleEvent(eventName$jscomp$inline_1578.toLowerCase(), "on" + (eventName$jscomp$inline_1578[0].toUpperCase() + eventName$jscomp$inline_1578.slice(1)));
	}
	registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
	registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
	registerSimpleEvent(ANIMATION_START, "onAnimationStart");
	registerSimpleEvent("dblclick", "onDoubleClick");
	registerSimpleEvent("focusin", "onFocus");
	registerSimpleEvent("focusout", "onBlur");
	registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
	registerSimpleEvent(TRANSITION_START, "onTransitionStart");
	registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
	registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
	registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
	registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
	registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
	registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
	registerTwoPhaseEvent("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
	registerTwoPhaseEvent("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
	registerTwoPhaseEvent("onBeforeInput", [
		"compositionend",
		"keypress",
		"textInput",
		"paste"
	]);
	registerTwoPhaseEvent("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
	registerTwoPhaseEvent("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
	registerTwoPhaseEvent("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
	var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), nonDelegatedEvents = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes));
	function processDispatchQueue(dispatchQueue, eventSystemFlags) {
		eventSystemFlags = 0 !== (eventSystemFlags & 4);
		for (var i = 0; i < dispatchQueue.length; i++) {
			var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
			_dispatchQueue$i = _dispatchQueue$i.listeners;
			a: {
				var previousInstance = void 0;
				if (eventSystemFlags) for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
					var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
					_dispatchListeners$i = _dispatchListeners$i.listener;
					if (instance !== previousInstance && event.isPropagationStopped()) break a;
					previousInstance = _dispatchListeners$i;
					event.currentTarget = currentTarget;
					try {
						previousInstance(event);
					} catch (error) {
						reportGlobalError(error);
					}
					event.currentTarget = null;
					previousInstance = instance;
				}
				else for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
					_dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
					instance = _dispatchListeners$i.instance;
					currentTarget = _dispatchListeners$i.currentTarget;
					_dispatchListeners$i = _dispatchListeners$i.listener;
					if (instance !== previousInstance && event.isPropagationStopped()) break a;
					previousInstance = _dispatchListeners$i;
					event.currentTarget = currentTarget;
					try {
						previousInstance(event);
					} catch (error) {
						reportGlobalError(error);
					}
					event.currentTarget = null;
					previousInstance = instance;
				}
			}
		}
	}
	function listenToNonDelegatedEvent(domEventName, targetElement) {
		var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
		void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
		var listenerSetKey = domEventName + "__bubble";
		JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, !1), JSCompiler_inline_result.add(listenerSetKey));
	}
	function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
		var eventSystemFlags = 0;
		isCapturePhaseListener && (eventSystemFlags |= 4);
		addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
	}
	var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
	function listenToAllSupportedEvents(rootContainerElement) {
		if (!rootContainerElement[listeningMarker]) {
			rootContainerElement[listeningMarker] = !0;
			allNativeEvents.forEach(function(domEventName) {
				"selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, !1, rootContainerElement), listenToNativeEvent(domEventName, !0, rootContainerElement));
			});
			var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
			null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = !0, listenToNativeEvent("selectionchange", !1, ownerDocument));
		}
	}
	function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
		switch (getEventPriority(domEventName)) {
			case 2:
				var listenerWrapper = dispatchDiscreteEvent;
				break;
			case 8:
				listenerWrapper = dispatchContinuousEvent;
				break;
			default: listenerWrapper = dispatchEvent;
		}
		eventSystemFlags = listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
		listenerWrapper = void 0;
		!passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = !0);
		isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
			capture: !0,
			passive: listenerWrapper
		}) : targetContainer.addEventListener(domEventName, eventSystemFlags, !0) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, { passive: listenerWrapper }) : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);
	}
	function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
		var ancestorInst = targetInst$jscomp$0;
		if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0) a: for (;;) {
			if (null === targetInst$jscomp$0) return;
			var nodeTag = targetInst$jscomp$0.tag;
			if (3 === nodeTag || 4 === nodeTag) {
				var container = targetInst$jscomp$0.stateNode.containerInfo;
				if (container === targetContainer) break;
				if (4 === nodeTag) for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag;) {
					var grandTag = nodeTag.tag;
					if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer) return;
					nodeTag = nodeTag.return;
				}
				for (; null !== container;) {
					nodeTag = getClosestInstanceFromNode(container);
					if (null === nodeTag) return;
					grandTag = nodeTag.tag;
					if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
						targetInst$jscomp$0 = ancestorInst = nodeTag;
						continue a;
					}
					container = container.parentNode;
				}
			}
			targetInst$jscomp$0 = targetInst$jscomp$0.return;
		}
		batchedUpdates$1(function() {
			var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
			a: {
				var reactName = topLevelEventsToReactNames.get(domEventName);
				if (void 0 !== reactName) {
					var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
					switch (domEventName) {
						case "keypress": if (0 === getEventCharCode(nativeEvent)) break a;
						case "keydown":
						case "keyup":
							SyntheticEventCtor = SyntheticKeyboardEvent;
							break;
						case "focusin":
							reactEventType = "focus";
							SyntheticEventCtor = SyntheticFocusEvent;
							break;
						case "focusout":
							reactEventType = "blur";
							SyntheticEventCtor = SyntheticFocusEvent;
							break;
						case "beforeblur":
						case "afterblur":
							SyntheticEventCtor = SyntheticFocusEvent;
							break;
						case "click": if (2 === nativeEvent.button) break a;
						case "auxclick":
						case "dblclick":
						case "mousedown":
						case "mousemove":
						case "mouseup":
						case "mouseout":
						case "mouseover":
						case "contextmenu":
							SyntheticEventCtor = SyntheticMouseEvent;
							break;
						case "drag":
						case "dragend":
						case "dragenter":
						case "dragexit":
						case "dragleave":
						case "dragover":
						case "dragstart":
						case "drop":
							SyntheticEventCtor = SyntheticDragEvent;
							break;
						case "touchcancel":
						case "touchend":
						case "touchmove":
						case "touchstart":
							SyntheticEventCtor = SyntheticTouchEvent;
							break;
						case ANIMATION_END:
						case ANIMATION_ITERATION:
						case ANIMATION_START:
							SyntheticEventCtor = SyntheticAnimationEvent;
							break;
						case TRANSITION_END:
							SyntheticEventCtor = SyntheticTransitionEvent;
							break;
						case "scroll":
						case "scrollend":
							SyntheticEventCtor = SyntheticUIEvent;
							break;
						case "wheel":
							SyntheticEventCtor = SyntheticWheelEvent;
							break;
						case "copy":
						case "cut":
						case "paste":
							SyntheticEventCtor = SyntheticClipboardEvent;
							break;
						case "gotpointercapture":
						case "lostpointercapture":
						case "pointercancel":
						case "pointerdown":
						case "pointermove":
						case "pointerout":
						case "pointerover":
						case "pointerup":
							SyntheticEventCtor = SyntheticPointerEvent;
							break;
						case "toggle":
						case "beforetoggle": SyntheticEventCtor = SyntheticToggleEvent;
					}
					var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
					inCapturePhase = [];
					for (var instance = targetInst, lastHostComponent; null !== instance;) {
						var _instance = instance;
						lastHostComponent = _instance.stateNode;
						_instance = _instance.tag;
						5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(createDispatchListener(instance, _instance, lastHostComponent)));
						if (accumulateTargetOnly) break;
						instance = instance.return;
					}
					0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
						event: reactName,
						listeners: inCapturePhase
					}));
				}
			}
			if (0 === (eventSystemFlags & 7)) {
				a: {
					reactName = "mouseover" === domEventName || "pointerover" === domEventName;
					SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
					if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey])) break a;
					if (SyntheticEventCtor || reactName) {
						reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
						if (SyntheticEventCtor) {
							if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase)) reactEventType = null;
						} else SyntheticEventCtor = null, reactEventType = targetInst;
						if (SyntheticEventCtor !== reactEventType) {
							inCapturePhase = SyntheticMouseEvent;
							_instance = "onMouseLeave";
							reactEventName = "onMouseEnter";
							instance = "mouse";
							if ("pointerout" === domEventName || "pointerover" === domEventName) inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
							accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
							lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
							reactName = new inCapturePhase(_instance, instance + "leave", SyntheticEventCtor, nativeEvent, nativeEventTarget);
							reactName.target = accumulateTargetOnly;
							reactName.relatedTarget = lastHostComponent;
							_instance = null;
							getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(reactEventName, instance + "enter", reactEventType, nativeEvent, nativeEventTarget), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
							accumulateTargetOnly = _instance;
							if (SyntheticEventCtor && reactEventType) b: {
								inCapturePhase = getParent;
								reactEventName = SyntheticEventCtor;
								instance = reactEventType;
								lastHostComponent = 0;
								for (_instance = reactEventName; _instance; _instance = inCapturePhase(_instance)) lastHostComponent++;
								_instance = 0;
								for (var tempB = instance; tempB; tempB = inCapturePhase(tempB)) _instance++;
								for (; 0 < lastHostComponent - _instance;) reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
								for (; 0 < _instance - lastHostComponent;) instance = inCapturePhase(instance), _instance--;
								for (; lastHostComponent--;) {
									if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
										inCapturePhase = reactEventName;
										break b;
									}
									reactEventName = inCapturePhase(reactEventName);
									instance = inCapturePhase(instance);
								}
								inCapturePhase = null;
							}
							else inCapturePhase = null;
							null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(dispatchQueue, reactName, SyntheticEventCtor, inCapturePhase, !1);
							null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(dispatchQueue, accumulateTargetOnly, reactEventType, inCapturePhase, !0);
						}
					}
				}
				a: {
					reactName = targetInst ? getNodeFromInstance(targetInst) : window;
					SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
					if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type) var getTargetInstFunc = getTargetInstForChangeEvent;
					else if (isTextInputElement(reactName)) if (isInputEventSupported) getTargetInstFunc = getTargetInstForInputOrChangeEvent;
					else {
						getTargetInstFunc = getTargetInstForInputEventPolyfill;
						var handleEventFunc = handleEventsForInputEventPolyfill;
					}
					else SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
					if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
						createAndAccumulateChangeEvent(dispatchQueue, getTargetInstFunc, nativeEvent, nativeEventTarget);
						break a;
					}
					handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
					"focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
				}
				handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
				switch (domEventName) {
					case "focusin":
						if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable) activeElement$2 = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
						break;
					case "focusout":
						lastSelection = activeElementInst = activeElement$2 = null;
						break;
					case "mousedown":
						mouseDown = !0;
						break;
					case "contextmenu":
					case "mouseup":
					case "dragend":
						mouseDown = !1;
						constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
						break;
					case "selectionchange": if (skipSelectionChangeEvent) break;
					case "keydown":
					case "keyup": constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
				}
				var fallbackData;
				if (canUseCompositionEvent) b: {
					switch (domEventName) {
						case "compositionstart":
							var eventType = "onCompositionStart";
							break b;
						case "compositionend":
							eventType = "onCompositionEnd";
							break b;
						case "compositionupdate":
							eventType = "onCompositionUpdate";
							break b;
					}
					eventType = void 0;
				}
				else isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
				eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = !0)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
					event: eventType,
					listeners: handleEventFunc
				}), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
				if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent)) eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
					event: handleEventFunc,
					listeners: eventType
				}), handleEventFunc.data = fallbackData);
				extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
			}
			processDispatchQueue(dispatchQueue, eventSystemFlags);
		});
	}
	function createDispatchListener(instance, listener, currentTarget) {
		return {
			instance,
			listener,
			currentTarget
		};
	}
	function accumulateTwoPhaseListeners(targetFiber, reactName) {
		for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber;) {
			var _instance2 = targetFiber, stateNode = _instance2.stateNode;
			_instance2 = _instance2.tag;
			5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(createDispatchListener(targetFiber, _instance2, stateNode)), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(createDispatchListener(targetFiber, _instance2, stateNode)));
			if (3 === targetFiber.tag) return listeners;
			targetFiber = targetFiber.return;
		}
		return [];
	}
	function getParent(inst) {
		if (null === inst) return null;
		do
			inst = inst.return;
		while (inst && 5 !== inst.tag && 27 !== inst.tag);
		return inst ? inst : null;
	}
	function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
		for (var registrationName = event._reactName, listeners = []; null !== target && target !== common;) {
			var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
			_instance3 = _instance3.tag;
			if (null !== alternate && alternate === common) break;
			5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(createDispatchListener(target, stateNode, alternate))) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(createDispatchListener(target, stateNode, alternate))));
			target = target.return;
		}
		0 !== listeners.length && dispatchQueue.push({
			event,
			listeners
		});
	}
	var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
	function normalizeMarkupForTextOrAttribute(markup) {
		return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
	}
	function checkForUnmatchedText(serverText, clientText) {
		clientText = normalizeMarkupForTextOrAttribute(clientText);
		return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;
	}
	function setProp(domElement, tag, key, value, props, prevValue) {
		switch (key) {
			case "children":
				"string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
				break;
			case "className":
				setValueForKnownAttribute(domElement, "class", value);
				break;
			case "tabIndex":
				setValueForKnownAttribute(domElement, "tabindex", value);
				break;
			case "dir":
			case "role":
			case "viewBox":
			case "width":
			case "height":
				setValueForKnownAttribute(domElement, key, value);
				break;
			case "style":
				setValueForStyles(domElement, value, prevValue);
				break;
			case "data": if ("object" !== tag) {
				setValueForKnownAttribute(domElement, "data", value);
				break;
			}
			case "src":
			case "href":
				if ("" === value && ("a" !== tag || "href" !== key)) {
					domElement.removeAttribute(key);
					break;
				}
				if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
					domElement.removeAttribute(key);
					break;
				}
				value = sanitizeURL("" + value);
				domElement.setAttribute(key, value);
				break;
			case "action":
			case "formAction":
				if ("function" === typeof value) {
					domElement.setAttribute(key, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
					break;
				} else "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(domElement, tag, "formEncType", props.formEncType, props, null), setProp(domElement, tag, "formMethod", props.formMethod, props, null), setProp(domElement, tag, "formTarget", props.formTarget, props, null)) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
				if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
					domElement.removeAttribute(key);
					break;
				}
				value = sanitizeURL("" + value);
				domElement.setAttribute(key, value);
				break;
			case "onClick":
				null != value && (domElement.onclick = noop$1$1);
				break;
			case "onScroll":
				null != value && listenToNonDelegatedEvent("scroll", domElement);
				break;
			case "onScrollEnd":
				null != value && listenToNonDelegatedEvent("scrollend", domElement);
				break;
			case "dangerouslySetInnerHTML":
				if (null != value) {
					if ("object" !== typeof value || !("__html" in value)) throw Error(formatProdErrorMessage(61));
					key = value.__html;
					if (null != key) {
						if (null != props.children) throw Error(formatProdErrorMessage(60));
						domElement.innerHTML = key;
					}
				}
				break;
			case "multiple":
				domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
				break;
			case "muted":
				domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
				break;
			case "suppressContentEditableWarning":
			case "suppressHydrationWarning":
			case "defaultValue":
			case "defaultChecked":
			case "innerHTML":
			case "ref": break;
			case "autoFocus": break;
			case "xlinkHref":
				if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
					domElement.removeAttribute("xlink:href");
					break;
				}
				key = sanitizeURL("" + value);
				domElement.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", key);
				break;
			case "contentEditable":
			case "spellCheck":
			case "draggable":
			case "value":
			case "autoReverse":
			case "externalResourcesRequired":
			case "focusable":
			case "preserveAlpha":
				null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
				break;
			case "inert":
			case "allowFullScreen":
			case "async":
			case "autoPlay":
			case "controls":
			case "default":
			case "defer":
			case "disabled":
			case "disablePictureInPicture":
			case "disableRemotePlayback":
			case "formNoValidate":
			case "hidden":
			case "loop":
			case "noModule":
			case "noValidate":
			case "open":
			case "playsInline":
			case "readOnly":
			case "required":
			case "reversed":
			case "scoped":
			case "seamless":
			case "itemScope":
				value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
				break;
			case "capture":
			case "download":
				!0 === value ? domElement.setAttribute(key, "") : !1 !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
				break;
			case "cols":
			case "rows":
			case "size":
			case "span":
				null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
				break;
			case "rowSpan":
			case "start":
				null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
				break;
			case "popover":
				listenToNonDelegatedEvent("beforetoggle", domElement);
				listenToNonDelegatedEvent("toggle", domElement);
				setValueForAttribute(domElement, "popover", value);
				break;
			case "xlinkActuate":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:actuate", value);
				break;
			case "xlinkArcrole":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:arcrole", value);
				break;
			case "xlinkRole":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:role", value);
				break;
			case "xlinkShow":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:show", value);
				break;
			case "xlinkTitle":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:title", value);
				break;
			case "xlinkType":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:type", value);
				break;
			case "xmlBase":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:base", value);
				break;
			case "xmlLang":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:lang", value);
				break;
			case "xmlSpace":
				setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:space", value);
				break;
			case "is":
				setValueForAttribute(domElement, "is", value);
				break;
			case "innerText":
			case "textContent": break;
			default: if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1]) key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
		}
	}
	function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
		switch (key) {
			case "style":
				setValueForStyles(domElement, value, prevValue);
				break;
			case "dangerouslySetInnerHTML":
				if (null != value) {
					if ("object" !== typeof value || !("__html" in value)) throw Error(formatProdErrorMessage(61));
					key = value.__html;
					if (null != key) {
						if (null != props.children) throw Error(formatProdErrorMessage(60));
						domElement.innerHTML = key;
					}
				}
				break;
			case "children":
				"string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
				break;
			case "onScroll":
				null != value && listenToNonDelegatedEvent("scroll", domElement);
				break;
			case "onScrollEnd":
				null != value && listenToNonDelegatedEvent("scrollend", domElement);
				break;
			case "onClick":
				null != value && (domElement.onclick = noop$1$1);
				break;
			case "suppressContentEditableWarning":
			case "suppressHydrationWarning":
			case "innerHTML":
			case "ref": break;
			case "innerText":
			case "textContent": break;
			default: if (!registrationNameDependencies.hasOwnProperty(key)) a: {
				if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
					"function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
					domElement.addEventListener(tag, value, props);
					break a;
				}
				key in domElement ? domElement[key] = value : !0 === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
			}
		}
	}
	function setInitialProperties(domElement, tag, props) {
		switch (tag) {
			case "div":
			case "span":
			case "svg":
			case "path":
			case "a":
			case "g":
			case "p":
			case "li": break;
			case "img":
				listenToNonDelegatedEvent("error", domElement);
				listenToNonDelegatedEvent("load", domElement);
				var hasSrc = !1, hasSrcSet = !1, propKey;
				for (propKey in props) if (props.hasOwnProperty(propKey)) {
					var propValue = props[propKey];
					if (null != propValue) switch (propKey) {
						case "src":
							hasSrc = !0;
							break;
						case "srcSet":
							hasSrcSet = !0;
							break;
						case "children":
						case "dangerouslySetInnerHTML": throw Error(formatProdErrorMessage(137, tag));
						default: setProp(domElement, tag, propKey, propValue, props, null);
					}
				}
				hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
				hasSrc && setProp(domElement, tag, "src", props.src, props, null);
				return;
			case "input":
				listenToNonDelegatedEvent("invalid", domElement);
				var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
				for (hasSrc in props) if (props.hasOwnProperty(hasSrc)) {
					var propValue$184 = props[hasSrc];
					if (null != propValue$184) switch (hasSrc) {
						case "name":
							hasSrcSet = propValue$184;
							break;
						case "type":
							propValue = propValue$184;
							break;
						case "checked":
							checked = propValue$184;
							break;
						case "defaultChecked":
							defaultChecked = propValue$184;
							break;
						case "value":
							propKey = propValue$184;
							break;
						case "defaultValue":
							defaultValue = propValue$184;
							break;
						case "children":
						case "dangerouslySetInnerHTML":
							if (null != propValue$184) throw Error(formatProdErrorMessage(137, tag));
							break;
						default: setProp(domElement, tag, hasSrc, propValue$184, props, null);
					}
				}
				initInput(domElement, propKey, defaultValue, checked, defaultChecked, propValue, hasSrcSet, !1);
				return;
			case "select":
				listenToNonDelegatedEvent("invalid", domElement);
				hasSrc = propValue = propKey = null;
				for (hasSrcSet in props) if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue)) switch (hasSrcSet) {
					case "value":
						propKey = defaultValue;
						break;
					case "defaultValue":
						propValue = defaultValue;
						break;
					case "multiple": hasSrc = defaultValue;
					default: setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
				}
				tag = propKey;
				props = propValue;
				domElement.multiple = !!hasSrc;
				null != tag ? updateOptions(domElement, !!hasSrc, tag, !1) : null != props && updateOptions(domElement, !!hasSrc, props, !0);
				return;
			case "textarea":
				listenToNonDelegatedEvent("invalid", domElement);
				propKey = hasSrcSet = hasSrc = null;
				for (propValue in props) if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue)) switch (propValue) {
					case "value":
						hasSrc = defaultValue;
						break;
					case "defaultValue":
						hasSrcSet = defaultValue;
						break;
					case "children":
						propKey = defaultValue;
						break;
					case "dangerouslySetInnerHTML":
						if (null != defaultValue) throw Error(formatProdErrorMessage(91));
						break;
					default: setProp(domElement, tag, propValue, defaultValue, props, null);
				}
				initTextarea(domElement, hasSrc, hasSrcSet, propKey);
				return;
			case "option":
				for (checked in props) if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc)) switch (checked) {
					case "selected":
						domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
						break;
					default: setProp(domElement, tag, checked, hasSrc, props, null);
				}
				return;
			case "dialog":
				listenToNonDelegatedEvent("beforetoggle", domElement);
				listenToNonDelegatedEvent("toggle", domElement);
				listenToNonDelegatedEvent("cancel", domElement);
				listenToNonDelegatedEvent("close", domElement);
				break;
			case "iframe":
			case "object":
				listenToNonDelegatedEvent("load", domElement);
				break;
			case "video":
			case "audio":
				for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++) listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
				break;
			case "image":
				listenToNonDelegatedEvent("error", domElement);
				listenToNonDelegatedEvent("load", domElement);
				break;
			case "details":
				listenToNonDelegatedEvent("toggle", domElement);
				break;
			case "embed":
			case "source":
			case "link": listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
			case "area":
			case "base":
			case "br":
			case "col":
			case "hr":
			case "keygen":
			case "meta":
			case "param":
			case "track":
			case "wbr":
			case "menuitem":
				for (defaultChecked in props) if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc)) switch (defaultChecked) {
					case "children":
					case "dangerouslySetInnerHTML": throw Error(formatProdErrorMessage(137, tag));
					default: setProp(domElement, tag, defaultChecked, hasSrc, props, null);
				}
				return;
			default: if (isCustomElement(tag)) {
				for (propValue$184 in props) props.hasOwnProperty(propValue$184) && (hasSrc = props[propValue$184], void 0 !== hasSrc && setPropOnCustomElement(domElement, tag, propValue$184, hasSrc, props, void 0));
				return;
			}
		}
		for (defaultValue in props) props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
	}
	function updateProperties(domElement, tag, lastProps, nextProps) {
		switch (tag) {
			case "div":
			case "span":
			case "svg":
			case "path":
			case "a":
			case "g":
			case "p":
			case "li": break;
			case "input":
				var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
				for (propKey in lastProps) {
					var lastProp = lastProps[propKey];
					if (lastProps.hasOwnProperty(propKey) && null != lastProp) switch (propKey) {
						case "checked": break;
						case "value": break;
						case "defaultValue": lastDefaultValue = lastProp;
						default: nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
					}
				}
				for (var propKey$201 in nextProps) {
					var propKey = nextProps[propKey$201];
					lastProp = lastProps[propKey$201];
					if (nextProps.hasOwnProperty(propKey$201) && (null != propKey || null != lastProp)) switch (propKey$201) {
						case "type":
							type = propKey;
							break;
						case "name":
							name = propKey;
							break;
						case "checked":
							checked = propKey;
							break;
						case "defaultChecked":
							defaultChecked = propKey;
							break;
						case "value":
							value = propKey;
							break;
						case "defaultValue":
							defaultValue = propKey;
							break;
						case "children":
						case "dangerouslySetInnerHTML":
							if (null != propKey) throw Error(formatProdErrorMessage(137, tag));
							break;
						default: propKey !== lastProp && setProp(domElement, tag, propKey$201, propKey, nextProps, lastProp);
					}
				}
				updateInput(domElement, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name);
				return;
			case "select":
				propKey = value = defaultValue = propKey$201 = null;
				for (type in lastProps) if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue) switch (type) {
					case "value": break;
					case "multiple": propKey = lastDefaultValue;
					default: nextProps.hasOwnProperty(type) || setProp(domElement, tag, type, null, nextProps, lastDefaultValue);
				}
				for (name in nextProps) if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue)) switch (name) {
					case "value":
						propKey$201 = type;
						break;
					case "defaultValue":
						defaultValue = type;
						break;
					case "multiple": value = type;
					default: type !== lastDefaultValue && setProp(domElement, tag, name, type, nextProps, lastDefaultValue);
				}
				tag = defaultValue;
				lastProps = value;
				nextProps = propKey;
				null != propKey$201 ? updateOptions(domElement, !!lastProps, propKey$201, !1) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, !0) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", !1));
				return;
			case "textarea":
				propKey = propKey$201 = null;
				for (defaultValue in lastProps) if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue)) switch (defaultValue) {
					case "value": break;
					case "children": break;
					default: setProp(domElement, tag, defaultValue, null, nextProps, name);
				}
				for (value in nextProps) if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type)) switch (value) {
					case "value":
						propKey$201 = name;
						break;
					case "defaultValue":
						propKey = name;
						break;
					case "children": break;
					case "dangerouslySetInnerHTML":
						if (null != name) throw Error(formatProdErrorMessage(91));
						break;
					default: name !== type && setProp(domElement, tag, value, name, nextProps, type);
				}
				updateTextarea(domElement, propKey$201, propKey);
				return;
			case "option":
				for (var propKey$217 in lastProps) if (propKey$201 = lastProps[propKey$217], lastProps.hasOwnProperty(propKey$217) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$217)) switch (propKey$217) {
					case "selected":
						domElement.selected = !1;
						break;
					default: setProp(domElement, tag, propKey$217, null, nextProps, propKey$201);
				}
				for (lastDefaultValue in nextProps) if (propKey$201 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$201 !== propKey && (null != propKey$201 || null != propKey)) switch (lastDefaultValue) {
					case "selected":
						domElement.selected = propKey$201 && "function" !== typeof propKey$201 && "symbol" !== typeof propKey$201;
						break;
					default: setProp(domElement, tag, lastDefaultValue, propKey$201, nextProps, propKey);
				}
				return;
			case "img":
			case "link":
			case "area":
			case "base":
			case "br":
			case "col":
			case "embed":
			case "hr":
			case "keygen":
			case "meta":
			case "param":
			case "source":
			case "track":
			case "wbr":
			case "menuitem":
				for (var propKey$222 in lastProps) propKey$201 = lastProps[propKey$222], lastProps.hasOwnProperty(propKey$222) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$222) && setProp(domElement, tag, propKey$222, null, nextProps, propKey$201);
				for (checked in nextProps) if (propKey$201 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$201 !== propKey && (null != propKey$201 || null != propKey)) switch (checked) {
					case "children":
					case "dangerouslySetInnerHTML":
						if (null != propKey$201) throw Error(formatProdErrorMessage(137, tag));
						break;
					default: setProp(domElement, tag, checked, propKey$201, nextProps, propKey);
				}
				return;
			default: if (isCustomElement(tag)) {
				for (var propKey$227 in lastProps) propKey$201 = lastProps[propKey$227], lastProps.hasOwnProperty(propKey$227) && void 0 !== propKey$201 && !nextProps.hasOwnProperty(propKey$227) && setPropOnCustomElement(domElement, tag, propKey$227, void 0, nextProps, propKey$201);
				for (defaultChecked in nextProps) propKey$201 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$201 === propKey || void 0 === propKey$201 && void 0 === propKey || setPropOnCustomElement(domElement, tag, defaultChecked, propKey$201, nextProps, propKey);
				return;
			}
		}
		for (var propKey$232 in lastProps) propKey$201 = lastProps[propKey$232], lastProps.hasOwnProperty(propKey$232) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$232) && setProp(domElement, tag, propKey$232, null, nextProps, propKey$201);
		for (lastProp in nextProps) propKey$201 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$201 === propKey || null == propKey$201 && null == propKey || setProp(domElement, tag, lastProp, propKey$201, nextProps, propKey);
	}
	function isLikelyStaticResource(initiatorType) {
		switch (initiatorType) {
			case "css":
			case "script":
			case "font":
			case "img":
			case "image":
			case "input":
			case "link": return !0;
			default: return !1;
		}
	}
	function estimateBandwidth() {
		if ("function" === typeof performance.getEntriesByType) {
			for (var count$1 = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i = 0; i < resourceEntries.length; i++) {
				var entry = resourceEntries[i], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
				if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
					initiatorType = 0;
					duration = entry.responseEnd;
					for (i += 1; i < resourceEntries.length; i++) {
						var overlapEntry = resourceEntries[i], overlapStartTime = overlapEntry.startTime;
						if (overlapStartTime > duration) break;
						var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
						overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
					}
					--i;
					bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
					count$1++;
					if (10 < count$1) break;
				}
			}
			if (0 < count$1) return bits / count$1 / 1e6;
		}
		return navigator.connection && (count$1 = navigator.connection.downlink, "number" === typeof count$1) ? count$1 : 5;
	}
	var eventsEnabled = null, selectionInformation = null;
	function getOwnerDocumentFromRootContainer(rootContainerElement) {
		return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
	}
	function getOwnHostContext(namespaceURI) {
		switch (namespaceURI) {
			case "http://www.w3.org/2000/svg": return 1;
			case "http://www.w3.org/1998/Math/MathML": return 2;
			default: return 0;
		}
	}
	function getChildHostContextProd(parentNamespace, type) {
		if (0 === parentNamespace) switch (type) {
			case "svg": return 1;
			case "math": return 2;
			default: return 0;
		}
		return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
	}
	function shouldSetTextContent(type, props) {
		return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
	}
	var currentPopstateTransitionEvent = null;
	function shouldAttemptEagerTransition() {
		var event = window.event;
		if (event && "popstate" === event.type) {
			if (event === currentPopstateTransitionEvent) return !1;
			currentPopstateTransitionEvent = event;
			return !0;
		}
		currentPopstateTransitionEvent = null;
		return !1;
	}
	var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
		return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
	} : scheduleTimeout;
	function handleErrorInNextTick(error) {
		setTimeout(function() {
			throw error;
		});
	}
	function isSingletonScope(type) {
		return "head" === type;
	}
	function clearHydrationBoundary(parentInstance, hydrationInstance) {
		var node = hydrationInstance, depth = 0;
		do {
			var nextNode = node.nextSibling;
			parentInstance.removeChild(node);
			if (nextNode && 8 === nextNode.nodeType) if (node = nextNode.data, "/$" === node || "/&" === node) {
				if (0 === depth) {
					parentInstance.removeChild(nextNode);
					retryIfBlockedOn(hydrationInstance);
					return;
				}
				depth--;
			} else if ("$" === node || "$?" === node || "$~" === node || "$!" === node || "&" === node) depth++;
			else if ("html" === node) releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
			else if ("head" === node) {
				node = parentInstance.ownerDocument.head;
				releaseSingletonInstance(node);
				for (var node$jscomp$0 = node.firstChild; node$jscomp$0;) {
					var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
					node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
					node$jscomp$0 = nextNode$jscomp$0;
				}
			} else "body" === node && releaseSingletonInstance(parentInstance.ownerDocument.body);
			node = nextNode;
		} while (node);
		retryIfBlockedOn(hydrationInstance);
	}
	function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
		var node = suspenseInstance;
		suspenseInstance = 0;
		do {
			var nextNode = node.nextSibling;
			1 === node.nodeType ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
			if (nextNode && 8 === nextNode.nodeType) if (node = nextNode.data, "/$" === node) if (0 === suspenseInstance) break;
			else suspenseInstance--;
			else "$" !== node && "$?" !== node && "$~" !== node && "$!" !== node || suspenseInstance++;
			node = nextNode;
		} while (node);
	}
	function clearContainerSparingly(container) {
		var nextNode = container.firstChild;
		nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
		for (; nextNode;) {
			var node = nextNode;
			nextNode = nextNode.nextSibling;
			switch (node.nodeName) {
				case "HTML":
				case "HEAD":
				case "BODY":
					clearContainerSparingly(node);
					detachDeletedInstance(node);
					continue;
				case "SCRIPT":
				case "STYLE": continue;
				case "LINK": if ("stylesheet" === node.rel.toLowerCase()) continue;
			}
			container.removeChild(node);
		}
	}
	function canHydrateInstance(instance, type, props, inRootOrSingleton) {
		for (; 1 === instance.nodeType;) {
			var anyProps = props;
			if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
				if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type)) break;
			} else if (!inRootOrSingleton) if ("input" === type && "hidden" === instance.type) {
				var name = null == anyProps.name ? null : "" + anyProps.name;
				if ("hidden" === anyProps.type && instance.getAttribute("name") === name) return instance;
			} else return instance;
			else if (!instance[internalHoistableMarker]) switch (type) {
				case "meta":
					if (!instance.hasAttribute("itemprop")) break;
					return instance;
				case "link":
					name = instance.getAttribute("rel");
					if ("stylesheet" === name && instance.hasAttribute("data-precedence")) break;
					else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title)) break;
					return instance;
				case "style":
					if (instance.hasAttribute("data-precedence")) break;
					return instance;
				case "script":
					name = instance.getAttribute("src");
					if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop")) break;
					return instance;
				default: return instance;
			}
			instance = getNextHydratable(instance.nextSibling);
			if (null === instance) break;
		}
		return null;
	}
	function canHydrateTextInstance(instance, text, inRootOrSingleton) {
		if ("" === text) return null;
		for (; 3 !== instance.nodeType;) {
			if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton) return null;
			instance = getNextHydratable(instance.nextSibling);
			if (null === instance) return null;
		}
		return instance;
	}
	function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
		for (; 8 !== instance.nodeType;) {
			if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton) return null;
			instance = getNextHydratable(instance.nextSibling);
			if (null === instance) return null;
		}
		return instance;
	}
	function isSuspenseInstancePending(instance) {
		return "$?" === instance.data || "$~" === instance.data;
	}
	function isSuspenseInstanceFallback(instance) {
		return "$!" === instance.data || "$?" === instance.data && "loading" !== instance.ownerDocument.readyState;
	}
	function registerSuspenseInstanceRetry(instance, callback) {
		var ownerDocument = instance.ownerDocument;
		if ("$~" === instance.data) instance._reactRetry = callback;
		else if ("$?" !== instance.data || "loading" !== ownerDocument.readyState) callback();
		else {
			var listener = function() {
				callback();
				ownerDocument.removeEventListener("DOMContentLoaded", listener);
			};
			ownerDocument.addEventListener("DOMContentLoaded", listener);
			instance._reactRetry = listener;
		}
	}
	function getNextHydratable(node) {
		for (; null != node; node = node.nextSibling) {
			var nodeType = node.nodeType;
			if (1 === nodeType || 3 === nodeType) break;
			if (8 === nodeType) {
				nodeType = node.data;
				if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "$~" === nodeType || "&" === nodeType || "F!" === nodeType || "F" === nodeType) break;
				if ("/$" === nodeType || "/&" === nodeType) return null;
			}
		}
		return node;
	}
	var previousHydratableOnEnteringScopedSingleton = null;
	function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
		hydrationInstance = hydrationInstance.nextSibling;
		for (var depth = 0; hydrationInstance;) {
			if (8 === hydrationInstance.nodeType) {
				var data = hydrationInstance.data;
				if ("/$" === data || "/&" === data) {
					if (0 === depth) return getNextHydratable(hydrationInstance.nextSibling);
					depth--;
				} else "$" !== data && "$!" !== data && "$?" !== data && "$~" !== data && "&" !== data || depth++;
			}
			hydrationInstance = hydrationInstance.nextSibling;
		}
		return null;
	}
	function getParentHydrationBoundary(targetInstance) {
		targetInstance = targetInstance.previousSibling;
		for (var depth = 0; targetInstance;) {
			if (8 === targetInstance.nodeType) {
				var data = targetInstance.data;
				if ("$" === data || "$!" === data || "$?" === data || "$~" === data || "&" === data) {
					if (0 === depth) return targetInstance;
					depth--;
				} else "/$" !== data && "/&" !== data || depth++;
			}
			targetInstance = targetInstance.previousSibling;
		}
		return null;
	}
	function resolveSingletonInstance(type, props, rootContainerInstance) {
		props = getOwnerDocumentFromRootContainer(rootContainerInstance);
		switch (type) {
			case "html":
				type = props.documentElement;
				if (!type) throw Error(formatProdErrorMessage(452));
				return type;
			case "head":
				type = props.head;
				if (!type) throw Error(formatProdErrorMessage(453));
				return type;
			case "body":
				type = props.body;
				if (!type) throw Error(formatProdErrorMessage(454));
				return type;
			default: throw Error(formatProdErrorMessage(451));
		}
	}
	function releaseSingletonInstance(instance) {
		for (var attributes = instance.attributes; attributes.length;) instance.removeAttributeNode(attributes[0]);
		detachDeletedInstance(instance);
	}
	var preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set();
	function getHoistableRoot(container) {
		return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
	}
	var previousDispatcher = ReactDOMSharedInternals.d;
	ReactDOMSharedInternals.d = {
		f: flushSyncWork,
		r: requestFormReset,
		D: prefetchDNS,
		C: preconnect,
		L: preload,
		m: preloadModule,
		X: preinitScript,
		S: preinitStyle,
		M: preinitModuleScript
	};
	function flushSyncWork() {
		var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
		return previousWasRendering || wasRendering;
	}
	function requestFormReset(form) {
		var formInst = getInstanceFromNode(form);
		null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
	}
	var globalDocument = "undefined" === typeof document ? null : document;
	function preconnectAs(rel, href, crossOrigin) {
		var ownerDocument = globalDocument;
		if (ownerDocument && "string" === typeof href && href) {
			var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
			limitedEscapedHref = "link[rel=\"" + rel + "\"][href=\"" + limitedEscapedHref + "\"]";
			"string" === typeof crossOrigin && (limitedEscapedHref += "[crossorigin=\"" + crossOrigin + "\"]");
			preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = {
				rel,
				crossOrigin,
				href
			}, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
		}
	}
	function prefetchDNS(href) {
		previousDispatcher.D(href);
		preconnectAs("dns-prefetch", href, null);
	}
	function preconnect(href, crossOrigin) {
		previousDispatcher.C(href, crossOrigin);
		preconnectAs("preconnect", href, crossOrigin);
	}
	function preload(href, as, options$1) {
		previousDispatcher.L(href, as, options$1);
		var ownerDocument = globalDocument;
		if (ownerDocument && href && as) {
			var preloadSelector = "link[rel=\"preload\"][as=\"" + escapeSelectorAttributeValueInsideDoubleQuotes(as) + "\"]";
			"image" === as ? options$1 && options$1.imageSrcSet ? (preloadSelector += "[imagesrcset=\"" + escapeSelectorAttributeValueInsideDoubleQuotes(options$1.imageSrcSet) + "\"]", "string" === typeof options$1.imageSizes && (preloadSelector += "[imagesizes=\"" + escapeSelectorAttributeValueInsideDoubleQuotes(options$1.imageSizes) + "\"]")) : preloadSelector += "[href=\"" + escapeSelectorAttributeValueInsideDoubleQuotes(href) + "\"]" : preloadSelector += "[href=\"" + escapeSelectorAttributeValueInsideDoubleQuotes(href) + "\"]";
			var key = preloadSelector;
			switch (as) {
				case "style":
					key = getStyleKey(href);
					break;
				case "script": key = getScriptKey(href);
			}
			preloadPropsMap.has(key) || (href = assign({
				rel: "preload",
				href: "image" === as && options$1 && options$1.imageSrcSet ? void 0 : href,
				as
			}, options$1), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
		}
	}
	function preloadModule(href, options$1) {
		previousDispatcher.m(href, options$1);
		var ownerDocument = globalDocument;
		if (ownerDocument && href) {
			var as = options$1 && "string" === typeof options$1.as ? options$1.as : "script", preloadSelector = "link[rel=\"modulepreload\"][as=\"" + escapeSelectorAttributeValueInsideDoubleQuotes(as) + "\"][href=\"" + escapeSelectorAttributeValueInsideDoubleQuotes(href) + "\"]", key = preloadSelector;
			switch (as) {
				case "audioworklet":
				case "paintworklet":
				case "serviceworker":
				case "sharedworker":
				case "worker":
				case "script": key = getScriptKey(href);
			}
			if (!preloadPropsMap.has(key) && (href = assign({
				rel: "modulepreload",
				href
			}, options$1), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
				switch (as) {
					case "audioworklet":
					case "paintworklet":
					case "serviceworker":
					case "sharedworker":
					case "worker":
					case "script": if (ownerDocument.querySelector(getScriptSelectorFromKey(key))) return;
				}
				as = ownerDocument.createElement("link");
				setInitialProperties(as, "link", href);
				markNodeAsHoistable(as);
				ownerDocument.head.appendChild(as);
			}
		}
	}
	function preinitStyle(href, precedence, options$1) {
		previousDispatcher.S(href, precedence, options$1);
		var ownerDocument = globalDocument;
		if (ownerDocument && href) {
			var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
			precedence = precedence || "default";
			var resource = styles.get(key);
			if (!resource) {
				var state = {
					loading: 0,
					preload: null
				};
				if (resource = ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) state.loading = 5;
				else {
					href = assign({
						rel: "stylesheet",
						href,
						"data-precedence": precedence
					}, options$1);
					(options$1 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options$1);
					var link = resource = ownerDocument.createElement("link");
					markNodeAsHoistable(link);
					setInitialProperties(link, "link", href);
					link._p = new Promise(function(resolve, reject) {
						link.onload = resolve;
						link.onerror = reject;
					});
					link.addEventListener("load", function() {
						state.loading |= 1;
					});
					link.addEventListener("error", function() {
						state.loading |= 2;
					});
					state.loading |= 4;
					insertStylesheet(resource, precedence, ownerDocument);
				}
				resource = {
					type: "stylesheet",
					instance: resource,
					count: 1,
					state
				};
				styles.set(key, resource);
			}
		}
	}
	function preinitScript(src, options$1) {
		previousDispatcher.X(src, options$1);
		var ownerDocument = globalDocument;
		if (ownerDocument && src) {
			var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
			resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({
				src,
				async: !0
			}, options$1), (options$1 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options$1), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
				type: "script",
				instance: resource,
				count: 1,
				state: null
			}, scripts.set(key, resource));
		}
	}
	function preinitModuleScript(src, options$1) {
		previousDispatcher.M(src, options$1);
		var ownerDocument = globalDocument;
		if (ownerDocument && src) {
			var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
			resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({
				src,
				async: !0,
				type: "module"
			}, options$1), (options$1 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options$1), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
				type: "script",
				instance: resource,
				count: 1,
				state: null
			}, scripts.set(key, resource));
		}
	}
	function getResource(type, currentProps, pendingProps, currentResource) {
		var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
		if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
		switch (type) {
			case "meta":
			case "title": return null;
			case "style": return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
				type: "style",
				instance: null,
				count: 0,
				state: null
			}, pendingProps.set(currentProps, currentResource)), currentResource) : {
				type: "void",
				instance: null,
				count: 0,
				state: null
			};
			case "link":
				if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
					type = getStyleKey(pendingProps.href);
					var styles$243 = getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles, resource$244 = styles$243.get(type);
					resource$244 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$244 = {
						type: "stylesheet",
						instance: null,
						count: 0,
						state: {
							loading: 0,
							preload: null
						}
					}, styles$243.set(type, resource$244), (styles$243 = JSCompiler_inline_result.querySelector(getStylesheetSelectorFromKey(type))) && !styles$243._p && (resource$244.instance = styles$243, resource$244.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
						rel: "preload",
						as: "style",
						href: pendingProps.href,
						crossOrigin: pendingProps.crossOrigin,
						integrity: pendingProps.integrity,
						media: pendingProps.media,
						hrefLang: pendingProps.hrefLang,
						referrerPolicy: pendingProps.referrerPolicy
					}, preloadPropsMap.set(type, pendingProps), styles$243 || preloadStylesheet(JSCompiler_inline_result, type, pendingProps, resource$244.state)));
					if (currentProps && null === currentResource) throw Error(formatProdErrorMessage(528, ""));
					return resource$244;
				}
				if (currentProps && null !== currentResource) throw Error(formatProdErrorMessage(529, ""));
				return null;
			case "script": return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(JSCompiler_inline_result).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
				type: "script",
				instance: null,
				count: 0,
				state: null
			}, pendingProps.set(currentProps, currentResource)), currentResource) : {
				type: "void",
				instance: null,
				count: 0,
				state: null
			};
			default: throw Error(formatProdErrorMessage(444, type));
		}
	}
	function getStyleKey(href) {
		return "href=\"" + escapeSelectorAttributeValueInsideDoubleQuotes(href) + "\"";
	}
	function getStylesheetSelectorFromKey(key) {
		return "link[rel=\"stylesheet\"][" + key + "]";
	}
	function stylesheetPropsFromRawProps(rawProps) {
		return assign({}, rawProps, {
			"data-precedence": rawProps.precedence,
			precedence: null
		});
	}
	function preloadStylesheet(ownerDocument, key, preloadProps, state) {
		ownerDocument.querySelector("link[rel=\"preload\"][as=\"style\"][" + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
			return state.loading |= 1;
		}), key.addEventListener("error", function() {
			return state.loading |= 2;
		}), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
	}
	function getScriptKey(src) {
		return "[src=\"" + escapeSelectorAttributeValueInsideDoubleQuotes(src) + "\"]";
	}
	function getScriptSelectorFromKey(key) {
		return "script[async]" + key;
	}
	function acquireResource(hoistableRoot, resource, props) {
		resource.count++;
		if (null === resource.instance) switch (resource.type) {
			case "style":
				var instance = hoistableRoot.querySelector("style[data-href~=\"" + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + "\"]");
				if (instance) return resource.instance = instance, markNodeAsHoistable(instance), instance;
				var styleProps = assign({}, props, {
					"data-href": props.href,
					"data-precedence": props.precedence,
					href: null,
					precedence: null
				});
				instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
				markNodeAsHoistable(instance);
				setInitialProperties(instance, "style", styleProps);
				insertStylesheet(instance, props.precedence, hoistableRoot);
				return resource.instance = instance;
			case "stylesheet":
				styleProps = getStyleKey(props.href);
				var instance$249 = hoistableRoot.querySelector(getStylesheetSelectorFromKey(styleProps));
				if (instance$249) return resource.state.loading |= 4, resource.instance = instance$249, markNodeAsHoistable(instance$249), instance$249;
				instance = stylesheetPropsFromRawProps(props);
				(styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
				instance$249 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
				markNodeAsHoistable(instance$249);
				var linkInstance = instance$249;
				linkInstance._p = new Promise(function(resolve, reject) {
					linkInstance.onload = resolve;
					linkInstance.onerror = reject;
				});
				setInitialProperties(instance$249, "link", instance);
				resource.state.loading |= 4;
				insertStylesheet(instance$249, props.precedence, hoistableRoot);
				return resource.instance = instance$249;
			case "script":
				instance$249 = getScriptKey(props.src);
				if (styleProps = hoistableRoot.querySelector(getScriptSelectorFromKey(instance$249))) return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
				instance = props;
				if (styleProps = preloadPropsMap.get(instance$249)) instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
				hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
				styleProps = hoistableRoot.createElement("script");
				markNodeAsHoistable(styleProps);
				setInitialProperties(styleProps, "link", instance);
				hoistableRoot.head.appendChild(styleProps);
				return resource.instance = styleProps;
			case "void": return null;
			default: throw Error(formatProdErrorMessage(443, resource.type));
		}
		else "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
		return resource.instance;
	}
	function insertStylesheet(instance, precedence, root$1) {
		for (var nodes = root$1.querySelectorAll("link[rel=\"stylesheet\"][data-precedence],style[data-precedence]"), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
			var node = nodes[i];
			if (node.dataset.precedence === precedence) prior = node;
			else if (prior !== last) break;
		}
		prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root$1.nodeType ? root$1.head : root$1, precedence.insertBefore(instance, precedence.firstChild));
	}
	function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
		stylesheetProps.crossOrigin ??= preloadProps.crossOrigin;
		stylesheetProps.referrerPolicy ??= preloadProps.referrerPolicy;
		stylesheetProps.title ??= preloadProps.title;
	}
	function adoptPreloadPropsForScript(scriptProps, preloadProps) {
		scriptProps.crossOrigin ??= preloadProps.crossOrigin;
		scriptProps.referrerPolicy ??= preloadProps.referrerPolicy;
		scriptProps.integrity ??= preloadProps.integrity;
	}
	var tagCaches = null;
	function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
		if (null === tagCaches) {
			var cache = /* @__PURE__ */ new Map();
			var caches = tagCaches = /* @__PURE__ */ new Map();
			caches.set(ownerDocument, cache);
		} else caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
		if (cache.has(type)) return cache;
		cache.set(type, null);
		ownerDocument = ownerDocument.getElementsByTagName(type);
		for (caches = 0; caches < ownerDocument.length; caches++) {
			var node = ownerDocument[caches];
			if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
				var nodeKey = node.getAttribute(keyAttribute) || "";
				nodeKey = type + nodeKey;
				var existing = cache.get(nodeKey);
				existing ? existing.push(node) : cache.set(nodeKey, [node]);
			}
		}
		return cache;
	}
	function mountHoistable(hoistableRoot, type, instance) {
		hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
		hoistableRoot.head.insertBefore(instance, "title" === type ? hoistableRoot.querySelector("head > title") : null);
	}
	function isHostHoistableType(type, props, hostContext) {
		if (1 === hostContext || null != props.itemProp) return !1;
		switch (type) {
			case "meta":
			case "title": return !0;
			case "style":
				if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) break;
				return !0;
			case "link":
				if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) break;
				switch (props.rel) {
					case "stylesheet": return type = props.disabled, "string" === typeof props.precedence && null == type;
					default: return !0;
				}
			case "script": if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src) return !0;
		}
		return !1;
	}
	function preloadResource(resource) {
		return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? !1 : !0;
	}
	function suspendResource(state, hoistableRoot, resource, props) {
		if ("stylesheet" === resource.type && ("string" !== typeof props.media || !1 !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
			if (null === resource.instance) {
				var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(key));
				if (instance) {
					hoistableRoot = instance._p;
					null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
					resource.state.loading |= 4;
					resource.instance = instance;
					markNodeAsHoistable(instance);
					return;
				}
				instance = hoistableRoot.ownerDocument || hoistableRoot;
				props = stylesheetPropsFromRawProps(props);
				(key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
				instance = instance.createElement("link");
				markNodeAsHoistable(instance);
				var linkInstance = instance;
				linkInstance._p = new Promise(function(resolve, reject) {
					linkInstance.onload = resolve;
					linkInstance.onerror = reject;
				});
				setInitialProperties(instance, "link", props);
				resource.instance = instance;
			}
			null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
			state.stylesheets.set(resource, hoistableRoot);
			(hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
		}
	}
	var estimatedBytesWithinLimit = 0;
	function waitForCommitToBeReady(state, timeoutOffset) {
		state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
		return 0 < state.count || 0 < state.imgCount ? function(commit) {
			var stylesheetTimer = setTimeout(function() {
				state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
				if (state.unsuspend) {
					var unsuspend = state.unsuspend;
					state.unsuspend = null;
					unsuspend();
				}
			}, 6e4 + timeoutOffset);
			0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
			var imgTimer = setTimeout(function() {
				state.waitingForImages = !1;
				if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
					var unsuspend = state.unsuspend;
					state.unsuspend = null;
					unsuspend();
				}
			}, (state.imgBytes > estimatedBytesWithinLimit ? 50 : 800) + timeoutOffset);
			state.unsuspend = commit;
			return function() {
				state.unsuspend = null;
				clearTimeout(stylesheetTimer);
				clearTimeout(imgTimer);
			};
		} : null;
	}
	function onUnsuspend() {
		this.count--;
		if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
			if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
			else if (this.unsuspend) {
				var unsuspend = this.unsuspend;
				this.unsuspend = null;
				unsuspend();
			}
		}
	}
	var precedencesByRoot = null;
	function insertSuspendedStylesheets(state, resources) {
		state.stylesheets = null;
		null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
	}
	function insertStylesheetIntoRoot(root$1, resource) {
		if (!(resource.state.loading & 4)) {
			var precedences = precedencesByRoot.get(root$1);
			if (precedences) var last = precedences.get(null);
			else {
				precedences = /* @__PURE__ */ new Map();
				precedencesByRoot.set(root$1, precedences);
				for (var nodes = root$1.querySelectorAll("link[data-precedence],style[data-precedence]"), i = 0; i < nodes.length; i++) {
					var node = nodes[i];
					if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media")) precedences.set(node.dataset.precedence, node), last = node;
				}
				last && precedences.set(null, last);
			}
			nodes = resource.instance;
			node = nodes.getAttribute("data-precedence");
			i = precedences.get(node) || last;
			i === last && precedences.set(null, nodes);
			precedences.set(node, nodes);
			this.count++;
			last = onUnsuspend.bind(this);
			nodes.addEventListener("load", last);
			nodes.addEventListener("error", last);
			i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root$1 = 9 === root$1.nodeType ? root$1.head : root$1, root$1.insertBefore(nodes, root$1.firstChild));
			resource.state.loading |= 4;
		}
	}
	var HostTransitionContext = {
		$$typeof: REACT_CONTEXT_TYPE,
		Provider: null,
		Consumer: null,
		_currentValue: sharedNotPendingObject,
		_currentValue2: sharedNotPendingObject,
		_threadCount: 0
	};
	function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
		this.tag = 1;
		this.containerInfo = containerInfo;
		this.pingCache = this.current = this.pendingChildren = null;
		this.timeoutHandle = -1;
		this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
		this.callbackPriority = 0;
		this.expirationTimes = createLaneMap(-1);
		this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
		this.entanglements = createLaneMap(0);
		this.hiddenUpdates = createLaneMap(null);
		this.identifierPrefix = identifierPrefix;
		this.onUncaughtError = onUncaughtError;
		this.onCaughtError = onCaughtError;
		this.onRecoverableError = onRecoverableError;
		this.pooledCache = null;
		this.pooledCacheLanes = 0;
		this.formState = formState;
		this.incompleteTransitions = /* @__PURE__ */ new Map();
	}
	function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
		containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState);
		tag = 1;
		!0 === isStrictMode && (tag |= 24);
		isStrictMode = createFiberImplClass(3, null, null, tag);
		containerInfo.current = isStrictMode;
		isStrictMode.stateNode = containerInfo;
		tag = createCache();
		tag.refCount++;
		containerInfo.pooledCache = tag;
		tag.refCount++;
		isStrictMode.memoizedState = {
			element: initialChildren,
			isDehydrated: hydrate,
			cache: tag
		};
		initializeUpdateQueue(isStrictMode);
		return containerInfo;
	}
	function getContextForSubtree(parentComponent) {
		if (!parentComponent) return emptyContextObject;
		parentComponent = emptyContextObject;
		return parentComponent;
	}
	function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
		parentComponent = getContextForSubtree(parentComponent);
		null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
		container = createUpdate(lane);
		container.payload = { element };
		callback = void 0 === callback ? null : callback;
		null !== callback && (container.callback = callback);
		element = enqueueUpdate(rootFiber, container, lane);
		null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
	}
	function markRetryLaneImpl(fiber, retryLane) {
		fiber = fiber.memoizedState;
		if (null !== fiber && null !== fiber.dehydrated) {
			var a = fiber.retryLane;
			fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
		}
	}
	function markRetryLaneIfNotHydrated(fiber, retryLane) {
		markRetryLaneImpl(fiber, retryLane);
		(fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
	}
	function attemptContinuousHydration(fiber) {
		if (13 === fiber.tag || 31 === fiber.tag) {
			var root$1 = enqueueConcurrentRenderForLane(fiber, 67108864);
			null !== root$1 && scheduleUpdateOnFiber(root$1, fiber, 67108864);
			markRetryLaneIfNotHydrated(fiber, 67108864);
		}
	}
	function attemptHydrationAtCurrentPriority(fiber) {
		if (13 === fiber.tag || 31 === fiber.tag) {
			var lane = requestUpdateLane();
			lane = getBumpedLaneForHydrationByLane(lane);
			var root$1 = enqueueConcurrentRenderForLane(fiber, lane);
			null !== root$1 && scheduleUpdateOnFiber(root$1, fiber, lane);
			markRetryLaneIfNotHydrated(fiber, lane);
		}
	}
	var _enabled = !0;
	function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
		var prevTransition = ReactSharedInternals.T;
		ReactSharedInternals.T = null;
		var previousPriority = ReactDOMSharedInternals.p;
		try {
			ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
		} finally {
			ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
		}
	}
	function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
		var prevTransition = ReactSharedInternals.T;
		ReactSharedInternals.T = null;
		var previousPriority = ReactDOMSharedInternals.p;
		try {
			ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
		} finally {
			ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
		}
	}
	function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
		if (_enabled) {
			var blockedOn = findInstanceBlockingEvent(nativeEvent);
			if (null === blockedOn) dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer), clearIfContinuousEvent(domEventName, nativeEvent);
			else if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) nativeEvent.stopPropagation();
			else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
				for (; null !== blockedOn;) {
					var fiber = getInstanceFromNode(blockedOn);
					if (null !== fiber) switch (fiber.tag) {
						case 3:
							fiber = fiber.stateNode;
							if (fiber.current.memoizedState.isDehydrated) {
								var lanes = getHighestPriorityLanes(fiber.pendingLanes);
								if (0 !== lanes) {
									var root$1 = fiber;
									root$1.pendingLanes |= 2;
									for (root$1.entangledLanes |= 2; lanes;) {
										var lane = 1 << 31 - clz32(lanes);
										root$1.entanglements[1] |= lane;
										lanes &= ~lane;
									}
									ensureRootIsScheduled(fiber);
									0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0, !1));
								}
							}
							break;
						case 31:
						case 13: root$1 = enqueueConcurrentRenderForLane(fiber, 2), null !== root$1 && scheduleUpdateOnFiber(root$1, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
					}
					fiber = findInstanceBlockingEvent(nativeEvent);
					null === fiber && dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
					if (fiber === blockedOn) break;
					blockedOn = fiber;
				}
				null !== blockedOn && nativeEvent.stopPropagation();
			} else dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
		}
	}
	function findInstanceBlockingEvent(nativeEvent) {
		nativeEvent = getEventTarget(nativeEvent);
		return findInstanceBlockingTarget(nativeEvent);
	}
	var return_targetInst = null;
	function findInstanceBlockingTarget(targetNode) {
		return_targetInst = null;
		targetNode = getClosestInstanceFromNode(targetNode);
		if (null !== targetNode) {
			var nearestMounted = getNearestMountedFiber(targetNode);
			if (null === nearestMounted) targetNode = null;
			else {
				var tag = nearestMounted.tag;
				if (13 === tag) {
					targetNode = getSuspenseInstanceFromFiber(nearestMounted);
					if (null !== targetNode) return targetNode;
					targetNode = null;
				} else if (31 === tag) {
					targetNode = getActivityInstanceFromFiber(nearestMounted);
					if (null !== targetNode) return targetNode;
					targetNode = null;
				} else if (3 === tag) {
					if (nearestMounted.stateNode.current.memoizedState.isDehydrated) return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
					targetNode = null;
				} else nearestMounted !== targetNode && (targetNode = null);
			}
		}
		return_targetInst = targetNode;
		return null;
	}
	function getEventPriority(domEventName) {
		switch (domEventName) {
			case "beforetoggle":
			case "cancel":
			case "click":
			case "close":
			case "contextmenu":
			case "copy":
			case "cut":
			case "auxclick":
			case "dblclick":
			case "dragend":
			case "dragstart":
			case "drop":
			case "focusin":
			case "focusout":
			case "input":
			case "invalid":
			case "keydown":
			case "keypress":
			case "keyup":
			case "mousedown":
			case "mouseup":
			case "paste":
			case "pause":
			case "play":
			case "pointercancel":
			case "pointerdown":
			case "pointerup":
			case "ratechange":
			case "reset":
			case "resize":
			case "seeked":
			case "submit":
			case "toggle":
			case "touchcancel":
			case "touchend":
			case "touchstart":
			case "volumechange":
			case "change":
			case "selectionchange":
			case "textInput":
			case "compositionstart":
			case "compositionend":
			case "compositionupdate":
			case "beforeblur":
			case "afterblur":
			case "beforeinput":
			case "blur":
			case "fullscreenchange":
			case "focus":
			case "hashchange":
			case "popstate":
			case "select":
			case "selectstart": return 2;
			case "drag":
			case "dragenter":
			case "dragexit":
			case "dragleave":
			case "dragover":
			case "mousemove":
			case "mouseout":
			case "mouseover":
			case "pointermove":
			case "pointerout":
			case "pointerover":
			case "scroll":
			case "touchmove":
			case "wheel":
			case "mouseenter":
			case "mouseleave":
			case "pointerenter":
			case "pointerleave": return 8;
			case "message": switch (getCurrentPriorityLevel()) {
				case ImmediatePriority: return 2;
				case UserBlockingPriority: return 8;
				case NormalPriority$1:
				case LowPriority: return 32;
				case IdlePriority: return 268435456;
				default: return 32;
			}
			default: return 32;
		}
	}
	var hasScheduledReplayAttempt = !1, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
	function clearIfContinuousEvent(domEventName, nativeEvent) {
		switch (domEventName) {
			case "focusin":
			case "focusout":
				queuedFocus = null;
				break;
			case "dragenter":
			case "dragleave":
				queuedDrag = null;
				break;
			case "mouseover":
			case "mouseout":
				queuedMouse = null;
				break;
			case "pointerover":
			case "pointerout":
				queuedPointers.delete(nativeEvent.pointerId);
				break;
			case "gotpointercapture":
			case "lostpointercapture": queuedPointerCaptures.delete(nativeEvent.pointerId);
		}
	}
	function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
		if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent) return existingQueuedEvent = {
			blockedOn,
			domEventName,
			eventSystemFlags,
			nativeEvent,
			targetContainers: [targetContainer]
		}, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
		existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
		blockedOn = existingQueuedEvent.targetContainers;
		null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
		return existingQueuedEvent;
	}
	function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
		switch (domEventName) {
			case "focusin": return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
			case "dragenter": return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
			case "mouseover": return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
			case "pointerover":
				var pointerId = nativeEvent.pointerId;
				queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent));
				return !0;
			case "gotpointercapture": return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)), !0;
		}
		return !1;
	}
	function attemptExplicitHydrationTarget(queuedTarget) {
		var targetInst = getClosestInstanceFromNode(queuedTarget.target);
		if (null !== targetInst) {
			var nearestMounted = getNearestMountedFiber(targetInst);
			if (null !== nearestMounted) {
				if (targetInst = nearestMounted.tag, 13 === targetInst) {
					if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
						queuedTarget.blockedOn = targetInst;
						runWithPriority(queuedTarget.priority, function() {
							attemptHydrationAtCurrentPriority(nearestMounted);
						});
						return;
					}
				} else if (31 === targetInst) {
					if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
						queuedTarget.blockedOn = targetInst;
						runWithPriority(queuedTarget.priority, function() {
							attemptHydrationAtCurrentPriority(nearestMounted);
						});
						return;
					}
				} else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
					queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
					return;
				}
			}
		}
		queuedTarget.blockedOn = null;
	}
	function attemptReplayContinuousQueuedEvent(queuedEvent) {
		if (null !== queuedEvent.blockedOn) return !1;
		for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length;) {
			var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
			if (null === nextBlockedOn) {
				nextBlockedOn = queuedEvent.nativeEvent;
				var nativeEventClone = new nextBlockedOn.constructor(nextBlockedOn.type, nextBlockedOn);
				currentReplayingEvent = nativeEventClone;
				nextBlockedOn.target.dispatchEvent(nativeEventClone);
				currentReplayingEvent = null;
			} else return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, !1;
			targetContainers.shift();
		}
		return !0;
	}
	function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map$1) {
		attemptReplayContinuousQueuedEvent(queuedEvent) && map$1.delete(key);
	}
	function replayUnblockedEvents() {
		hasScheduledReplayAttempt = !1;
		null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
		null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
		null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
		queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
		queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
	}
	function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
		queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = !0, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents)));
	}
	var lastScheduledReplayQueue = null;
	function scheduleReplayQueueIfNeeded(formReplayingQueue) {
		lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, function() {
			lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
			for (var i = 0; i < formReplayingQueue.length; i += 3) {
				var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
				if ("function" !== typeof submitterOrAction) if (null === findInstanceBlockingTarget(submitterOrAction || form)) continue;
				else break;
				var formInst = getInstanceFromNode(form);
				null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(formInst, {
					pending: !0,
					data: formData,
					method: form.method,
					action: submitterOrAction
				}, submitterOrAction, formData));
			}
		}));
	}
	function retryIfBlockedOn(unblocked) {
		function unblock(queuedEvent) {
			return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
		}
		null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
		null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
		null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
		queuedPointers.forEach(unblock);
		queuedPointerCaptures.forEach(unblock);
		for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
			var queuedTarget = queuedExplicitHydrationTargets[i];
			queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
		}
		for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn);) attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
		i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
		if (null != i) for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
			var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
			if ("function" === typeof submitterOrAction) formProps || scheduleReplayQueueIfNeeded(i);
			else if (formProps) {
				var action = null;
				if (submitterOrAction && submitterOrAction.hasAttribute("formAction")) {
					if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null) action = formProps.formAction;
					else if (null !== findInstanceBlockingTarget(form)) continue;
				} else action = formProps.action;
				"function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
				scheduleReplayQueueIfNeeded(i);
			}
		}
	}
	function defaultOnDefaultTransitionIndicator() {
		function handleNavigate(event) {
			event.canIntercept && "react-transition" === event.info && event.intercept({
				handler: function() {
					return new Promise(function(resolve) {
						return pendingResolve = resolve;
					});
				},
				focusReset: "manual",
				scroll: "manual"
			});
		}
		function handleNavigateComplete() {
			null !== pendingResolve && (pendingResolve(), pendingResolve = null);
			isCancelled || setTimeout(startFakeNavigation, 20);
		}
		function startFakeNavigation() {
			if (!isCancelled && !navigation.transition) {
				var currentEntry = navigation.currentEntry;
				currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
					state: currentEntry.getState(),
					info: "react-transition",
					history: "replace"
				});
			}
		}
		if ("object" === typeof navigation) {
			var isCancelled = !1, pendingResolve = null;
			navigation.addEventListener("navigate", handleNavigate);
			navigation.addEventListener("navigatesuccess", handleNavigateComplete);
			navigation.addEventListener("navigateerror", handleNavigateComplete);
			setTimeout(startFakeNavigation, 100);
			return function() {
				isCancelled = !0;
				navigation.removeEventListener("navigate", handleNavigate);
				navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
				navigation.removeEventListener("navigateerror", handleNavigateComplete);
				null !== pendingResolve && (pendingResolve(), pendingResolve = null);
			};
		}
	}
	function ReactDOMRoot(internalRoot) {
		this._internalRoot = internalRoot;
	}
	ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
		var root$1 = this._internalRoot;
		if (null === root$1) throw Error(formatProdErrorMessage(409));
		var current = root$1.current;
		updateContainerImpl(current, requestUpdateLane(), children, root$1, null, null);
	};
	ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
		var root$1 = this._internalRoot;
		if (null !== root$1) {
			this._internalRoot = null;
			var container = root$1.containerInfo;
			updateContainerImpl(root$1.current, 2, null, root$1, null, null);
			flushSyncWork$1();
			container[internalContainerInstanceKey] = null;
		}
	};
	function ReactDOMHydrationRoot(internalRoot) {
		this._internalRoot = internalRoot;
	}
	ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
		if (target) {
			var updatePriority = resolveUpdatePriority();
			target = {
				blockedOn: null,
				target,
				priority: updatePriority
			};
			for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++);
			queuedExplicitHydrationTargets.splice(i, 0, target);
			0 === i && attemptExplicitHydrationTarget(target);
		}
	};
	var isomorphicReactPackageVersion$jscomp$inline_1840 = React$6.version;
	if ("19.2.3" !== isomorphicReactPackageVersion$jscomp$inline_1840) throw Error(formatProdErrorMessage(527, isomorphicReactPackageVersion$jscomp$inline_1840, "19.2.3"));
	ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
		var fiber = componentOrElement._reactInternals;
		if (void 0 === fiber) {
			if ("function" === typeof componentOrElement.render) throw Error(formatProdErrorMessage(188));
			componentOrElement = Object.keys(componentOrElement).join(",");
			throw Error(formatProdErrorMessage(268, componentOrElement));
		}
		componentOrElement = findCurrentFiberUsingSlowPath(fiber);
		componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
		componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
		return componentOrElement;
	};
	var internals$jscomp$inline_2347 = {
		bundleType: 0,
		version: "19.2.3",
		rendererPackageName: "react-dom",
		currentDispatcherRef: ReactSharedInternals,
		reconcilerVersion: "19.2.3"
	};
	if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
		var hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
		if (!hook$jscomp$inline_2348.isDisabled && hook$jscomp$inline_2348.supportsFiber) try {
			rendererID = hook$jscomp$inline_2348.inject(internals$jscomp$inline_2347), injectedHook = hook$jscomp$inline_2348;
		} catch (err) {}
	}
	exports.createRoot = function(container, options$1) {
		if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
		var isStrictMode = !1, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
		null !== options$1 && void 0 !== options$1 && (!0 === options$1.unstable_strictMode && (isStrictMode = !0), void 0 !== options$1.identifierPrefix && (identifierPrefix = options$1.identifierPrefix), void 0 !== options$1.onUncaughtError && (onUncaughtError = options$1.onUncaughtError), void 0 !== options$1.onCaughtError && (onCaughtError = options$1.onCaughtError), void 0 !== options$1.onRecoverableError && (onRecoverableError = options$1.onRecoverableError));
		options$1 = createFiberRoot(container, 1, !1, null, null, isStrictMode, identifierPrefix, null, onUncaughtError, onCaughtError, onRecoverableError, defaultOnDefaultTransitionIndicator);
		container[internalContainerInstanceKey] = options$1.current;
		listenToAllSupportedEvents(container);
		return new ReactDOMRoot(options$1);
	};
}));
var import_client = (/* @__PURE__ */ __commonJSMin(((exports, module) => {
	function checkDCE() {
		if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") return;
		try {
			__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
		} catch (err) {
			console.error(err);
		}
	}
	checkDCE();
	module.exports = require_react_dom_client_production();
})))();
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
let EServerArgumentType = /* @__PURE__ */ function(EServerArgumentType$1) {
	EServerArgumentType$1[EServerArgumentType$1["STRING"] = 0] = "STRING";
	EServerArgumentType$1[EServerArgumentType$1["SELECT"] = 1] = "SELECT";
	EServerArgumentType$1[EServerArgumentType$1["INT"] = 2] = "INT";
	EServerArgumentType$1[EServerArgumentType$1["BOOLEAN"] = 3] = "BOOLEAN";
	return EServerArgumentType$1;
}({});
let EAppOperation = /* @__PURE__ */ function(EAppOperation$1) {
	EAppOperation$1[EAppOperation$1["TRANSLATION"] = 0] = "TRANSLATION";
	EAppOperation$1[EAppOperation$1["CLEANING"] = 1] = "CLEANING";
	return EAppOperation$1;
}({});
let EImageFit = /* @__PURE__ */ function(EImageFit$1) {
	EImageFit$1[EImageFit$1["FIT_TO_PAGE"] = 0] = "FIT_TO_PAGE";
	EImageFit$1[EImageFit$1["SCROLL"] = 1] = "SCROLL";
	return EImageFit$1;
}({});
var createStoreImpl = (createState) => {
	let state;
	const listeners = /* @__PURE__ */ new Set();
	const setState = (partial, replace) => {
		const nextState = typeof partial === "function" ? partial(state) : partial;
		if (!Object.is(nextState, state)) {
			const previousState = state;
			state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
			listeners.forEach((listener) => listener(state, previousState));
		}
	};
	const getState = () => state;
	const getInitialState = () => initialState;
	const subscribe = (listener) => {
		listeners.add(listener);
		return () => listeners.delete(listener);
	};
	const api = {
		setState,
		getState,
		getInitialState,
		subscribe
	};
	const initialState = state = createState(setState, getState, api);
	return api;
};
var createStore = ((createState) => createState ? createStoreImpl(createState) : createStoreImpl);
var identity$1 = (arg) => arg;
function useStore(api, selector = identity$1) {
	const slice = import_react.useSyncExternalStore(api.subscribe, import_react.useCallback(() => selector(api.getState()), [api, selector]), import_react.useCallback(() => selector(api.getInitialState()), [api, selector]));
	import_react.useDebugValue(slice);
	return slice;
}
var createImpl = (createState) => {
	const api = createStore(createState);
	const useBoundStore = (selector) => useStore(api, selector);
	Object.assign(useBoundStore, api);
	return useBoundStore;
};
var create = ((createState) => createState ? createImpl(createState) : createImpl);
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR$1 = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR$1;
var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
	if (node && typeof node === "object") switch (node[NODE_TYPE]) {
		case MAP:
		case SEQ: return true;
	}
	return false;
}
function isNode$1(node) {
	if (node && typeof node === "object") switch (node[NODE_TYPE]) {
		case ALIAS:
		case MAP:
		case SCALAR$1:
		case SEQ: return true;
	}
	return false;
}
var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
var BREAK$1 = Symbol("break visit");
var SKIP$1 = Symbol("skip children");
var REMOVE$1 = Symbol("remove node");
function visit$1(node, visitor) {
	const visitor_ = initVisitor(visitor);
	if (isDocument(node)) {
		if (visit_(null, node.contents, visitor_, Object.freeze([node])) === REMOVE$1) node.contents = null;
	} else visit_(null, node, visitor_, Object.freeze([]));
}
visit$1.BREAK = BREAK$1;
visit$1.SKIP = SKIP$1;
visit$1.REMOVE = REMOVE$1;
function visit_(key, node, visitor, path) {
	const ctrl = callVisitor(key, node, visitor, path);
	if (isNode$1(ctrl) || isPair(ctrl)) {
		replaceNode(key, path, ctrl);
		return visit_(key, ctrl, visitor, path);
	}
	if (typeof ctrl !== "symbol") {
		if (isCollection(node)) {
			path = Object.freeze(path.concat(node));
			for (let i = 0; i < node.items.length; ++i) {
				const ci = visit_(i, node.items[i], visitor, path);
				if (typeof ci === "number") i = ci - 1;
				else if (ci === BREAK$1) return BREAK$1;
				else if (ci === REMOVE$1) {
					node.items.splice(i, 1);
					i -= 1;
				}
			}
		} else if (isPair(node)) {
			path = Object.freeze(path.concat(node));
			const ck = visit_("key", node.key, visitor, path);
			if (ck === BREAK$1) return BREAK$1;
			else if (ck === REMOVE$1) node.key = null;
			const cv = visit_("value", node.value, visitor, path);
			if (cv === BREAK$1) return BREAK$1;
			else if (cv === REMOVE$1) node.value = null;
		}
	}
	return ctrl;
}
async function visitAsync(node, visitor) {
	const visitor_ = initVisitor(visitor);
	if (isDocument(node)) {
		if (await visitAsync_(null, node.contents, visitor_, Object.freeze([node])) === REMOVE$1) node.contents = null;
	} else await visitAsync_(null, node, visitor_, Object.freeze([]));
}
visitAsync.BREAK = BREAK$1;
visitAsync.SKIP = SKIP$1;
visitAsync.REMOVE = REMOVE$1;
async function visitAsync_(key, node, visitor, path) {
	const ctrl = await callVisitor(key, node, visitor, path);
	if (isNode$1(ctrl) || isPair(ctrl)) {
		replaceNode(key, path, ctrl);
		return visitAsync_(key, ctrl, visitor, path);
	}
	if (typeof ctrl !== "symbol") {
		if (isCollection(node)) {
			path = Object.freeze(path.concat(node));
			for (let i = 0; i < node.items.length; ++i) {
				const ci = await visitAsync_(i, node.items[i], visitor, path);
				if (typeof ci === "number") i = ci - 1;
				else if (ci === BREAK$1) return BREAK$1;
				else if (ci === REMOVE$1) {
					node.items.splice(i, 1);
					i -= 1;
				}
			}
		} else if (isPair(node)) {
			path = Object.freeze(path.concat(node));
			const ck = await visitAsync_("key", node.key, visitor, path);
			if (ck === BREAK$1) return BREAK$1;
			else if (ck === REMOVE$1) node.key = null;
			const cv = await visitAsync_("value", node.value, visitor, path);
			if (cv === BREAK$1) return BREAK$1;
			else if (cv === REMOVE$1) node.value = null;
		}
	}
	return ctrl;
}
function initVisitor(visitor) {
	if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) return Object.assign({
		Alias: visitor.Node,
		Map: visitor.Node,
		Scalar: visitor.Node,
		Seq: visitor.Node
	}, visitor.Value && {
		Map: visitor.Value,
		Scalar: visitor.Value,
		Seq: visitor.Value
	}, visitor.Collection && {
		Map: visitor.Collection,
		Seq: visitor.Collection
	}, visitor);
	return visitor;
}
function callVisitor(key, node, visitor, path) {
	if (typeof visitor === "function") return visitor(key, node, path);
	if (isMap(node)) return visitor.Map?.(key, node, path);
	if (isSeq(node)) return visitor.Seq?.(key, node, path);
	if (isPair(node)) return visitor.Pair?.(key, node, path);
	if (isScalar(node)) return visitor.Scalar?.(key, node, path);
	if (isAlias(node)) return visitor.Alias?.(key, node, path);
}
function replaceNode(key, path, node) {
	const parent = path[path.length - 1];
	if (isCollection(parent)) parent.items[key] = node;
	else if (isPair(parent)) if (key === "key") parent.key = node;
	else parent.value = node;
	else if (isDocument(parent)) parent.contents = node;
	else {
		const pt = isAlias(parent) ? "alias" : "scalar";
		throw new Error(`Cannot replace node with ${pt} parent`);
	}
}
var escapeChars = {
	"!": "%21",
	",": "%2C",
	"[": "%5B",
	"]": "%5D",
	"{": "%7B",
	"}": "%7D"
};
var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class Directives {
	constructor(yaml, tags) {
		this.docStart = null;
		this.docEnd = false;
		this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
		this.tags = Object.assign({}, Directives.defaultTags, tags);
	}
	clone() {
		const copy = new Directives(this.yaml, this.tags);
		copy.docStart = this.docStart;
		return copy;
	}
	atDocument() {
		const res = new Directives(this.yaml, this.tags);
		switch (this.yaml.version) {
			case "1.1":
				this.atNextDocument = true;
				break;
			case "1.2":
				this.atNextDocument = false;
				this.yaml = {
					explicit: Directives.defaultYaml.explicit,
					version: "1.2"
				};
				this.tags = Object.assign({}, Directives.defaultTags);
				break;
		}
		return res;
	}
	add(line, onError) {
		if (this.atNextDocument) {
			this.yaml = {
				explicit: Directives.defaultYaml.explicit,
				version: "1.1"
			};
			this.tags = Object.assign({}, Directives.defaultTags);
			this.atNextDocument = false;
		}
		const parts = line.trim().split(/[ \t]+/);
		const name = parts.shift();
		switch (name) {
			case "%TAG": {
				if (parts.length !== 2) {
					onError(0, "%TAG directive should contain exactly two parts");
					if (parts.length < 2) return false;
				}
				const [handle, prefix$1] = parts;
				this.tags[handle] = prefix$1;
				return true;
			}
			case "%YAML": {
				this.yaml.explicit = true;
				if (parts.length !== 1) {
					onError(0, "%YAML directive should contain exactly one part");
					return false;
				}
				const [version] = parts;
				if (version === "1.1" || version === "1.2") {
					this.yaml.version = version;
					return true;
				} else {
					const isValid = /^\d+\.\d+$/.test(version);
					onError(6, `Unsupported YAML version ${version}`, isValid);
					return false;
				}
			}
			default:
				onError(0, `Unknown directive ${name}`, true);
				return false;
		}
	}
	tagName(source, onError) {
		if (source === "!") return "!";
		if (source[0] !== "!") {
			onError(`Not a valid tag: ${source}`);
			return null;
		}
		if (source[1] === "<") {
			const verbatim = source.slice(2, -1);
			if (verbatim === "!" || verbatim === "!!") {
				onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
				return null;
			}
			if (source[source.length - 1] !== ">") onError("Verbatim tags must end with a >");
			return verbatim;
		}
		const [, handle, suffix$1] = source.match(/^(.*!)([^!]*)$/s);
		if (!suffix$1) onError(`The ${source} tag has no suffix`);
		const prefix$1 = this.tags[handle];
		if (prefix$1) try {
			return prefix$1 + decodeURIComponent(suffix$1);
		} catch (error) {
			onError(String(error));
			return null;
		}
		if (handle === "!") return source;
		onError(`Could not resolve tag: ${source}`);
		return null;
	}
	tagString(tag) {
		for (const [handle, prefix$1] of Object.entries(this.tags)) if (tag.startsWith(prefix$1)) return handle + escapeTagName(tag.substring(prefix$1.length));
		return tag[0] === "!" ? tag : `!<${tag}>`;
	}
	toString(doc) {
		const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
		const tagEntries = Object.entries(this.tags);
		let tagNames;
		if (doc && tagEntries.length > 0 && isNode$1(doc.contents)) {
			const tags = {};
			visit$1(doc.contents, (_key, node) => {
				if (isNode$1(node) && node.tag) tags[node.tag] = true;
			});
			tagNames = Object.keys(tags);
		} else tagNames = [];
		for (const [handle, prefix$1] of tagEntries) {
			if (handle === "!!" && prefix$1 === "tag:yaml.org,2002:") continue;
			if (!doc || tagNames.some((tn) => tn.startsWith(prefix$1))) lines.push(`%TAG ${handle} ${prefix$1}`);
		}
		return lines.join("\n");
	}
};
Directives.defaultYaml = {
	explicit: false,
	version: "1.2"
};
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
function anchorIsValid(anchor) {
	if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
		const msg = `Anchor must not contain whitespace or control characters: ${JSON.stringify(anchor)}`;
		throw new Error(msg);
	}
	return true;
}
function anchorNames(root$1) {
	const anchors = /* @__PURE__ */ new Set();
	visit$1(root$1, { Value(_key, node) {
		if (node.anchor) anchors.add(node.anchor);
	} });
	return anchors;
}
function findNewAnchor(prefix$1, exclude) {
	for (let i = 1;; ++i) {
		const name = `${prefix$1}${i}`;
		if (!exclude.has(name)) return name;
	}
}
function createNodeAnchors(doc, prefix$1) {
	const aliasObjects = [];
	const sourceObjects = /* @__PURE__ */ new Map();
	let prevAnchors = null;
	return {
		onAnchor: (source) => {
			aliasObjects.push(source);
			prevAnchors ?? (prevAnchors = anchorNames(doc));
			const anchor = findNewAnchor(prefix$1, prevAnchors);
			prevAnchors.add(anchor);
			return anchor;
		},
		setAnchors: () => {
			for (const source of aliasObjects) {
				const ref = sourceObjects.get(source);
				if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) ref.node.anchor = ref.anchor;
				else {
					const error = /* @__PURE__ */ new Error("Failed to resolve repeated object (this should not happen)");
					error.source = source;
					throw error;
				}
			}
		},
		sourceObjects
	};
}
function applyReviver(reviver, obj, key, val) {
	if (val && typeof val === "object") if (Array.isArray(val)) for (let i = 0, len = val.length; i < len; ++i) {
		const v0 = val[i];
		const v1 = applyReviver(reviver, val, String(i), v0);
		if (v1 === void 0) delete val[i];
		else if (v1 !== v0) val[i] = v1;
	}
	else if (val instanceof Map) for (const k of Array.from(val.keys())) {
		const v0 = val.get(k);
		const v1 = applyReviver(reviver, val, k, v0);
		if (v1 === void 0) val.delete(k);
		else if (v1 !== v0) val.set(k, v1);
	}
	else if (val instanceof Set) for (const v0 of Array.from(val)) {
		const v1 = applyReviver(reviver, val, v0, v0);
		if (v1 === void 0) val.delete(v0);
		else if (v1 !== v0) {
			val.delete(v0);
			val.add(v1);
		}
	}
	else for (const [k, v0] of Object.entries(val)) {
		const v1 = applyReviver(reviver, val, k, v0);
		if (v1 === void 0) delete val[k];
		else if (v1 !== v0) val[k] = v1;
	}
	return reviver.call(obj, key, val);
}
function toJS(value, arg, ctx) {
	if (Array.isArray(value)) return value.map((v, i) => toJS(v, String(i), ctx));
	if (value && typeof value.toJSON === "function") {
		if (!ctx || !hasAnchor(value)) return value.toJSON(arg, ctx);
		const data = {
			aliasCount: 0,
			count: 1,
			res: void 0
		};
		ctx.anchors.set(value, data);
		ctx.onCreate = (res$1) => {
			data.res = res$1;
			delete ctx.onCreate;
		};
		const res = value.toJSON(arg, ctx);
		if (ctx.onCreate) ctx.onCreate(res);
		return res;
	}
	if (typeof value === "bigint" && !ctx?.keep) return Number(value);
	return value;
}
var NodeBase = class {
	constructor(type) {
		Object.defineProperty(this, NODE_TYPE, { value: type });
	}
	clone() {
		const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
		if (this.range) copy.range = this.range.slice();
		return copy;
	}
	toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
		if (!isDocument(doc)) throw new TypeError("A document argument is required");
		const ctx = {
			anchors: /* @__PURE__ */ new Map(),
			doc,
			keep: true,
			mapAsMap: mapAsMap === true,
			mapKeyWarned: false,
			maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
		};
		const res = toJS(this, "", ctx);
		if (typeof onAnchor === "function") for (const { count: count$1, res: res$1 } of ctx.anchors.values()) onAnchor(res$1, count$1);
		return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
	}
};
var Alias = class extends NodeBase {
	constructor(source) {
		super(ALIAS);
		this.source = source;
		Object.defineProperty(this, "tag", { set() {
			throw new Error("Alias nodes cannot have tags");
		} });
	}
	resolve(doc, ctx) {
		let nodes;
		if (ctx?.aliasResolveCache) nodes = ctx.aliasResolveCache;
		else {
			nodes = [];
			visit$1(doc, { Node: (_key, node) => {
				if (isAlias(node) || hasAnchor(node)) nodes.push(node);
			} });
			if (ctx) ctx.aliasResolveCache = nodes;
		}
		let found = void 0;
		for (const node of nodes) {
			if (node === this) break;
			if (node.anchor === this.source) found = node;
		}
		return found;
	}
	toJSON(_arg, ctx) {
		if (!ctx) return { source: this.source };
		const { anchors, doc, maxAliasCount } = ctx;
		const source = this.resolve(doc, ctx);
		if (!source) {
			const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
			throw new ReferenceError(msg);
		}
		let data = anchors.get(source);
		if (!data) {
			toJS(source, null, ctx);
			data = anchors.get(source);
		}
		/* istanbul ignore if */
		if (data?.res === void 0) throw new ReferenceError("This should not happen: Alias anchor was not resolved?");
		if (maxAliasCount >= 0) {
			data.count += 1;
			if (data.aliasCount === 0) data.aliasCount = getAliasCount(doc, source, anchors);
			if (data.count * data.aliasCount > maxAliasCount) throw new ReferenceError("Excessive alias count indicates a resource exhaustion attack");
		}
		return data.res;
	}
	toString(ctx, _onComment, _onChompKeep) {
		const src = `*${this.source}`;
		if (ctx) {
			anchorIsValid(this.source);
			if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
				const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
				throw new Error(msg);
			}
			if (ctx.implicitKey) return `${src} `;
		}
		return src;
	}
};
function getAliasCount(doc, node, anchors) {
	if (isAlias(node)) {
		const source = node.resolve(doc);
		const anchor = anchors && source && anchors.get(source);
		return anchor ? anchor.count * anchor.aliasCount : 0;
	} else if (isCollection(node)) {
		let count$1 = 0;
		for (const item of node.items) {
			const c = getAliasCount(doc, item, anchors);
			if (c > count$1) count$1 = c;
		}
		return count$1;
	} else if (isPair(node)) {
		const kc = getAliasCount(doc, node.key, anchors);
		const vc = getAliasCount(doc, node.value, anchors);
		return Math.max(kc, vc);
	}
	return 1;
}
var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
var Scalar = class extends NodeBase {
	constructor(value) {
		super(SCALAR$1);
		this.value = value;
	}
	toJSON(arg, ctx) {
		return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
	}
	toString() {
		return String(this.value);
	}
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
	if (tagName) {
		const match = tags.filter((t) => t.tag === tagName);
		const tagObj = match.find((t) => !t.format) ?? match[0];
		if (!tagObj) throw new Error(`Tag ${tagName} not found`);
		return tagObj;
	}
	return tags.find((t) => t.identify?.(value) && !t.format);
}
function createNode(value, tagName, ctx) {
	if (isDocument(value)) value = value.contents;
	if (isNode$1(value)) return value;
	if (isPair(value)) {
		const map$1 = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
		map$1.items.push(value);
		return map$1;
	}
	if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) value = value.valueOf();
	const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema$3, sourceObjects } = ctx;
	let ref = void 0;
	if (aliasDuplicateObjects && value && typeof value === "object") {
		ref = sourceObjects.get(value);
		if (ref) {
			ref.anchor ?? (ref.anchor = onAnchor(value));
			return new Alias(ref.anchor);
		} else {
			ref = {
				anchor: null,
				node: null
			};
			sourceObjects.set(value, ref);
		}
	}
	if (tagName?.startsWith("!!")) tagName = defaultTagPrefix + tagName.slice(2);
	let tagObj = findTagObject(value, tagName, schema$3.tags);
	if (!tagObj) {
		if (value && typeof value.toJSON === "function") value = value.toJSON();
		if (!value || typeof value !== "object") {
			const node$1 = new Scalar(value);
			if (ref) ref.node = node$1;
			return node$1;
		}
		tagObj = value instanceof Map ? schema$3[MAP] : Symbol.iterator in Object(value) ? schema$3[SEQ] : schema$3[MAP];
	}
	if (onTagObj) {
		onTagObj(tagObj);
		delete ctx.onTagObj;
	}
	const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
	if (tagName) node.tag = tagName;
	else if (!tagObj.default) node.tag = tagObj.tag;
	if (ref) ref.node = node;
	return node;
}
function collectionFromPath(schema$3, path, value) {
	let v = value;
	for (let i = path.length - 1; i >= 0; --i) {
		const k = path[i];
		if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
			const a = [];
			a[k] = v;
			v = a;
		} else v = new Map([[k, v]]);
	}
	return createNode(v, void 0, {
		aliasDuplicateObjects: false,
		keepUndefined: false,
		onAnchor: () => {
			throw new Error("This should not happen, please report a bug.");
		},
		schema: schema$3,
		sourceObjects: /* @__PURE__ */ new Map()
	});
}
var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
	constructor(type, schema$3) {
		super(type);
		Object.defineProperty(this, "schema", {
			value: schema$3,
			configurable: true,
			enumerable: false,
			writable: true
		});
	}
	clone(schema$3) {
		const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
		if (schema$3) copy.schema = schema$3;
		copy.items = copy.items.map((it) => isNode$1(it) || isPair(it) ? it.clone(schema$3) : it);
		if (this.range) copy.range = this.range.slice();
		return copy;
	}
	addIn(path, value) {
		if (isEmptyPath(path)) this.add(value);
		else {
			const [key, ...rest] = path;
			const node = this.get(key, true);
			if (isCollection(node)) node.addIn(rest, value);
			else if (node === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
			else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
		}
	}
	deleteIn(path) {
		const [key, ...rest] = path;
		if (rest.length === 0) return this.delete(key);
		const node = this.get(key, true);
		if (isCollection(node)) return node.deleteIn(rest);
		else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
	}
	getIn(path, keepScalar) {
		const [key, ...rest] = path;
		const node = this.get(key, true);
		if (rest.length === 0) return !keepScalar && isScalar(node) ? node.value : node;
		else return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
	}
	hasAllNullValues(allowScalar) {
		return this.items.every((node) => {
			if (!isPair(node)) return false;
			const n = node.value;
			return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
		});
	}
	hasIn(path) {
		const [key, ...rest] = path;
		if (rest.length === 0) return this.has(key);
		const node = this.get(key, true);
		return isCollection(node) ? node.hasIn(rest) : false;
	}
	setIn(path, value) {
		const [key, ...rest] = path;
		if (rest.length === 0) this.set(key, value);
		else {
			const node = this.get(key, true);
			if (isCollection(node)) node.setIn(rest, value);
			else if (node === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
			else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
		}
	}
};
var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment, indent) {
	if (/^\n+$/.test(comment)) return comment.substring(1);
	return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
	if (!lineWidth || lineWidth < 0) return text;
	if (lineWidth < minContentWidth) minContentWidth = 0;
	const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
	if (text.length <= endStep) return text;
	const folds = [];
	const escapedFolds = {};
	let end = lineWidth - indent.length;
	if (typeof indentAtStart === "number") if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);
	else end = lineWidth - indentAtStart;
	let split = void 0;
	let prev = void 0;
	let overflow = false;
	let i = -1;
	let escStart = -1;
	let escEnd = -1;
	if (mode === "block") {
		i = consumeMoreIndentedLines(text, i, indent.length);
		if (i !== -1) end = i + endStep;
	}
	for (let ch; ch = text[i += 1];) {
		if (mode === "quoted" && ch === "\\") {
			escStart = i;
			switch (text[i + 1]) {
				case "x":
					i += 3;
					break;
				case "u":
					i += 5;
					break;
				case "U":
					i += 9;
					break;
				default: i += 1;
			}
			escEnd = i;
		}
		if (ch === "\n") {
			if (mode === "block") i = consumeMoreIndentedLines(text, i, indent.length);
			end = i + indent.length + endStep;
			split = void 0;
		} else {
			if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
				const next = text[i + 1];
				if (next && next !== " " && next !== "\n" && next !== "	") split = i;
			}
			if (i >= end) if (split) {
				folds.push(split);
				end = split + endStep;
				split = void 0;
			} else if (mode === "quoted") {
				while (prev === " " || prev === "	") {
					prev = ch;
					ch = text[i += 1];
					overflow = true;
				}
				const j = i > escEnd + 1 ? i - 2 : escStart - 1;
				if (escapedFolds[j]) return text;
				folds.push(j);
				escapedFolds[j] = true;
				end = j + endStep;
				split = void 0;
			} else overflow = true;
		}
		prev = ch;
	}
	if (overflow && onOverflow) onOverflow();
	if (folds.length === 0) return text;
	if (onFold) onFold();
	let res = text.slice(0, folds[0]);
	for (let i$1 = 0; i$1 < folds.length; ++i$1) {
		const fold = folds[i$1];
		const end$1 = folds[i$1 + 1] || text.length;
		if (fold === 0) res = `\n${indent}${text.slice(0, end$1)}`;
		else {
			if (mode === "quoted" && escapedFolds[fold]) res += `${text[fold]}\\`;
			res += `\n${indent}${text.slice(fold + 1, end$1)}`;
		}
	}
	return res;
}
function consumeMoreIndentedLines(text, i, indent) {
	let end = i;
	let start = i + 1;
	let ch = text[start];
	while (ch === " " || ch === "	") if (i < start + indent) ch = text[++i];
	else {
		do
			ch = text[++i];
		while (ch && ch !== "\n");
		end = i;
		start = i + 1;
		ch = text[start];
	}
	return end;
}
var getFoldOptions = (ctx, isBlock$1) => ({
	indentAtStart: isBlock$1 ? ctx.indent.length : ctx.indentAtStart,
	lineWidth: ctx.options.lineWidth,
	minContentWidth: ctx.options.minContentWidth
});
var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
	if (!lineWidth || lineWidth < 0) return false;
	const limit = lineWidth - indentLength;
	const strLen = str.length;
	if (strLen <= limit) return false;
	for (let i = 0, start = 0; i < strLen; ++i) if (str[i] === "\n") {
		if (i - start > limit) return true;
		start = i + 1;
		if (strLen - start <= limit) return false;
	}
	return true;
}
function doubleQuotedString(value, ctx) {
	const json = JSON.stringify(value);
	if (ctx.options.doubleQuotedAsJSON) return json;
	const { implicitKey } = ctx;
	const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
	const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
	let str = "";
	let start = 0;
	for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
		if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
			str += json.slice(start, i) + "\\ ";
			i += 1;
			start = i;
			ch = "\\";
		}
		if (ch === "\\") switch (json[i + 1]) {
			case "u":
				{
					str += json.slice(start, i);
					const code = json.substr(i + 2, 4);
					switch (code) {
						case "0000":
							str += "\\0";
							break;
						case "0007":
							str += "\\a";
							break;
						case "000b":
							str += "\\v";
							break;
						case "001b":
							str += "\\e";
							break;
						case "0085":
							str += "\\N";
							break;
						case "00a0":
							str += "\\_";
							break;
						case "2028":
							str += "\\L";
							break;
						case "2029":
							str += "\\P";
							break;
						default: if (code.substr(0, 2) === "00") str += "\\x" + code.substr(2);
						else str += json.substr(i, 6);
					}
					i += 5;
					start = i + 1;
				}
				break;
			case "n":
				if (implicitKey || json[i + 2] === "\"" || json.length < minMultiLineLength) i += 1;
				else {
					str += json.slice(start, i) + "\n\n";
					while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== "\"") {
						str += "\n";
						i += 2;
					}
					str += indent;
					if (json[i + 2] === " ") str += "\\";
					i += 1;
					start = i + 1;
				}
				break;
			default: i += 1;
		}
	}
	str = start ? str + json.slice(start) : json;
	return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
	if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
	const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
	const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
	return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
	const { singleQuote } = ctx.options;
	let qs;
	if (singleQuote === false) qs = doubleQuotedString;
	else {
		const hasDouble = value.includes("\"");
		const hasSingle = value.includes("'");
		if (hasDouble && !hasSingle) qs = singleQuotedString;
		else if (hasSingle && !hasDouble) qs = doubleQuotedString;
		else qs = singleQuote ? singleQuotedString : doubleQuotedString;
	}
	return qs(value, ctx);
}
var blockEndNewlines;
try {
	blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
} catch {
	blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
	const { blockQuote, commentString, lineWidth } = ctx.options;
	if (!blockQuote || /\n[\t ]+$/.test(value)) return quotedString(value, ctx);
	const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
	const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
	if (!value) return literal ? "|\n" : ">\n";
	let chomp;
	let endStart;
	for (endStart = value.length; endStart > 0; --endStart) {
		const ch = value[endStart - 1];
		if (ch !== "\n" && ch !== "	" && ch !== " ") break;
	}
	let end = value.substring(endStart);
	const endNlPos = end.indexOf("\n");
	if (endNlPos === -1) chomp = "-";
	else if (value === end || endNlPos !== end.length - 1) {
		chomp = "+";
		if (onChompKeep) onChompKeep();
	} else chomp = "";
	if (end) {
		value = value.slice(0, -end.length);
		if (end[end.length - 1] === "\n") end = end.slice(0, -1);
		end = end.replace(blockEndNewlines, `$&${indent}`);
	}
	let startWithSpace = false;
	let startEnd;
	let startNlPos = -1;
	for (startEnd = 0; startEnd < value.length; ++startEnd) {
		const ch = value[startEnd];
		if (ch === " ") startWithSpace = true;
		else if (ch === "\n") startNlPos = startEnd;
		else break;
	}
	let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
	if (start) {
		value = value.substring(start.length);
		start = start.replace(/\n+/g, `$&${indent}`);
	}
	let header = (startWithSpace ? indent ? "2" : "1" : "") + chomp;
	if (comment) {
		header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
		if (onComment) onComment();
	}
	if (!literal) {
		const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
		let literalFallback = false;
		const foldOptions = getFoldOptions(ctx, true);
		if (blockQuote !== "folded" && type !== Scalar.BLOCK_FOLDED) foldOptions.onOverflow = () => {
			literalFallback = true;
		};
		const body = foldFlowLines(`${start}${foldedValue}${end}`, indent, FOLD_BLOCK, foldOptions);
		if (!literalFallback) return `>${header}\n${indent}${body}`;
	}
	value = value.replace(/\n+/g, `$&${indent}`);
	return `|${header}\n${indent}${start}${value}${end}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
	const { type, value } = item;
	const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
	if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) return quotedString(value, ctx);
	if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
	if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) return blockString(item, ctx, onComment, onChompKeep);
	if (containsDocumentMarker(value)) {
		if (indent === "") {
			ctx.forceBlockIndent = true;
			return blockString(item, ctx, onComment, onChompKeep);
		} else if (implicitKey && indent === indentStep) return quotedString(value, ctx);
	}
	const str = value.replace(/\n+/g, `$&\n${indent}`);
	if (actualString) {
		const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
		const { compat, tags } = ctx.doc.schema;
		if (tags.some(test) || compat?.some(test)) return quotedString(value, ctx);
	}
	return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
	const { implicitKey, inFlow } = ctx;
	const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
	let { type } = item;
	if (type !== Scalar.QUOTE_DOUBLE) {
		if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value)) type = Scalar.QUOTE_DOUBLE;
	}
	const _stringify = (_type) => {
		switch (_type) {
			case Scalar.BLOCK_FOLDED:
			case Scalar.BLOCK_LITERAL: return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
			case Scalar.QUOTE_DOUBLE: return doubleQuotedString(ss.value, ctx);
			case Scalar.QUOTE_SINGLE: return singleQuotedString(ss.value, ctx);
			case Scalar.PLAIN: return plainString(ss, ctx, onComment, onChompKeep);
			default: return null;
		}
	};
	let res = _stringify(type);
	if (res === null) {
		const { defaultKeyType, defaultStringType } = ctx.options;
		const t = implicitKey && defaultKeyType || defaultStringType;
		res = _stringify(t);
		if (res === null) throw new Error(`Unsupported default string type ${t}`);
	}
	return res;
}
function createStringifyContext(doc, options$1) {
	const opt = Object.assign({
		blockQuote: true,
		commentString: stringifyComment,
		defaultKeyType: null,
		defaultStringType: "PLAIN",
		directives: null,
		doubleQuotedAsJSON: false,
		doubleQuotedMinMultiLineLength: 40,
		falseStr: "false",
		flowCollectionPadding: true,
		indentSeq: true,
		lineWidth: 80,
		minContentWidth: 20,
		nullStr: "null",
		simpleKeys: false,
		singleQuote: null,
		trueStr: "true",
		verifyAliasOrder: true
	}, doc.schema.toStringOptions, options$1);
	let inFlow;
	switch (opt.collectionStyle) {
		case "block":
			inFlow = false;
			break;
		case "flow":
			inFlow = true;
			break;
		default: inFlow = null;
	}
	return {
		anchors: /* @__PURE__ */ new Set(),
		doc,
		flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
		indent: "",
		indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
		inFlow,
		options: opt
	};
}
function getTagObject(tags, item) {
	if (item.tag) {
		const match = tags.filter((t) => t.tag === item.tag);
		if (match.length > 0) return match.find((t) => t.format === item.format) ?? match[0];
	}
	let tagObj = void 0;
	let obj;
	if (isScalar(item)) {
		obj = item.value;
		let match = tags.filter((t) => t.identify?.(obj));
		if (match.length > 1) {
			const testMatch = match.filter((t) => t.test);
			if (testMatch.length > 0) match = testMatch;
		}
		tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
	} else {
		obj = item;
		tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
	}
	if (!tagObj) {
		const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
		throw new Error(`Tag not resolved for ${name} value`);
	}
	return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
	if (!doc.directives) return "";
	const props = [];
	const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
	if (anchor && anchorIsValid(anchor)) {
		anchors.add(anchor);
		props.push(`&${anchor}`);
	}
	const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
	if (tag) props.push(doc.directives.tagString(tag));
	return props.join(" ");
}
function stringify$1(item, ctx, onComment, onChompKeep) {
	if (isPair(item)) return item.toString(ctx, onComment, onChompKeep);
	if (isAlias(item)) {
		if (ctx.doc.directives) return item.toString(ctx);
		if (ctx.resolvedAliases?.has(item)) throw new TypeError(`Cannot stringify circular structure without alias nodes`);
		else {
			if (ctx.resolvedAliases) ctx.resolvedAliases.add(item);
			else ctx.resolvedAliases = new Set([item]);
			item = item.resolve(ctx.doc);
		}
	}
	let tagObj = void 0;
	const node = isNode$1(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
	tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
	const props = stringifyProps(node, tagObj, ctx);
	if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
	const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
	if (!props) return str;
	return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}\n${ctx.indent}${str}`;
}
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
	const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
	let keyComment = isNode$1(key) && key.comment || null;
	if (simpleKeys) {
		if (keyComment) throw new Error("With simple keys, key nodes cannot have comments");
		if (isCollection(key) || !isNode$1(key) && typeof key === "object") throw new Error("With simple keys, collection cannot be used as a key value");
	}
	let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
	ctx = Object.assign({}, ctx, {
		allNullValues: false,
		implicitKey: !explicitKey && (simpleKeys || !allNullValues),
		indent: indent + indentStep
	});
	let keyCommentDone = false;
	let chompKeep = false;
	let str = stringify$1(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
	if (!explicitKey && !ctx.inFlow && str.length > 1024) {
		if (simpleKeys) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
		explicitKey = true;
	}
	if (ctx.inFlow) {
		if (allNullValues || value == null) {
			if (keyCommentDone && onComment) onComment();
			return str === "" ? "?" : explicitKey ? `? ${str}` : str;
		}
	} else if (allNullValues && !simpleKeys || value == null && explicitKey) {
		str = `? ${str}`;
		if (keyComment && !keyCommentDone) str += lineComment(str, ctx.indent, commentString(keyComment));
		else if (chompKeep && onChompKeep) onChompKeep();
		return str;
	}
	if (keyCommentDone) keyComment = null;
	if (explicitKey) {
		if (keyComment) str += lineComment(str, ctx.indent, commentString(keyComment));
		str = `? ${str}\n${indent}:`;
	} else {
		str = `${str}:`;
		if (keyComment) str += lineComment(str, ctx.indent, commentString(keyComment));
	}
	let vsb, vcb, valueComment;
	if (isNode$1(value)) {
		vsb = !!value.spaceBefore;
		vcb = value.commentBefore;
		valueComment = value.comment;
	} else {
		vsb = false;
		vcb = null;
		valueComment = null;
		if (value && typeof value === "object") value = doc.createNode(value);
	}
	ctx.implicitKey = false;
	if (!explicitKey && !keyComment && isScalar(value)) ctx.indentAtStart = str.length + 1;
	chompKeep = false;
	if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) ctx.indent = ctx.indent.substring(2);
	let valueCommentDone = false;
	const valueStr = stringify$1(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
	let ws = " ";
	if (keyComment || vsb || vcb) {
		ws = vsb ? "\n" : "";
		if (vcb) {
			const cs = commentString(vcb);
			ws += `\n${indentComment(cs, ctx.indent)}`;
		}
		if (valueStr === "" && !ctx.inFlow) {
			if (ws === "\n" && valueComment) ws = "\n\n";
		} else ws += `\n${ctx.indent}`;
	} else if (!explicitKey && isCollection(value)) {
		const vs0 = valueStr[0];
		const nl0 = valueStr.indexOf("\n");
		const hasNewline = nl0 !== -1;
		const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
		if (hasNewline || !flow) {
			let hasPropsLine = false;
			if (hasNewline && (vs0 === "&" || vs0 === "!")) {
				let sp0 = valueStr.indexOf(" ");
				if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") sp0 = valueStr.indexOf(" ", sp0 + 1);
				if (sp0 === -1 || nl0 < sp0) hasPropsLine = true;
			}
			if (!hasPropsLine) ws = `\n${ctx.indent}`;
		}
	} else if (valueStr === "" || valueStr[0] === "\n") ws = "";
	str += ws + valueStr;
	if (ctx.inFlow) {
		if (valueCommentDone && onComment) onComment();
	} else if (valueComment && !valueCommentDone) str += lineComment(str, ctx.indent, commentString(valueComment));
	else if (chompKeep && onChompKeep) onChompKeep();
	return str;
}
function warn(logLevel, warning) {
	if (logLevel === "debug" || logLevel === "warn") console.warn(warning);
}
var MERGE_KEY = "<<";
var merge = {
	identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
	default: "key",
	tag: "tag:yaml.org,2002:merge",
	test: /^<<$/,
	resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), { addToJSMap: addMergeToJSMap }),
	stringify: () => MERGE_KEY
};
var isMergeKey = (ctx, key) => (merge.identify(key) || isScalar(key) && (!key.type || key.type === Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default);
function addMergeToJSMap(ctx, map$1, value) {
	value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
	if (isSeq(value)) for (const it of value.items) mergeValue(ctx, map$1, it);
	else if (Array.isArray(value)) for (const it of value) mergeValue(ctx, map$1, it);
	else mergeValue(ctx, map$1, value);
}
function mergeValue(ctx, map$1, value) {
	const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
	if (!isMap(source)) throw new Error("Merge sources must be maps or map aliases");
	const srcMap = source.toJSON(null, ctx, Map);
	for (const [key, value$1] of srcMap) if (map$1 instanceof Map) {
		if (!map$1.has(key)) map$1.set(key, value$1);
	} else if (map$1 instanceof Set) map$1.add(key);
	else if (!Object.prototype.hasOwnProperty.call(map$1, key)) Object.defineProperty(map$1, key, {
		value: value$1,
		writable: true,
		enumerable: true,
		configurable: true
	});
	return map$1;
}
function addPairToJSMap(ctx, map$1, { key, value }) {
	if (isNode$1(key) && key.addToJSMap) key.addToJSMap(ctx, map$1, value);
	else if (isMergeKey(ctx, key)) addMergeToJSMap(ctx, map$1, value);
	else {
		const jsKey = toJS(key, "", ctx);
		if (map$1 instanceof Map) map$1.set(jsKey, toJS(value, jsKey, ctx));
		else if (map$1 instanceof Set) map$1.add(jsKey);
		else {
			const stringKey = stringifyKey(key, jsKey, ctx);
			const jsValue = toJS(value, stringKey, ctx);
			if (stringKey in map$1) Object.defineProperty(map$1, stringKey, {
				value: jsValue,
				writable: true,
				enumerable: true,
				configurable: true
			});
			else map$1[stringKey] = jsValue;
		}
	}
	return map$1;
}
function stringifyKey(key, jsKey, ctx) {
	if (jsKey === null) return "";
	if (typeof jsKey !== "object") return String(jsKey);
	if (isNode$1(key) && ctx?.doc) {
		const strCtx = createStringifyContext(ctx.doc, {});
		strCtx.anchors = /* @__PURE__ */ new Set();
		for (const node of ctx.anchors.keys()) strCtx.anchors.add(node.anchor);
		strCtx.inFlow = true;
		strCtx.inStringifyKey = true;
		const strKey = key.toString(strCtx);
		if (!ctx.mapKeyWarned) {
			let jsonStr = JSON.stringify(strKey);
			if (jsonStr.length > 40) jsonStr = jsonStr.substring(0, 36) + "...\"";
			warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
			ctx.mapKeyWarned = true;
		}
		return strKey;
	}
	return JSON.stringify(jsKey);
}
function createPair(key, value, ctx) {
	return new Pair(createNode(key, void 0, ctx), createNode(value, void 0, ctx));
}
var Pair = class Pair {
	constructor(key, value = null) {
		Object.defineProperty(this, NODE_TYPE, { value: PAIR });
		this.key = key;
		this.value = value;
	}
	clone(schema$3) {
		let { key, value } = this;
		if (isNode$1(key)) key = key.clone(schema$3);
		if (isNode$1(value)) value = value.clone(schema$3);
		return new Pair(key, value);
	}
	toJSON(_, ctx) {
		return addPairToJSMap(ctx, ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {}, this);
	}
	toString(ctx, onComment, onChompKeep) {
		return ctx?.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
	}
};
function stringifyCollection(collection, ctx, options$1) {
	return (ctx.inFlow ?? collection.flow ? stringifyFlowCollection : stringifyBlockCollection)(collection, ctx, options$1);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
	const { indent, options: { commentString } } = ctx;
	const itemCtx = Object.assign({}, ctx, {
		indent: itemIndent,
		type: null
	});
	let chompKeep = false;
	const lines = [];
	for (let i = 0; i < items.length; ++i) {
		const item = items[i];
		let comment$1 = null;
		if (isNode$1(item)) {
			if (!chompKeep && item.spaceBefore) lines.push("");
			addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
			if (item.comment) comment$1 = item.comment;
		} else if (isPair(item)) {
			const ik = isNode$1(item.key) ? item.key : null;
			if (ik) {
				if (!chompKeep && ik.spaceBefore) lines.push("");
				addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
			}
		}
		chompKeep = false;
		let str$1 = stringify$1(item, itemCtx, () => comment$1 = null, () => chompKeep = true);
		if (comment$1) str$1 += lineComment(str$1, itemIndent, commentString(comment$1));
		if (chompKeep && comment$1) chompKeep = false;
		lines.push(blockItemPrefix + str$1);
	}
	let str;
	if (lines.length === 0) str = flowChars.start + flowChars.end;
	else {
		str = lines[0];
		for (let i = 1; i < lines.length; ++i) {
			const line = lines[i];
			str += line ? `\n${indent}${line}` : "\n";
		}
	}
	if (comment) {
		str += "\n" + indentComment(commentString(comment), indent);
		if (onComment) onComment();
	} else if (chompKeep && onChompKeep) onChompKeep();
	return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
	const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
	itemIndent += indentStep;
	const itemCtx = Object.assign({}, ctx, {
		indent: itemIndent,
		inFlow: true,
		type: null
	});
	let reqNewline = false;
	let linesAtValue = 0;
	const lines = [];
	for (let i = 0; i < items.length; ++i) {
		const item = items[i];
		let comment = null;
		if (isNode$1(item)) {
			if (item.spaceBefore) lines.push("");
			addCommentBefore(ctx, lines, item.commentBefore, false);
			if (item.comment) comment = item.comment;
		} else if (isPair(item)) {
			const ik = isNode$1(item.key) ? item.key : null;
			if (ik) {
				if (ik.spaceBefore) lines.push("");
				addCommentBefore(ctx, lines, ik.commentBefore, false);
				if (ik.comment) reqNewline = true;
			}
			const iv = isNode$1(item.value) ? item.value : null;
			if (iv) {
				if (iv.comment) comment = iv.comment;
				if (iv.commentBefore) reqNewline = true;
			} else if (item.value == null && ik?.comment) comment = ik.comment;
		}
		if (comment) reqNewline = true;
		let str = stringify$1(item, itemCtx, () => comment = null);
		if (i < items.length - 1) str += ",";
		if (comment) str += lineComment(str, itemIndent, commentString(comment));
		if (!reqNewline && (lines.length > linesAtValue || str.includes("\n"))) reqNewline = true;
		lines.push(str);
		linesAtValue = lines.length;
	}
	const { start, end } = flowChars;
	if (lines.length === 0) return start + end;
	else {
		if (!reqNewline) {
			const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
			reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
		}
		if (reqNewline) {
			let str = start;
			for (const line of lines) str += line ? `\n${indentStep}${indent}${line}` : "\n";
			return `${str}\n${indent}${end}`;
		} else return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
	}
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
	if (comment && chompKeep) comment = comment.replace(/^\n+/, "");
	if (comment) {
		const ic = indentComment(commentString(comment), indent);
		lines.push(ic.trimStart());
	}
}
function findPair(items, key) {
	const k = isScalar(key) ? key.value : key;
	for (const it of items) if (isPair(it)) {
		if (it.key === key || it.key === k) return it;
		if (isScalar(it.key) && it.key.value === k) return it;
	}
}
var YAMLMap = class extends Collection {
	static get tagName() {
		return "tag:yaml.org,2002:map";
	}
	constructor(schema$3) {
		super(MAP, schema$3);
		this.items = [];
	}
	static from(schema$3, obj, ctx) {
		const { keepUndefined, replacer } = ctx;
		const map$1 = new this(schema$3);
		const add = (key, value) => {
			if (typeof replacer === "function") value = replacer.call(obj, key, value);
			else if (Array.isArray(replacer) && !replacer.includes(key)) return;
			if (value !== void 0 || keepUndefined) map$1.items.push(createPair(key, value, ctx));
		};
		if (obj instanceof Map) for (const [key, value] of obj) add(key, value);
		else if (obj && typeof obj === "object") for (const key of Object.keys(obj)) add(key, obj[key]);
		if (typeof schema$3.sortMapEntries === "function") map$1.items.sort(schema$3.sortMapEntries);
		return map$1;
	}
	add(pair, overwrite) {
		let _pair;
		if (isPair(pair)) _pair = pair;
		else if (!pair || typeof pair !== "object" || !("key" in pair)) _pair = new Pair(pair, pair?.value);
		else _pair = new Pair(pair.key, pair.value);
		const prev = findPair(this.items, _pair.key);
		const sortEntries = this.schema?.sortMapEntries;
		if (prev) {
			if (!overwrite) throw new Error(`Key ${_pair.key} already set`);
			if (isScalar(prev.value) && isScalarValue(_pair.value)) prev.value.value = _pair.value;
			else prev.value = _pair.value;
		} else if (sortEntries) {
			const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
			if (i === -1) this.items.push(_pair);
			else this.items.splice(i, 0, _pair);
		} else this.items.push(_pair);
	}
	delete(key) {
		const it = findPair(this.items, key);
		if (!it) return false;
		return this.items.splice(this.items.indexOf(it), 1).length > 0;
	}
	get(key, keepScalar) {
		const node = findPair(this.items, key)?.value;
		return (!keepScalar && isScalar(node) ? node.value : node) ?? void 0;
	}
	has(key) {
		return !!findPair(this.items, key);
	}
	set(key, value) {
		this.add(new Pair(key, value), true);
	}
	toJSON(_, ctx, Type) {
		const map$1 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
		if (ctx?.onCreate) ctx.onCreate(map$1);
		for (const item of this.items) addPairToJSMap(ctx, map$1, item);
		return map$1;
	}
	toString(ctx, onComment, onChompKeep) {
		if (!ctx) return JSON.stringify(this);
		for (const item of this.items) if (!isPair(item)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
		if (!ctx.allNullValues && this.hasAllNullValues(false)) ctx = Object.assign({}, ctx, { allNullValues: true });
		return stringifyCollection(this, ctx, {
			blockItemPrefix: "",
			flowChars: {
				start: "{",
				end: "}"
			},
			itemIndent: ctx.indent || "",
			onChompKeep,
			onComment
		});
	}
};
var map = {
	collection: "map",
	default: true,
	nodeClass: YAMLMap,
	tag: "tag:yaml.org,2002:map",
	resolve(map$1, onError) {
		if (!isMap(map$1)) onError("Expected a mapping for this tag");
		return map$1;
	},
	createNode: (schema$3, obj, ctx) => YAMLMap.from(schema$3, obj, ctx)
};
var YAMLSeq = class extends Collection {
	static get tagName() {
		return "tag:yaml.org,2002:seq";
	}
	constructor(schema$3) {
		super(SEQ, schema$3);
		this.items = [];
	}
	add(value) {
		this.items.push(value);
	}
	delete(key) {
		const idx = asItemIndex(key);
		if (typeof idx !== "number") return false;
		return this.items.splice(idx, 1).length > 0;
	}
	get(key, keepScalar) {
		const idx = asItemIndex(key);
		if (typeof idx !== "number") return void 0;
		const it = this.items[idx];
		return !keepScalar && isScalar(it) ? it.value : it;
	}
	has(key) {
		const idx = asItemIndex(key);
		return typeof idx === "number" && idx < this.items.length;
	}
	set(key, value) {
		const idx = asItemIndex(key);
		if (typeof idx !== "number") throw new Error(`Expected a valid index, not ${key}.`);
		const prev = this.items[idx];
		if (isScalar(prev) && isScalarValue(value)) prev.value = value;
		else this.items[idx] = value;
	}
	toJSON(_, ctx) {
		const seq$1 = [];
		if (ctx?.onCreate) ctx.onCreate(seq$1);
		let i = 0;
		for (const item of this.items) seq$1.push(toJS(item, String(i++), ctx));
		return seq$1;
	}
	toString(ctx, onComment, onChompKeep) {
		if (!ctx) return JSON.stringify(this);
		return stringifyCollection(this, ctx, {
			blockItemPrefix: "- ",
			flowChars: {
				start: "[",
				end: "]"
			},
			itemIndent: (ctx.indent || "") + "  ",
			onChompKeep,
			onComment
		});
	}
	static from(schema$3, obj, ctx) {
		const { replacer } = ctx;
		const seq$1 = new this(schema$3);
		if (obj && Symbol.iterator in Object(obj)) {
			let i = 0;
			for (let it of obj) {
				if (typeof replacer === "function") {
					const key = obj instanceof Set ? it : String(i++);
					it = replacer.call(obj, key, it);
				}
				seq$1.items.push(createNode(it, void 0, ctx));
			}
		}
		return seq$1;
	}
};
function asItemIndex(key) {
	let idx = isScalar(key) ? key.value : key;
	if (idx && typeof idx === "string") idx = Number(idx);
	return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
var seq = {
	collection: "seq",
	default: true,
	nodeClass: YAMLSeq,
	tag: "tag:yaml.org,2002:seq",
	resolve(seq$1, onError) {
		if (!isSeq(seq$1)) onError("Expected a sequence for this tag");
		return seq$1;
	},
	createNode: (schema$3, obj, ctx) => YAMLSeq.from(schema$3, obj, ctx)
};
var string = {
	identify: (value) => typeof value === "string",
	default: true,
	tag: "tag:yaml.org,2002:str",
	resolve: (str) => str,
	stringify(item, ctx, onComment, onChompKeep) {
		ctx = Object.assign({ actualString: true }, ctx);
		return stringifyString(item, ctx, onComment, onChompKeep);
	}
};
var nullTag = {
	identify: (value) => value == null,
	createNode: () => new Scalar(null),
	default: true,
	tag: "tag:yaml.org,2002:null",
	test: /^(?:~|[Nn]ull|NULL)?$/,
	resolve: () => new Scalar(null),
	stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
};
var boolTag = {
	identify: (value) => typeof value === "boolean",
	default: true,
	tag: "tag:yaml.org,2002:bool",
	test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
	resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
	stringify({ source, value }, ctx) {
		if (source && boolTag.test.test(source)) {
			if (value === (source[0] === "t" || source[0] === "T")) return source;
		}
		return value ? ctx.options.trueStr : ctx.options.falseStr;
	}
};
function stringifyNumber({ format: format$1, minFractionDigits, tag, value }) {
	if (typeof value === "bigint") return String(value);
	const num = typeof value === "number" ? value : Number(value);
	if (!isFinite(num)) return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
	let n = Object.is(value, -0) ? "-0" : JSON.stringify(value);
	if (!format$1 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
		let i = n.indexOf(".");
		if (i < 0) {
			i = n.length;
			n += ".";
		}
		let d = minFractionDigits - (n.length - i - 1);
		while (d-- > 0) n += "0";
	}
	return n;
}
var floatNaN = {
	identify: (value) => typeof value === "number",
	default: true,
	tag: "tag:yaml.org,2002:float",
	test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
	resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
	stringify: stringifyNumber
};
var floatExp = {
	identify: (value) => typeof value === "number",
	default: true,
	tag: "tag:yaml.org,2002:float",
	format: "EXP",
	test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
	resolve: (str) => parseFloat(str),
	stringify(node) {
		const num = Number(node.value);
		return isFinite(num) ? num.toExponential() : stringifyNumber(node);
	}
};
var float = {
	identify: (value) => typeof value === "number",
	default: true,
	tag: "tag:yaml.org,2002:float",
	test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
	resolve(str) {
		const node = new Scalar(parseFloat(str));
		const dot = str.indexOf(".");
		if (dot !== -1 && str[str.length - 1] === "0") node.minFractionDigits = str.length - dot - 1;
		return node;
	},
	stringify: stringifyNumber
};
var intIdentify$2 = (value) => typeof value === "bigint" || Number.isInteger(value);
var intResolve$1 = (str, offset$3, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset$3), radix);
function intStringify$1(node, radix, prefix$1) {
	const { value } = node;
	if (intIdentify$2(value) && value >= 0) return prefix$1 + value.toString(radix);
	return stringifyNumber(node);
}
var intOct = {
	identify: (value) => intIdentify$2(value) && value >= 0,
	default: true,
	tag: "tag:yaml.org,2002:int",
	format: "OCT",
	test: /^0o[0-7]+$/,
	resolve: (str, _onError, opt) => intResolve$1(str, 2, 8, opt),
	stringify: (node) => intStringify$1(node, 8, "0o")
};
var int = {
	identify: intIdentify$2,
	default: true,
	tag: "tag:yaml.org,2002:int",
	test: /^[-+]?[0-9]+$/,
	resolve: (str, _onError, opt) => intResolve$1(str, 0, 10, opt),
	stringify: stringifyNumber
};
var intHex = {
	identify: (value) => intIdentify$2(value) && value >= 0,
	default: true,
	tag: "tag:yaml.org,2002:int",
	format: "HEX",
	test: /^0x[0-9a-fA-F]+$/,
	resolve: (str, _onError, opt) => intResolve$1(str, 2, 16, opt),
	stringify: (node) => intStringify$1(node, 16, "0x")
};
var schema = [
	map,
	seq,
	string,
	nullTag,
	boolTag,
	intOct,
	int,
	intHex,
	floatNaN,
	floatExp,
	float
];
function intIdentify$1(value) {
	return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON = ({ value }) => JSON.stringify(value);
var jsonScalars = [
	{
		identify: (value) => typeof value === "string",
		default: true,
		tag: "tag:yaml.org,2002:str",
		resolve: (str) => str,
		stringify: stringifyJSON
	},
	{
		identify: (value) => value == null,
		createNode: () => new Scalar(null),
		default: true,
		tag: "tag:yaml.org,2002:null",
		test: /^null$/,
		resolve: () => null,
		stringify: stringifyJSON
	},
	{
		identify: (value) => typeof value === "boolean",
		default: true,
		tag: "tag:yaml.org,2002:bool",
		test: /^true$|^false$/,
		resolve: (str) => str === "true",
		stringify: stringifyJSON
	},
	{
		identify: intIdentify$1,
		default: true,
		tag: "tag:yaml.org,2002:int",
		test: /^-?(?:0|[1-9][0-9]*)$/,
		resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
		stringify: ({ value }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
	},
	{
		identify: (value) => typeof value === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
		resolve: (str) => parseFloat(str),
		stringify: stringifyJSON
	}
];
var schema$1 = [map, seq].concat(jsonScalars, {
	default: true,
	tag: "",
	test: /^/,
	resolve(str, onError) {
		onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
		return str;
	}
});
var binary = {
	identify: (value) => value instanceof Uint8Array,
	default: false,
	tag: "tag:yaml.org,2002:binary",
	resolve(src, onError) {
		if (typeof atob === "function") {
			const str = atob(src.replace(/[\n\r]/g, ""));
			const buffer = new Uint8Array(str.length);
			for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);
			return buffer;
		} else {
			onError("This environment does not support reading binary tags; either Buffer or atob is required");
			return src;
		}
	},
	stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
		if (!value) return "";
		const buf = value;
		let str;
		if (typeof btoa === "function") {
			let s = "";
			for (let i = 0; i < buf.length; ++i) s += String.fromCharCode(buf[i]);
			str = btoa(s);
		} else throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
		type ?? (type = Scalar.BLOCK_LITERAL);
		if (type !== Scalar.QUOTE_DOUBLE) {
			const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
			const n = Math.ceil(str.length / lineWidth);
			const lines = new Array(n);
			for (let i = 0, o = 0; i < n; ++i, o += lineWidth) lines[i] = str.substr(o, lineWidth);
			str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
		}
		return stringifyString({
			comment,
			type,
			value: str
		}, ctx, onComment, onChompKeep);
	}
};
function resolvePairs(seq$1, onError) {
	if (isSeq(seq$1)) for (let i = 0; i < seq$1.items.length; ++i) {
		let item = seq$1.items[i];
		if (isPair(item)) continue;
		else if (isMap(item)) {
			if (item.items.length > 1) onError("Each pair must have its own sequence indicator");
			const pair = item.items[0] || new Pair(new Scalar(null));
			if (item.commentBefore) pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}\n${pair.key.commentBefore}` : item.commentBefore;
			if (item.comment) {
				const cn = pair.value ?? pair.key;
				cn.comment = cn.comment ? `${item.comment}\n${cn.comment}` : item.comment;
			}
			item = pair;
		}
		seq$1.items[i] = isPair(item) ? item : new Pair(item);
	}
	else onError("Expected a sequence for this tag");
	return seq$1;
}
function createPairs(schema$3, iterable, ctx) {
	const { replacer } = ctx;
	const pairs$1 = new YAMLSeq(schema$3);
	pairs$1.tag = "tag:yaml.org,2002:pairs";
	let i = 0;
	if (iterable && Symbol.iterator in Object(iterable)) for (let it of iterable) {
		if (typeof replacer === "function") it = replacer.call(iterable, String(i++), it);
		let key, value;
		if (Array.isArray(it)) if (it.length === 2) {
			key = it[0];
			value = it[1];
		} else throw new TypeError(`Expected [key, value] tuple: ${it}`);
		else if (it && it instanceof Object) {
			const keys$1 = Object.keys(it);
			if (keys$1.length === 1) {
				key = keys$1[0];
				value = it[key];
			} else throw new TypeError(`Expected tuple with one key, not ${keys$1.length} keys`);
		} else key = it;
		pairs$1.items.push(createPair(key, value, ctx));
	}
	return pairs$1;
}
var pairs = {
	collection: "seq",
	default: false,
	tag: "tag:yaml.org,2002:pairs",
	resolve: resolvePairs,
	createNode: createPairs
};
var YAMLOMap = class YAMLOMap extends YAMLSeq {
	constructor() {
		super();
		this.add = YAMLMap.prototype.add.bind(this);
		this.delete = YAMLMap.prototype.delete.bind(this);
		this.get = YAMLMap.prototype.get.bind(this);
		this.has = YAMLMap.prototype.has.bind(this);
		this.set = YAMLMap.prototype.set.bind(this);
		this.tag = YAMLOMap.tag;
	}
	toJSON(_, ctx) {
		if (!ctx) return super.toJSON(_);
		const map$1 = /* @__PURE__ */ new Map();
		if (ctx?.onCreate) ctx.onCreate(map$1);
		for (const pair of this.items) {
			let key, value;
			if (isPair(pair)) {
				key = toJS(pair.key, "", ctx);
				value = toJS(pair.value, key, ctx);
			} else key = toJS(pair, "", ctx);
			if (map$1.has(key)) throw new Error("Ordered maps must not include duplicate keys");
			map$1.set(key, value);
		}
		return map$1;
	}
	static from(schema$3, iterable, ctx) {
		const pairs$1 = createPairs(schema$3, iterable, ctx);
		const omap$1 = new this();
		omap$1.items = pairs$1.items;
		return omap$1;
	}
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
	collection: "seq",
	identify: (value) => value instanceof Map,
	nodeClass: YAMLOMap,
	default: false,
	tag: "tag:yaml.org,2002:omap",
	resolve(seq$1, onError) {
		const pairs$1 = resolvePairs(seq$1, onError);
		const seenKeys = [];
		for (const { key } of pairs$1.items) if (isScalar(key)) if (seenKeys.includes(key.value)) onError(`Ordered maps must not include duplicate keys: ${key.value}`);
		else seenKeys.push(key.value);
		return Object.assign(new YAMLOMap(), pairs$1);
	},
	createNode: (schema$3, iterable, ctx) => YAMLOMap.from(schema$3, iterable, ctx)
};
function boolStringify({ value, source }, ctx) {
	if (source && (value ? trueTag : falseTag).test.test(source)) return source;
	return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag = {
	identify: (value) => value === true,
	default: true,
	tag: "tag:yaml.org,2002:bool",
	test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
	resolve: () => new Scalar(true),
	stringify: boolStringify
};
var falseTag = {
	identify: (value) => value === false,
	default: true,
	tag: "tag:yaml.org,2002:bool",
	test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
	resolve: () => new Scalar(false),
	stringify: boolStringify
};
var floatNaN$1 = {
	identify: (value) => typeof value === "number",
	default: true,
	tag: "tag:yaml.org,2002:float",
	test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
	resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
	stringify: stringifyNumber
};
var floatExp$1 = {
	identify: (value) => typeof value === "number",
	default: true,
	tag: "tag:yaml.org,2002:float",
	format: "EXP",
	test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
	resolve: (str) => parseFloat(str.replace(/_/g, "")),
	stringify(node) {
		const num = Number(node.value);
		return isFinite(num) ? num.toExponential() : stringifyNumber(node);
	}
};
var float$1 = {
	identify: (value) => typeof value === "number",
	default: true,
	tag: "tag:yaml.org,2002:float",
	test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
	resolve(str) {
		const node = new Scalar(parseFloat(str.replace(/_/g, "")));
		const dot = str.indexOf(".");
		if (dot !== -1) {
			const f = str.substring(dot + 1).replace(/_/g, "");
			if (f[f.length - 1] === "0") node.minFractionDigits = f.length;
		}
		return node;
	},
	stringify: stringifyNumber
};
var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve(str, offset$3, radix, { intAsBigInt }) {
	const sign = str[0];
	if (sign === "-" || sign === "+") offset$3 += 1;
	str = str.substring(offset$3).replace(/_/g, "");
	if (intAsBigInt) {
		switch (radix) {
			case 2:
				str = `0b${str}`;
				break;
			case 8:
				str = `0o${str}`;
				break;
			case 16:
				str = `0x${str}`;
				break;
		}
		const n$1 = BigInt(str);
		return sign === "-" ? BigInt(-1) * n$1 : n$1;
	}
	const n = parseInt(str, radix);
	return sign === "-" ? -1 * n : n;
}
function intStringify(node, radix, prefix$1) {
	const { value } = node;
	if (intIdentify(value)) {
		const str = value.toString(radix);
		return value < 0 ? "-" + prefix$1 + str.substr(1) : prefix$1 + str;
	}
	return stringifyNumber(node);
}
var intBin = {
	identify: intIdentify,
	default: true,
	tag: "tag:yaml.org,2002:int",
	format: "BIN",
	test: /^[-+]?0b[0-1_]+$/,
	resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
	stringify: (node) => intStringify(node, 2, "0b")
};
var intOct$1 = {
	identify: intIdentify,
	default: true,
	tag: "tag:yaml.org,2002:int",
	format: "OCT",
	test: /^[-+]?0[0-7_]+$/,
	resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
	stringify: (node) => intStringify(node, 8, "0")
};
var int$1 = {
	identify: intIdentify,
	default: true,
	tag: "tag:yaml.org,2002:int",
	test: /^[-+]?[0-9][0-9_]*$/,
	resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
	stringify: stringifyNumber
};
var intHex$1 = {
	identify: intIdentify,
	default: true,
	tag: "tag:yaml.org,2002:int",
	format: "HEX",
	test: /^[-+]?0x[0-9a-fA-F_]+$/,
	resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
	stringify: (node) => intStringify(node, 16, "0x")
};
var YAMLSet = class YAMLSet extends YAMLMap {
	constructor(schema$3) {
		super(schema$3);
		this.tag = YAMLSet.tag;
	}
	add(key) {
		let pair;
		if (isPair(key)) pair = key;
		else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null) pair = new Pair(key.key, null);
		else pair = new Pair(key, null);
		if (!findPair(this.items, pair.key)) this.items.push(pair);
	}
	get(key, keepPair) {
		const pair = findPair(this.items, key);
		return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
	}
	set(key, value) {
		if (typeof value !== "boolean") throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
		const prev = findPair(this.items, key);
		if (prev && !value) this.items.splice(this.items.indexOf(prev), 1);
		else if (!prev && value) this.items.push(new Pair(key));
	}
	toJSON(_, ctx) {
		return super.toJSON(_, ctx, Set);
	}
	toString(ctx, onComment, onChompKeep) {
		if (!ctx) return JSON.stringify(this);
		if (this.hasAllNullValues(true)) return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
		else throw new Error("Set items must all have null values");
	}
	static from(schema$3, iterable, ctx) {
		const { replacer } = ctx;
		const set$1 = new this(schema$3);
		if (iterable && Symbol.iterator in Object(iterable)) for (let value of iterable) {
			if (typeof replacer === "function") value = replacer.call(iterable, value, value);
			set$1.items.push(createPair(value, null, ctx));
		}
		return set$1;
	}
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
	collection: "map",
	identify: (value) => value instanceof Set,
	nodeClass: YAMLSet,
	default: false,
	tag: "tag:yaml.org,2002:set",
	createNode: (schema$3, iterable, ctx) => YAMLSet.from(schema$3, iterable, ctx),
	resolve(map$1, onError) {
		if (isMap(map$1)) if (map$1.hasAllNullValues(true)) return Object.assign(new YAMLSet(), map$1);
		else onError("Set items must all have null values");
		else onError("Expected a mapping for this tag");
		return map$1;
	}
};
function parseSexagesimal(str, asBigInt) {
	const sign = str[0];
	const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
	const num = (n) => asBigInt ? BigInt(n) : Number(n);
	const res = parts.replace(/_/g, "").split(":").reduce((res$1, p) => res$1 * num(60) + num(p), num(0));
	return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
	let { value } = node;
	let num = (n) => n;
	if (typeof value === "bigint") num = (n) => BigInt(n);
	else if (isNaN(value) || !isFinite(value)) return stringifyNumber(node);
	let sign = "";
	if (value < 0) {
		sign = "-";
		value *= num(-1);
	}
	const _60 = num(60);
	const parts = [value % _60];
	if (value < 60) parts.unshift(0);
	else {
		value = (value - parts[0]) / _60;
		parts.unshift(value % _60);
		if (value >= 60) {
			value = (value - parts[0]) / _60;
			parts.unshift(value);
		}
	}
	return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
var intTime = {
	identify: (value) => typeof value === "bigint" || Number.isInteger(value),
	default: true,
	tag: "tag:yaml.org,2002:int",
	format: "TIME",
	test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
	resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
	stringify: stringifySexagesimal
};
var floatTime = {
	identify: (value) => typeof value === "number",
	default: true,
	tag: "tag:yaml.org,2002:float",
	format: "TIME",
	test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
	resolve: (str) => parseSexagesimal(str, false),
	stringify: stringifySexagesimal
};
var timestamp = {
	identify: (value) => value instanceof Date,
	default: true,
	tag: "tag:yaml.org,2002:timestamp",
	test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
	resolve(str) {
		const match = str.match(timestamp.test);
		if (!match) throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
		const [, year, month, day, hour, minute, second] = match.map(Number);
		const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
		let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
		const tz = match[8];
		if (tz && tz !== "Z") {
			let d = parseSexagesimal(tz, false);
			if (Math.abs(d) < 30) d *= 60;
			date -= 6e4 * d;
		}
		return new Date(date);
	},
	stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
};
var schema$2 = [
	map,
	seq,
	string,
	nullTag,
	trueTag,
	falseTag,
	intBin,
	intOct$1,
	int$1,
	intHex$1,
	floatNaN$1,
	floatExp$1,
	float$1,
	binary,
	merge,
	omap,
	pairs,
	set,
	intTime,
	floatTime,
	timestamp
];
var schemas = new Map([
	["core", schema],
	["failsafe", [
		map,
		seq,
		string
	]],
	["json", schema$1],
	["yaml11", schema$2],
	["yaml-1.1", schema$2]
]);
var tagsByName = {
	binary,
	bool: boolTag,
	float,
	floatExp,
	floatNaN,
	floatTime,
	int,
	intHex,
	intOct,
	intTime,
	map,
	merge,
	null: nullTag,
	omap,
	pairs,
	seq,
	set,
	timestamp
};
var coreKnownTags = {
	"tag:yaml.org,2002:binary": binary,
	"tag:yaml.org,2002:merge": merge,
	"tag:yaml.org,2002:omap": omap,
	"tag:yaml.org,2002:pairs": pairs,
	"tag:yaml.org,2002:set": set,
	"tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName, addMergeTag) {
	const schemaTags = schemas.get(schemaName);
	if (schemaTags && !customTags) return addMergeTag && !schemaTags.includes(merge) ? schemaTags.concat(merge) : schemaTags.slice();
	let tags = schemaTags;
	if (!tags) if (Array.isArray(customTags)) tags = [];
	else {
		const keys$1 = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
		throw new Error(`Unknown schema "${schemaName}"; use one of ${keys$1} or define customTags array`);
	}
	if (Array.isArray(customTags)) for (const tag of customTags) tags = tags.concat(tag);
	else if (typeof customTags === "function") tags = customTags(tags.slice());
	if (addMergeTag) tags = tags.concat(merge);
	return tags.reduce((tags$1, tag) => {
		const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
		if (!tagObj) {
			const tagName = JSON.stringify(tag);
			const keys$1 = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
			throw new Error(`Unknown custom tag ${tagName}; use one of ${keys$1}`);
		}
		if (!tags$1.includes(tagObj)) tags$1.push(tagObj);
		return tags$1;
	}, []);
}
var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
var Schema = class Schema {
	constructor({ compat, customTags, merge: merge$1, resolveKnownTags, schema: schema$3, sortMapEntries, toStringDefaults }) {
		this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
		this.name = typeof schema$3 === "string" && schema$3 || "core";
		this.knownTags = resolveKnownTags ? coreKnownTags : {};
		this.tags = getTags(customTags, this.name, merge$1);
		this.toStringOptions = toStringDefaults ?? null;
		Object.defineProperty(this, MAP, { value: map });
		Object.defineProperty(this, SCALAR$1, { value: string });
		Object.defineProperty(this, SEQ, { value: seq });
		this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
	}
	clone() {
		const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
		copy.tags = this.tags.slice();
		return copy;
	}
};
function stringifyDocument(doc, options$1) {
	const lines = [];
	let hasDirectives = options$1.directives === true;
	if (options$1.directives !== false && doc.directives) {
		const dir = doc.directives.toString(doc);
		if (dir) {
			lines.push(dir);
			hasDirectives = true;
		} else if (doc.directives.docStart) hasDirectives = true;
	}
	if (hasDirectives) lines.push("---");
	const ctx = createStringifyContext(doc, options$1);
	const { commentString } = ctx.options;
	if (doc.commentBefore) {
		if (lines.length !== 1) lines.unshift("");
		const cs = commentString(doc.commentBefore);
		lines.unshift(indentComment(cs, ""));
	}
	let chompKeep = false;
	let contentComment = null;
	if (doc.contents) {
		if (isNode$1(doc.contents)) {
			if (doc.contents.spaceBefore && hasDirectives) lines.push("");
			if (doc.contents.commentBefore) {
				const cs = commentString(doc.contents.commentBefore);
				lines.push(indentComment(cs, ""));
			}
			ctx.forceBlockIndent = !!doc.comment;
			contentComment = doc.contents.comment;
		}
		const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
		let body = stringify$1(doc.contents, ctx, () => contentComment = null, onChompKeep);
		if (contentComment) body += lineComment(body, "", commentString(contentComment));
		if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") lines[lines.length - 1] = `--- ${body}`;
		else lines.push(body);
	} else lines.push(stringify$1(doc.contents, ctx));
	if (doc.directives?.docEnd) if (doc.comment) {
		const cs = commentString(doc.comment);
		if (cs.includes("\n")) {
			lines.push("...");
			lines.push(indentComment(cs, ""));
		} else lines.push(`... ${cs}`);
	} else lines.push("...");
	else {
		let dc = doc.comment;
		if (dc && chompKeep) dc = dc.replace(/^\n+/, "");
		if (dc) {
			if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "") lines.push("");
			lines.push(indentComment(commentString(dc), ""));
		}
	}
	return lines.join("\n") + "\n";
}
var Document$1 = class Document$1 {
	constructor(value, replacer, options$1) {
		this.commentBefore = null;
		this.comment = null;
		this.errors = [];
		this.warnings = [];
		Object.defineProperty(this, NODE_TYPE, { value: DOC });
		let _replacer = null;
		if (typeof replacer === "function" || Array.isArray(replacer)) _replacer = replacer;
		else if (options$1 === void 0 && replacer) {
			options$1 = replacer;
			replacer = void 0;
		}
		const opt = Object.assign({
			intAsBigInt: false,
			keepSourceTokens: false,
			logLevel: "warn",
			prettyErrors: true,
			strict: true,
			stringKeys: false,
			uniqueKeys: true,
			version: "1.2"
		}, options$1);
		this.options = opt;
		let { version } = opt;
		if (options$1?._directives) {
			this.directives = options$1._directives.atDocument();
			if (this.directives.yaml.explicit) version = this.directives.yaml.version;
		} else this.directives = new Directives({ version });
		this.setSchema(version, options$1);
		this.contents = value === void 0 ? null : this.createNode(value, _replacer, options$1);
	}
	clone() {
		const copy = Object.create(Document$1.prototype, { [NODE_TYPE]: { value: DOC } });
		copy.commentBefore = this.commentBefore;
		copy.comment = this.comment;
		copy.errors = this.errors.slice();
		copy.warnings = this.warnings.slice();
		copy.options = Object.assign({}, this.options);
		if (this.directives) copy.directives = this.directives.clone();
		copy.schema = this.schema.clone();
		copy.contents = isNode$1(this.contents) ? this.contents.clone(copy.schema) : this.contents;
		if (this.range) copy.range = this.range.slice();
		return copy;
	}
	add(value) {
		if (assertCollection(this.contents)) this.contents.add(value);
	}
	addIn(path, value) {
		if (assertCollection(this.contents)) this.contents.addIn(path, value);
	}
	createAlias(node, name) {
		if (!node.anchor) {
			const prev = anchorNames(this);
			node.anchor = !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
		}
		return new Alias(node.anchor);
	}
	createNode(value, replacer, options$1) {
		let _replacer = void 0;
		if (typeof replacer === "function") {
			value = replacer.call({ "": value }, "", value);
			_replacer = replacer;
		} else if (Array.isArray(replacer)) {
			const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
			const asStr = replacer.filter(keyToStr).map(String);
			if (asStr.length > 0) replacer = replacer.concat(asStr);
			_replacer = replacer;
		} else if (options$1 === void 0 && replacer) {
			options$1 = replacer;
			replacer = void 0;
		}
		const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options$1 ?? {};
		const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, anchorPrefix || "a");
		const ctx = {
			aliasDuplicateObjects: aliasDuplicateObjects ?? true,
			keepUndefined: keepUndefined ?? false,
			onAnchor,
			onTagObj,
			replacer: _replacer,
			schema: this.schema,
			sourceObjects
		};
		const node = createNode(value, tag, ctx);
		if (flow && isCollection(node)) node.flow = true;
		setAnchors();
		return node;
	}
	createPair(key, value, options$1 = {}) {
		return new Pair(this.createNode(key, null, options$1), this.createNode(value, null, options$1));
	}
	delete(key) {
		return assertCollection(this.contents) ? this.contents.delete(key) : false;
	}
	deleteIn(path) {
		if (isEmptyPath(path)) {
			if (this.contents == null) return false;
			this.contents = null;
			return true;
		}
		return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
	}
	get(key, keepScalar) {
		return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
	}
	getIn(path, keepScalar) {
		if (isEmptyPath(path)) return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
		return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
	}
	has(key) {
		return isCollection(this.contents) ? this.contents.has(key) : false;
	}
	hasIn(path) {
		if (isEmptyPath(path)) return this.contents !== void 0;
		return isCollection(this.contents) ? this.contents.hasIn(path) : false;
	}
	set(key, value) {
		if (this.contents == null) this.contents = collectionFromPath(this.schema, [key], value);
		else if (assertCollection(this.contents)) this.contents.set(key, value);
	}
	setIn(path, value) {
		if (isEmptyPath(path)) this.contents = value;
		else if (this.contents == null) this.contents = collectionFromPath(this.schema, Array.from(path), value);
		else if (assertCollection(this.contents)) this.contents.setIn(path, value);
	}
	setSchema(version, options$1 = {}) {
		if (typeof version === "number") version = String(version);
		let opt;
		switch (version) {
			case "1.1":
				if (this.directives) this.directives.yaml.version = "1.1";
				else this.directives = new Directives({ version: "1.1" });
				opt = {
					resolveKnownTags: false,
					schema: "yaml-1.1"
				};
				break;
			case "1.2":
			case "next":
				if (this.directives) this.directives.yaml.version = version;
				else this.directives = new Directives({ version });
				opt = {
					resolveKnownTags: true,
					schema: "core"
				};
				break;
			case null:
				if (this.directives) delete this.directives;
				opt = null;
				break;
			default: {
				const sv = JSON.stringify(version);
				throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
			}
		}
		if (options$1.schema instanceof Object) this.schema = options$1.schema;
		else if (opt) this.schema = new Schema(Object.assign(opt, options$1));
		else throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
	}
	toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
		const ctx = {
			anchors: /* @__PURE__ */ new Map(),
			doc: this,
			keep: !json,
			mapAsMap: mapAsMap === true,
			mapKeyWarned: false,
			maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
		};
		const res = toJS(this.contents, jsonArg ?? "", ctx);
		if (typeof onAnchor === "function") for (const { count: count$1, res: res$1 } of ctx.anchors.values()) onAnchor(res$1, count$1);
		return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
	}
	toJSON(jsonArg, onAnchor) {
		return this.toJS({
			json: true,
			jsonArg,
			mapAsMap: false,
			onAnchor
		});
	}
	toString(options$1 = {}) {
		if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
		if ("indent" in options$1 && (!Number.isInteger(options$1.indent) || Number(options$1.indent) <= 0)) {
			const s = JSON.stringify(options$1.indent);
			throw new Error(`"indent" option must be a positive integer, not ${s}`);
		}
		return stringifyDocument(this, options$1);
	}
};
function assertCollection(contents) {
	if (isCollection(contents)) return true;
	throw new Error("Expected a YAML collection as document contents");
}
var YAMLError = class extends Error {
	constructor(name, pos, code, message) {
		super();
		this.name = name;
		this.code = code;
		this.message = message;
		this.pos = pos;
	}
};
var YAMLParseError = class extends YAMLError {
	constructor(pos, code, message) {
		super("YAMLParseError", pos, code, message);
	}
};
var YAMLWarning = class extends YAMLError {
	constructor(pos, code, message) {
		super("YAMLWarning", pos, code, message);
	}
};
var prettifyError = (src, lc) => (error) => {
	if (error.pos[0] === -1) return;
	error.linePos = error.pos.map((pos) => lc.linePos(pos));
	const { line, col } = error.linePos[0];
	error.message += ` at line ${line}, column ${col}`;
	let ci = col - 1;
	let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
	if (ci >= 60 && lineStr.length > 80) {
		const trimStart = Math.min(ci - 39, lineStr.length - 79);
		lineStr = "" + lineStr.substring(trimStart);
		ci -= trimStart - 1;
	}
	if (lineStr.length > 80) lineStr = lineStr.substring(0, 79) + "";
	if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
		let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
		if (prev.length > 80) prev = prev.substring(0, 79) + "\n";
		lineStr = prev + lineStr;
	}
	if (/[^ ]/.test(lineStr)) {
		let count$1 = 1;
		const end = error.linePos[1];
		if (end?.line === line && end.col > col) count$1 = Math.max(1, Math.min(end.col - col, 80 - ci));
		const pointer = " ".repeat(ci) + "^".repeat(count$1);
		error.message += `:\n\n${lineStr}\n${pointer}\n`;
	}
};
function resolveProps(tokens, { flow, indicator, next, offset: offset$3, onError, parentIndent, startOnNewline }) {
	let spaceBefore = false;
	let atNewline = startOnNewline;
	let hasSpace = startOnNewline;
	let comment = "";
	let commentSep = "";
	let hasNewline = false;
	let reqSpace = false;
	let tab = null;
	let anchor = null;
	let tag = null;
	let newlineAfterProp = null;
	let comma = null;
	let found = null;
	let start = null;
	for (const token of tokens) {
		if (reqSpace) {
			if (token.type !== "space" && token.type !== "newline" && token.type !== "comma") onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
			reqSpace = false;
		}
		if (tab) {
			if (atNewline && token.type !== "comment" && token.type !== "newline") onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
			tab = null;
		}
		switch (token.type) {
			case "space":
				if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) tab = token;
				hasSpace = true;
				break;
			case "comment": {
				if (!hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
				const cb = token.source.substring(1) || " ";
				if (!comment) comment = cb;
				else comment += commentSep + cb;
				commentSep = "";
				atNewline = false;
				break;
			}
			case "newline":
				if (atNewline) {
					if (comment) comment += token.source;
					else if (!found || indicator !== "seq-item-ind") spaceBefore = true;
				} else commentSep += token.source;
				atNewline = true;
				hasNewline = true;
				if (anchor || tag) newlineAfterProp = token;
				hasSpace = true;
				break;
			case "anchor":
				if (anchor) onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
				if (token.source.endsWith(":")) onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
				anchor = token;
				start ?? (start = token.offset);
				atNewline = false;
				hasSpace = false;
				reqSpace = true;
				break;
			case "tag":
				if (tag) onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
				tag = token;
				start ?? (start = token.offset);
				atNewline = false;
				hasSpace = false;
				reqSpace = true;
				break;
			case indicator:
				if (anchor || tag) onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
				if (found) onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
				found = token;
				atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
				hasSpace = false;
				break;
			case "comma": if (flow) {
				if (comma) onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
				comma = token;
				atNewline = false;
				hasSpace = false;
				break;
			}
			default:
				onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
				atNewline = false;
				hasSpace = false;
		}
	}
	const last = tokens[tokens.length - 1];
	const end = last ? last.offset + last.source.length : offset$3;
	if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
	if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq")) onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
	return {
		comma,
		found,
		spaceBefore,
		comment,
		hasNewline,
		anchor,
		tag,
		newlineAfterProp,
		end,
		start: start ?? end
	};
}
function containsNewline(key) {
	if (!key) return null;
	switch (key.type) {
		case "alias":
		case "scalar":
		case "double-quoted-scalar":
		case "single-quoted-scalar":
			if (key.source.includes("\n")) return true;
			if (key.end) {
				for (const st of key.end) if (st.type === "newline") return true;
			}
			return false;
		case "flow-collection":
			for (const it of key.items) {
				for (const st of it.start) if (st.type === "newline") return true;
				if (it.sep) {
					for (const st of it.sep) if (st.type === "newline") return true;
				}
				if (containsNewline(it.key) || containsNewline(it.value)) return true;
			}
			return false;
		default: return true;
	}
}
function flowIndentCheck(indent, fc, onError) {
	if (fc?.type === "flow-collection") {
		const end = fc.end[0];
		if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) onError(end, "BAD_INDENT", "Flow end indicator should be more indented than parent", true);
	}
}
function mapIncludes(ctx, items, search) {
	const { uniqueKeys } = ctx.options;
	if (uniqueKeys === false) return false;
	const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value;
	return items.some((pair) => isEqual(pair.key, search));
}
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode$1, composeEmptyNode: composeEmptyNode$1 }, ctx, bm, onError, tag) {
	const map$1 = new (tag?.nodeClass ?? YAMLMap)(ctx.schema);
	if (ctx.atRoot) ctx.atRoot = false;
	let offset$3 = bm.offset;
	let commentEnd = null;
	for (const collItem of bm.items) {
		const { start, key, sep, value } = collItem;
		const keyProps = resolveProps(start, {
			indicator: "explicit-key-ind",
			next: key ?? sep?.[0],
			offset: offset$3,
			onError,
			parentIndent: bm.indent,
			startOnNewline: true
		});
		const implicitKey = !keyProps.found;
		if (implicitKey) {
			if (key) {
				if (key.type === "block-seq") onError(offset$3, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
				else if ("indent" in key && key.indent !== bm.indent) onError(offset$3, "BAD_INDENT", startColMsg);
			}
			if (!keyProps.anchor && !keyProps.tag && !sep) {
				commentEnd = keyProps.end;
				if (keyProps.comment) if (map$1.comment) map$1.comment += "\n" + keyProps.comment;
				else map$1.comment = keyProps.comment;
				continue;
			}
			if (keyProps.newlineAfterProp || containsNewline(key)) onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
		} else if (keyProps.found?.indent !== bm.indent) onError(offset$3, "BAD_INDENT", startColMsg);
		ctx.atKey = true;
		const keyStart = keyProps.end;
		const keyNode = key ? composeNode$1(ctx, key, keyProps, onError) : composeEmptyNode$1(ctx, keyStart, start, null, keyProps, onError);
		if (ctx.schema.compat) flowIndentCheck(bm.indent, key, onError);
		ctx.atKey = false;
		if (mapIncludes(ctx, map$1.items, keyNode)) onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
		const valueProps = resolveProps(sep ?? [], {
			indicator: "map-value-ind",
			next: value,
			offset: keyNode.range[2],
			onError,
			parentIndent: bm.indent,
			startOnNewline: !key || key.type === "block-scalar"
		});
		offset$3 = valueProps.end;
		if (valueProps.found) {
			if (implicitKey) {
				if (value?.type === "block-map" && !valueProps.hasNewline) onError(offset$3, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
				if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024) onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
			}
			const valueNode = value ? composeNode$1(ctx, value, valueProps, onError) : composeEmptyNode$1(ctx, offset$3, sep, null, valueProps, onError);
			if (ctx.schema.compat) flowIndentCheck(bm.indent, value, onError);
			offset$3 = valueNode.range[2];
			const pair = new Pair(keyNode, valueNode);
			if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
			map$1.items.push(pair);
		} else {
			if (implicitKey) onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
			if (valueProps.comment) if (keyNode.comment) keyNode.comment += "\n" + valueProps.comment;
			else keyNode.comment = valueProps.comment;
			const pair = new Pair(keyNode);
			if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
			map$1.items.push(pair);
		}
	}
	if (commentEnd && commentEnd < offset$3) onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
	map$1.range = [
		bm.offset,
		offset$3,
		commentEnd ?? offset$3
	];
	return map$1;
}
function resolveBlockSeq({ composeNode: composeNode$1, composeEmptyNode: composeEmptyNode$1 }, ctx, bs, onError, tag) {
	const seq$1 = new (tag?.nodeClass ?? YAMLSeq)(ctx.schema);
	if (ctx.atRoot) ctx.atRoot = false;
	if (ctx.atKey) ctx.atKey = false;
	let offset$3 = bs.offset;
	let commentEnd = null;
	for (const { start, value } of bs.items) {
		const props = resolveProps(start, {
			indicator: "seq-item-ind",
			next: value,
			offset: offset$3,
			onError,
			parentIndent: bs.indent,
			startOnNewline: true
		});
		if (!props.found) if (props.anchor || props.tag || value) if (value?.type === "block-seq") onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
		else onError(offset$3, "MISSING_CHAR", "Sequence item without - indicator");
		else {
			commentEnd = props.end;
			if (props.comment) seq$1.comment = props.comment;
			continue;
		}
		const node = value ? composeNode$1(ctx, value, props, onError) : composeEmptyNode$1(ctx, props.end, start, null, props, onError);
		if (ctx.schema.compat) flowIndentCheck(bs.indent, value, onError);
		offset$3 = node.range[2];
		seq$1.items.push(node);
	}
	seq$1.range = [
		bs.offset,
		offset$3,
		commentEnd ?? offset$3
	];
	return seq$1;
}
function resolveEnd(end, offset$3, reqSpace, onError) {
	let comment = "";
	if (end) {
		let hasSpace = false;
		let sep = "";
		for (const token of end) {
			const { source, type } = token;
			switch (type) {
				case "space":
					hasSpace = true;
					break;
				case "comment": {
					if (reqSpace && !hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
					const cb = source.substring(1) || " ";
					if (!comment) comment = cb;
					else comment += sep + cb;
					sep = "";
					break;
				}
				case "newline":
					if (comment) sep += source;
					hasSpace = true;
					break;
				default: onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
			}
			offset$3 += source.length;
		}
	}
	return {
		comment,
		offset: offset$3
	};
}
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode$1, composeEmptyNode: composeEmptyNode$1 }, ctx, fc, onError, tag) {
	const isMap$1 = fc.start.source === "{";
	const fcName = isMap$1 ? "flow map" : "flow sequence";
	const coll = new (tag?.nodeClass ?? (isMap$1 ? YAMLMap : YAMLSeq))(ctx.schema);
	coll.flow = true;
	const atRoot = ctx.atRoot;
	if (atRoot) ctx.atRoot = false;
	if (ctx.atKey) ctx.atKey = false;
	let offset$3 = fc.offset + fc.start.source.length;
	for (let i = 0; i < fc.items.length; ++i) {
		const collItem = fc.items[i];
		const { start, key, sep, value } = collItem;
		const props = resolveProps(start, {
			flow: fcName,
			indicator: "explicit-key-ind",
			next: key ?? sep?.[0],
			offset: offset$3,
			onError,
			parentIndent: fc.indent,
			startOnNewline: false
		});
		if (!props.found) {
			if (!props.anchor && !props.tag && !sep && !value) {
				if (i === 0 && props.comma) onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
				else if (i < fc.items.length - 1) onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
				if (props.comment) if (coll.comment) coll.comment += "\n" + props.comment;
				else coll.comment = props.comment;
				offset$3 = props.end;
				continue;
			}
			if (!isMap$1 && ctx.options.strict && containsNewline(key)) onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
		}
		if (i === 0) {
			if (props.comma) onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
		} else {
			if (!props.comma) onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
			if (props.comment) {
				let prevItemComment = "";
				loop: for (const st of start) switch (st.type) {
					case "comma":
					case "space": break;
					case "comment":
						prevItemComment = st.source.substring(1);
						break loop;
					default: break loop;
				}
				if (prevItemComment) {
					let prev = coll.items[coll.items.length - 1];
					if (isPair(prev)) prev = prev.value ?? prev.key;
					if (prev.comment) prev.comment += "\n" + prevItemComment;
					else prev.comment = prevItemComment;
					props.comment = props.comment.substring(prevItemComment.length + 1);
				}
			}
		}
		if (!isMap$1 && !sep && !props.found) {
			const valueNode = value ? composeNode$1(ctx, value, props, onError) : composeEmptyNode$1(ctx, props.end, sep, null, props, onError);
			coll.items.push(valueNode);
			offset$3 = valueNode.range[2];
			if (isBlock(value)) onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
		} else {
			ctx.atKey = true;
			const keyStart = props.end;
			const keyNode = key ? composeNode$1(ctx, key, props, onError) : composeEmptyNode$1(ctx, keyStart, start, null, props, onError);
			if (isBlock(key)) onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
			ctx.atKey = false;
			const valueProps = resolveProps(sep ?? [], {
				flow: fcName,
				indicator: "map-value-ind",
				next: value,
				offset: keyNode.range[2],
				onError,
				parentIndent: fc.indent,
				startOnNewline: false
			});
			if (valueProps.found) {
				if (!isMap$1 && !props.found && ctx.options.strict) {
					if (sep) for (const st of sep) {
						if (st === valueProps.found) break;
						if (st.type === "newline") {
							onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
							break;
						}
					}
					if (props.start < valueProps.found.offset - 1024) onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
				}
			} else if (value) if ("source" in value && value.source?.[0] === ":") onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
			else onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
			const valueNode = value ? composeNode$1(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode$1(ctx, valueProps.end, sep, null, valueProps, onError) : null;
			if (valueNode) {
				if (isBlock(value)) onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
			} else if (valueProps.comment) if (keyNode.comment) keyNode.comment += "\n" + valueProps.comment;
			else keyNode.comment = valueProps.comment;
			const pair = new Pair(keyNode, valueNode);
			if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
			if (isMap$1) {
				const map$1 = coll;
				if (mapIncludes(ctx, map$1.items, keyNode)) onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
				map$1.items.push(pair);
			} else {
				const map$1 = new YAMLMap(ctx.schema);
				map$1.flow = true;
				map$1.items.push(pair);
				const endRange = (valueNode ?? keyNode).range;
				map$1.range = [
					keyNode.range[0],
					endRange[1],
					endRange[2]
				];
				coll.items.push(map$1);
			}
			offset$3 = valueNode ? valueNode.range[2] : valueProps.end;
		}
	}
	const expectedEnd = isMap$1 ? "}" : "]";
	const [ce, ...ee] = fc.end;
	let cePos = offset$3;
	if (ce?.source === expectedEnd) cePos = ce.offset + ce.source.length;
	else {
		const name = fcName[0].toUpperCase() + fcName.substring(1);
		const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
		onError(offset$3, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
		if (ce && ce.source.length !== 1) ee.unshift(ce);
	}
	if (ee.length > 0) {
		const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
		if (end.comment) if (coll.comment) coll.comment += "\n" + end.comment;
		else coll.comment = end.comment;
		coll.range = [
			fc.offset,
			cePos,
			end.offset
		];
	} else coll.range = [
		fc.offset,
		cePos,
		cePos
	];
	return coll;
}
function resolveCollection(CN$1, ctx, token, onError, tagName, tag) {
	const coll = token.type === "block-map" ? resolveBlockMap(CN$1, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq(CN$1, ctx, token, onError, tag) : resolveFlowCollection(CN$1, ctx, token, onError, tag);
	const Coll = coll.constructor;
	if (tagName === "!" || tagName === Coll.tagName) {
		coll.tag = Coll.tagName;
		return coll;
	}
	if (tagName) coll.tag = tagName;
	return coll;
}
function composeCollection(CN$1, ctx, token, props, onError) {
	const tagToken = props.tag;
	const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
	if (token.type === "block-seq") {
		const { anchor, newlineAfterProp: nl } = props;
		const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
		if (lastProp && (!nl || nl.offset < lastProp.offset)) onError(lastProp, "MISSING_CHAR", "Missing newline after block sequence props");
	}
	const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
	if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") return resolveCollection(CN$1, ctx, token, onError, tagName);
	let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
	if (!tag) {
		const kt = ctx.schema.knownTags[tagName];
		if (kt?.collection === expType) {
			ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
			tag = kt;
		} else {
			if (kt) onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
			else onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
			return resolveCollection(CN$1, ctx, token, onError, tagName);
		}
	}
	const coll = resolveCollection(CN$1, ctx, token, onError, tagName, tag);
	const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
	const node = isNode$1(res) ? res : new Scalar(res);
	node.range = coll.range;
	node.tag = tagName;
	if (tag?.format) node.format = tag.format;
	return node;
}
function resolveBlockScalar(ctx, scalar, onError) {
	const start = scalar.offset;
	const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
	if (!header) return {
		value: "",
		type: null,
		comment: "",
		range: [
			start,
			start,
			start
		]
	};
	const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
	const lines = scalar.source ? splitLines(scalar.source) : [];
	let chompStart = lines.length;
	for (let i = lines.length - 1; i >= 0; --i) {
		const content = lines[i][1];
		if (content === "" || content === "\r") chompStart = i;
		else break;
	}
	if (chompStart === 0) {
		const value$1 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
		let end$1 = start + header.length;
		if (scalar.source) end$1 += scalar.source.length;
		return {
			value: value$1,
			type,
			comment: header.comment,
			range: [
				start,
				end$1,
				end$1
			]
		};
	}
	let trimIndent = scalar.indent + header.indent;
	let offset$3 = scalar.offset + header.length;
	let contentStart = 0;
	for (let i = 0; i < chompStart; ++i) {
		const [indent, content] = lines[i];
		if (content === "" || content === "\r") {
			if (header.indent === 0 && indent.length > trimIndent) trimIndent = indent.length;
		} else {
			if (indent.length < trimIndent) onError(offset$3 + indent.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator");
			if (header.indent === 0) trimIndent = indent.length;
			contentStart = i;
			if (trimIndent === 0 && !ctx.atRoot) onError(offset$3, "BAD_INDENT", "Block scalar values in collections must be indented");
			break;
		}
		offset$3 += indent.length + content.length + 1;
	}
	for (let i = lines.length - 1; i >= chompStart; --i) if (lines[i][0].length > trimIndent) chompStart = i + 1;
	let value = "";
	let sep = "";
	let prevMoreIndented = false;
	for (let i = 0; i < contentStart; ++i) value += lines[i][0].slice(trimIndent) + "\n";
	for (let i = contentStart; i < chompStart; ++i) {
		let [indent, content] = lines[i];
		offset$3 += indent.length + content.length + 1;
		const crlf = content[content.length - 1] === "\r";
		if (crlf) content = content.slice(0, -1);
		/* istanbul ignore if already caught in lexer */
		if (content && indent.length < trimIndent) {
			const message = `Block scalar lines must not be less indented than their ${header.indent ? "explicit indentation indicator" : "first line"}`;
			onError(offset$3 - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
			indent = "";
		}
		if (type === Scalar.BLOCK_LITERAL) {
			value += sep + indent.slice(trimIndent) + content;
			sep = "\n";
		} else if (indent.length > trimIndent || content[0] === "	") {
			if (sep === " ") sep = "\n";
			else if (!prevMoreIndented && sep === "\n") sep = "\n\n";
			value += sep + indent.slice(trimIndent) + content;
			sep = "\n";
			prevMoreIndented = true;
		} else if (content === "") if (sep === "\n") value += "\n";
		else sep = "\n";
		else {
			value += sep + content;
			sep = " ";
			prevMoreIndented = false;
		}
	}
	switch (header.chomp) {
		case "-": break;
		case "+":
			for (let i = chompStart; i < lines.length; ++i) value += "\n" + lines[i][0].slice(trimIndent);
			if (value[value.length - 1] !== "\n") value += "\n";
			break;
		default: value += "\n";
	}
	const end = start + header.length + scalar.source.length;
	return {
		value,
		type,
		comment: header.comment,
		range: [
			start,
			end,
			end
		]
	};
}
function parseBlockScalarHeader({ offset: offset$3, props }, strict, onError) {
	/* istanbul ignore if should not happen */
	if (props[0].type !== "block-scalar-header") {
		onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
		return null;
	}
	const { source } = props[0];
	const mode = source[0];
	let indent = 0;
	let chomp = "";
	let error = -1;
	for (let i = 1; i < source.length; ++i) {
		const ch = source[i];
		if (!chomp && (ch === "-" || ch === "+")) chomp = ch;
		else {
			const n = Number(ch);
			if (!indent && n) indent = n;
			else if (error === -1) error = offset$3 + i;
		}
	}
	if (error !== -1) onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
	let hasSpace = false;
	let comment = "";
	let length = source.length;
	for (let i = 1; i < props.length; ++i) {
		const token = props[i];
		switch (token.type) {
			case "space": hasSpace = true;
			case "newline":
				length += token.source.length;
				break;
			case "comment":
				if (strict && !hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
				length += token.source.length;
				comment = token.source.substring(1);
				break;
			case "error":
				onError(token, "UNEXPECTED_TOKEN", token.message);
				length += token.source.length;
				break;
			default: {
				onError(token, "UNEXPECTED_TOKEN", `Unexpected token in block scalar header: ${token.type}`);
				const ts = token.source;
				if (ts && typeof ts === "string") length += ts.length;
			}
		}
	}
	return {
		mode,
		indent,
		chomp,
		comment,
		length
	};
}
function splitLines(source) {
	const split = source.split(/\n( *)/);
	const first = split[0];
	const m = first.match(/^( *)/);
	const lines = [m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first]];
	for (let i = 1; i < split.length; i += 2) lines.push([split[i], split[i + 1]]);
	return lines;
}
function resolveFlowScalar(scalar, strict, onError) {
	const { offset: offset$3, type, source, end } = scalar;
	let _type;
	let value;
	const _onError = (rel, code, msg) => onError(offset$3 + rel, code, msg);
	switch (type) {
		case "scalar":
			_type = Scalar.PLAIN;
			value = plainValue(source, _onError);
			break;
		case "single-quoted-scalar":
			_type = Scalar.QUOTE_SINGLE;
			value = singleQuotedValue(source, _onError);
			break;
		case "double-quoted-scalar":
			_type = Scalar.QUOTE_DOUBLE;
			value = doubleQuotedValue(source, _onError);
			break;
		default:
			onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
			return {
				value: "",
				type: null,
				comment: "",
				range: [
					offset$3,
					offset$3 + source.length,
					offset$3 + source.length
				]
			};
	}
	const valueEnd = offset$3 + source.length;
	const re = resolveEnd(end, valueEnd, strict, onError);
	return {
		value,
		type: _type,
		comment: re.comment,
		range: [
			offset$3,
			valueEnd,
			re.offset
		]
	};
}
function plainValue(source, onError) {
	let badChar = "";
	switch (source[0]) {
		case "	":
			badChar = "a tab character";
			break;
		case ",":
			badChar = "flow indicator character ,";
			break;
		case "%":
			badChar = "directive indicator character %";
			break;
		case "|":
		case ">":
			badChar = `block scalar indicator ${source[0]}`;
			break;
		case "@":
		case "`":
			badChar = `reserved character ${source[0]}`;
			break;
	}
	if (badChar) onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
	return foldLines(source);
}
function singleQuotedValue(source, onError) {
	if (source[source.length - 1] !== "'" || source.length === 1) onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
	return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
	let first, line;
	try {
		first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
		line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
	} catch {
		first = /(.*?)[ \t]*\r?\n/sy;
		line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
	}
	let match = first.exec(source);
	if (!match) return source;
	let res = match[1];
	let sep = " ";
	let pos = first.lastIndex;
	line.lastIndex = pos;
	while (match = line.exec(source)) {
		if (match[1] === "") if (sep === "\n") res += sep;
		else sep = "\n";
		else {
			res += sep + match[1];
			sep = " ";
		}
		pos = line.lastIndex;
	}
	const last = /[ \t]*(.*)/sy;
	last.lastIndex = pos;
	match = last.exec(source);
	return res + sep + (match?.[1] ?? "");
}
function doubleQuotedValue(source, onError) {
	let res = "";
	for (let i = 1; i < source.length - 1; ++i) {
		const ch = source[i];
		if (ch === "\r" && source[i + 1] === "\n") continue;
		if (ch === "\n") {
			const { fold, offset: offset$3 } = foldNewline(source, i);
			res += fold;
			i = offset$3;
		} else if (ch === "\\") {
			let next = source[++i];
			const cc = escapeCodes[next];
			if (cc) res += cc;
			else if (next === "\n") {
				next = source[i + 1];
				while (next === " " || next === "	") next = source[++i + 1];
			} else if (next === "\r" && source[i + 1] === "\n") {
				next = source[++i + 1];
				while (next === " " || next === "	") next = source[++i + 1];
			} else if (next === "x" || next === "u" || next === "U") {
				const length = {
					x: 2,
					u: 4,
					U: 8
				}[next];
				res += parseCharCode(source, i + 1, length, onError);
				i += length;
			} else {
				const raw = source.substr(i - 1, 2);
				onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
				res += raw;
			}
		} else if (ch === " " || ch === "	") {
			const wsStart = i;
			let next = source[i + 1];
			while (next === " " || next === "	") next = source[++i + 1];
			if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n")) res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
		} else res += ch;
	}
	if (source[source.length - 1] !== "\"" || source.length === 1) onError(source.length, "MISSING_CHAR", "Missing closing \"quote");
	return res;
}
function foldNewline(source, offset$3) {
	let fold = "";
	let ch = source[offset$3 + 1];
	while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
		if (ch === "\r" && source[offset$3 + 2] !== "\n") break;
		if (ch === "\n") fold += "\n";
		offset$3 += 1;
		ch = source[offset$3 + 1];
	}
	if (!fold) fold = " ";
	return {
		fold,
		offset: offset$3
	};
}
var escapeCodes = {
	"0": "\0",
	a: "\x07",
	b: "\b",
	e: "\x1B",
	f: "\f",
	n: "\n",
	r: "\r",
	t: "	",
	v: "\v",
	N: "",
	_: "\xA0",
	L: "\u2028",
	P: "\u2029",
	" ": " ",
	"\"": "\"",
	"/": "/",
	"\\": "\\",
	"	": "	"
};
function parseCharCode(source, offset$3, length, onError) {
	const cc = source.substr(offset$3, length);
	const code = cc.length === length && /^[0-9a-fA-F]+$/.test(cc) ? parseInt(cc, 16) : NaN;
	if (isNaN(code)) {
		const raw = source.substr(offset$3 - 2, length + 2);
		onError(offset$3 - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
		return raw;
	}
	return String.fromCodePoint(code);
}
function composeScalar(ctx, token, tagToken, onError) {
	const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(ctx, token, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
	const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
	let tag;
	if (ctx.options.stringKeys && ctx.atKey) tag = ctx.schema[SCALAR$1];
	else if (tagName) tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
	else if (token.type === "scalar") tag = findScalarTagByTest(ctx, value, token, onError);
	else tag = ctx.schema[SCALAR$1];
	let scalar;
	try {
		const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
		scalar = isScalar(res) ? res : new Scalar(res);
	} catch (error) {
		const msg = error instanceof Error ? error.message : String(error);
		onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
		scalar = new Scalar(value);
	}
	scalar.range = range;
	scalar.source = value;
	if (type) scalar.type = type;
	if (tagName) scalar.tag = tagName;
	if (tag.format) scalar.format = tag.format;
	if (comment) scalar.comment = comment;
	return scalar;
}
function findScalarTagByName(schema$3, value, tagName, tagToken, onError) {
	if (tagName === "!") return schema$3[SCALAR$1];
	const matchWithTest = [];
	for (const tag of schema$3.tags) if (!tag.collection && tag.tag === tagName) if (tag.default && tag.test) matchWithTest.push(tag);
	else return tag;
	for (const tag of matchWithTest) if (tag.test?.test(value)) return tag;
	const kt = schema$3.knownTags[tagName];
	if (kt && !kt.collection) {
		schema$3.tags.push(Object.assign({}, kt, {
			default: false,
			test: void 0
		}));
		return kt;
	}
	onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
	return schema$3[SCALAR$1];
}
function findScalarTagByTest({ atKey, directives, schema: schema$3 }, value, token, onError) {
	const tag = schema$3.tags.find((tag$1) => (tag$1.default === true || atKey && tag$1.default === "key") && tag$1.test?.test(value)) || schema$3[SCALAR$1];
	if (schema$3.compat) {
		const compat = schema$3.compat.find((tag$1) => tag$1.default && tag$1.test?.test(value)) ?? schema$3[SCALAR$1];
		if (tag.tag !== compat.tag) onError(token, "TAG_RESOLVE_FAILED", `Value may be parsed as either ${directives.tagString(tag.tag)} or ${directives.tagString(compat.tag)}`, true);
	}
	return tag;
}
function emptyScalarPosition(offset$3, before, pos) {
	if (before) {
		pos ?? (pos = before.length);
		for (let i = pos - 1; i >= 0; --i) {
			let st = before[i];
			switch (st.type) {
				case "space":
				case "comment":
				case "newline":
					offset$3 -= st.source.length;
					continue;
			}
			st = before[++i];
			while (st?.type === "space") {
				offset$3 += st.source.length;
				st = before[++i];
			}
			break;
		}
	}
	return offset$3;
}
var CN = {
	composeNode,
	composeEmptyNode
};
function composeNode(ctx, token, props, onError) {
	const atKey = ctx.atKey;
	const { spaceBefore, comment, anchor, tag } = props;
	let node;
	let isSrcToken = true;
	switch (token.type) {
		case "alias":
			node = composeAlias(ctx, token, onError);
			if (anchor || tag) onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
			break;
		case "scalar":
		case "single-quoted-scalar":
		case "double-quoted-scalar":
		case "block-scalar":
			node = composeScalar(ctx, token, tag, onError);
			if (anchor) node.anchor = anchor.source.substring(1);
			break;
		case "block-map":
		case "block-seq":
		case "flow-collection":
			node = composeCollection(CN, ctx, token, props, onError);
			if (anchor) node.anchor = anchor.source.substring(1);
			break;
		default:
			onError(token, "UNEXPECTED_TOKEN", token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`);
			node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
			isSrcToken = false;
	}
	if (anchor && node.anchor === "") onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
	if (atKey && ctx.options.stringKeys && (!isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) onError(tag ?? token, "NON_STRING_KEY", "With stringKeys, all keys must be strings");
	if (spaceBefore) node.spaceBefore = true;
	if (comment) if (token.type === "scalar" && token.source === "") node.comment = comment;
	else node.commentBefore = comment;
	if (ctx.options.keepSourceTokens && isSrcToken) node.srcToken = token;
	return node;
}
function composeEmptyNode(ctx, offset$3, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
	const node = composeScalar(ctx, {
		type: "scalar",
		offset: emptyScalarPosition(offset$3, before, pos),
		indent: -1,
		source: ""
	}, tag, onError);
	if (anchor) {
		node.anchor = anchor.source.substring(1);
		if (node.anchor === "") onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
	}
	if (spaceBefore) node.spaceBefore = true;
	if (comment) {
		node.comment = comment;
		node.range[2] = end;
	}
	return node;
}
function composeAlias({ options: options$1 }, { offset: offset$3, source, end }, onError) {
	const alias = new Alias(source.substring(1));
	if (alias.source === "") onError(offset$3, "BAD_ALIAS", "Alias cannot be an empty string");
	if (alias.source.endsWith(":")) onError(offset$3 + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
	const valueEnd = offset$3 + source.length;
	const re = resolveEnd(end, valueEnd, options$1.strict, onError);
	alias.range = [
		offset$3,
		valueEnd,
		re.offset
	];
	if (re.comment) alias.comment = re.comment;
	return alias;
}
function composeDoc(options$1, directives, { offset: offset$3, start, value, end }, onError) {
	const doc = new Document$1(void 0, Object.assign({ _directives: directives }, options$1));
	const ctx = {
		atKey: false,
		atRoot: true,
		directives: doc.directives,
		options: doc.options,
		schema: doc.schema
	};
	const props = resolveProps(start, {
		indicator: "doc-start",
		next: value ?? end?.[0],
		offset: offset$3,
		onError,
		parentIndent: 0,
		startOnNewline: true
	});
	if (props.found) {
		doc.directives.docStart = true;
		if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline) onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
	}
	doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
	const contentEnd = doc.contents.range[2];
	const re = resolveEnd(end, contentEnd, false, onError);
	if (re.comment) doc.comment = re.comment;
	doc.range = [
		offset$3,
		contentEnd,
		re.offset
	];
	return doc;
}
function getErrorPos(src) {
	if (typeof src === "number") return [src, src + 1];
	if (Array.isArray(src)) return src.length === 2 ? src : [src[0], src[1]];
	const { offset: offset$3, source } = src;
	return [offset$3, offset$3 + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
	let comment = "";
	let atComment = false;
	let afterEmptyLine = false;
	for (let i = 0; i < prelude.length; ++i) {
		const source = prelude[i];
		switch (source[0]) {
			case "#":
				comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
				atComment = true;
				afterEmptyLine = false;
				break;
			case "%":
				if (prelude[i + 1]?.[0] !== "#") i += 1;
				atComment = false;
				break;
			default:
				if (!atComment) afterEmptyLine = true;
				atComment = false;
		}
	}
	return {
		comment,
		afterEmptyLine
	};
}
var Composer = class {
	constructor(options$1 = {}) {
		this.doc = null;
		this.atDirectives = false;
		this.prelude = [];
		this.errors = [];
		this.warnings = [];
		this.onError = (source, code, message, warning) => {
			const pos = getErrorPos(source);
			if (warning) this.warnings.push(new YAMLWarning(pos, code, message));
			else this.errors.push(new YAMLParseError(pos, code, message));
		};
		this.directives = new Directives({ version: options$1.version || "1.2" });
		this.options = options$1;
	}
	decorate(doc, afterDoc) {
		const { comment, afterEmptyLine } = parsePrelude(this.prelude);
		if (comment) {
			const dc = doc.contents;
			if (afterDoc) doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
			else if (afterEmptyLine || doc.directives.docStart || !dc) doc.commentBefore = comment;
			else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
				let it = dc.items[0];
				if (isPair(it)) it = it.key;
				const cb = it.commentBefore;
				it.commentBefore = cb ? `${comment}\n${cb}` : comment;
			} else {
				const cb = dc.commentBefore;
				dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
			}
		}
		if (afterDoc) {
			Array.prototype.push.apply(doc.errors, this.errors);
			Array.prototype.push.apply(doc.warnings, this.warnings);
		} else {
			doc.errors = this.errors;
			doc.warnings = this.warnings;
		}
		this.prelude = [];
		this.errors = [];
		this.warnings = [];
	}
	streamInfo() {
		return {
			comment: parsePrelude(this.prelude).comment,
			directives: this.directives,
			errors: this.errors,
			warnings: this.warnings
		};
	}
	*compose(tokens, forceDoc = false, endOffset = -1) {
		for (const token of tokens) yield* this.next(token);
		yield* this.end(forceDoc, endOffset);
	}
	*next(token) {
		switch (token.type) {
			case "directive":
				this.directives.add(token.source, (offset$3, message, warning) => {
					const pos = getErrorPos(token);
					pos[0] += offset$3;
					this.onError(pos, "BAD_DIRECTIVE", message, warning);
				});
				this.prelude.push(token.source);
				this.atDirectives = true;
				break;
			case "document": {
				const doc = composeDoc(this.options, this.directives, token, this.onError);
				if (this.atDirectives && !doc.directives.docStart) this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
				this.decorate(doc, false);
				if (this.doc) yield this.doc;
				this.doc = doc;
				this.atDirectives = false;
				break;
			}
			case "byte-order-mark":
			case "space": break;
			case "comment":
			case "newline":
				this.prelude.push(token.source);
				break;
			case "error": {
				const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
				const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
				if (this.atDirectives || !this.doc) this.errors.push(error);
				else this.doc.errors.push(error);
				break;
			}
			case "doc-end": {
				if (!this.doc) {
					this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", "Unexpected doc-end without preceding document"));
					break;
				}
				this.doc.directives.docEnd = true;
				const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
				this.decorate(this.doc, true);
				if (end.comment) {
					const dc = this.doc.comment;
					this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
				}
				this.doc.range[2] = end.offset;
				break;
			}
			default: this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
		}
	}
	*end(forceDoc = false, endOffset = -1) {
		if (this.doc) {
			this.decorate(this.doc, true);
			yield this.doc;
			this.doc = null;
		} else if (forceDoc) {
			const doc = new Document$1(void 0, Object.assign({ _directives: this.directives }, this.options));
			if (this.atDirectives) this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
			doc.range = [
				0,
				endOffset,
				endOffset
			];
			this.decorate(doc, false);
			yield doc;
		}
	}
};
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove item");
function visit(cst, visitor) {
	if ("type" in cst && cst.type === "document") cst = {
		start: cst.start,
		value: cst.value
	};
	_visit(Object.freeze([]), cst, visitor);
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
visit.itemAtPath = (cst, path) => {
	let item = cst;
	for (const [field, index$3] of path) {
		const tok = item?.[field];
		if (tok && "items" in tok) item = tok.items[index$3];
		else return void 0;
	}
	return item;
};
visit.parentCollection = (cst, path) => {
	const parent = visit.itemAtPath(cst, path.slice(0, -1));
	const field = path[path.length - 1][0];
	const coll = parent?.[field];
	if (coll && "items" in coll) return coll;
	throw new Error("Parent collection not found");
};
function _visit(path, item, visitor) {
	let ctrl = visitor(item, path);
	if (typeof ctrl === "symbol") return ctrl;
	for (const field of ["key", "value"]) {
		const token = item[field];
		if (token && "items" in token) {
			for (let i = 0; i < token.items.length; ++i) {
				const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
				if (typeof ci === "number") i = ci - 1;
				else if (ci === BREAK) return BREAK;
				else if (ci === REMOVE) {
					token.items.splice(i, 1);
					i -= 1;
				}
			}
			if (typeof ctrl === "function" && field === "key") ctrl = ctrl(item, path);
		}
	}
	return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}
function tokenType(source) {
	switch (source) {
		case "": return "byte-order-mark";
		case "": return "doc-mode";
		case "": return "flow-error-end";
		case "": return "scalar";
		case "---": return "doc-start";
		case "...": return "doc-end";
		case "":
		case "\n":
		case "\r\n": return "newline";
		case "-": return "seq-item-ind";
		case "?": return "explicit-key-ind";
		case ":": return "map-value-ind";
		case "{": return "flow-map-start";
		case "}": return "flow-map-end";
		case "[": return "flow-seq-start";
		case "]": return "flow-seq-end";
		case ",": return "comma";
	}
	switch (source[0]) {
		case " ":
		case "	": return "space";
		case "#": return "comment";
		case "%": return "directive-line";
		case "*": return "alias";
		case "&": return "anchor";
		case "!": return "tag";
		case "'": return "single-quoted-scalar";
		case "\"": return "double-quoted-scalar";
		case "|":
		case ">": return "block-scalar-header";
	}
	return null;
}
function isEmpty(ch) {
	switch (ch) {
		case void 0:
		case " ":
		case "\n":
		case "\r":
		case "	": return true;
		default: return false;
	}
}
var hexDigits = /* @__PURE__ */ new Set("0123456789ABCDEFabcdef");
var tagChars = /* @__PURE__ */ new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
var flowIndicatorChars = /* @__PURE__ */ new Set(",[]{}");
var invalidAnchorChars = /* @__PURE__ */ new Set(" ,[]{}\n\r	");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
var Lexer = class {
	constructor() {
		this.atEnd = false;
		this.blockScalarIndent = -1;
		this.blockScalarKeep = false;
		this.buffer = "";
		this.flowKey = false;
		this.flowLevel = 0;
		this.indentNext = 0;
		this.indentValue = 0;
		this.lineEndPos = null;
		this.next = null;
		this.pos = 0;
	}
	*lex(source, incomplete = false) {
		if (source) {
			if (typeof source !== "string") throw TypeError("source is not a string");
			this.buffer = this.buffer ? this.buffer + source : source;
			this.lineEndPos = null;
		}
		this.atEnd = !incomplete;
		let next = this.next ?? "stream";
		while (next && (incomplete || this.hasChars(1))) next = yield* this.parseNext(next);
	}
	atLineEnd() {
		let i = this.pos;
		let ch = this.buffer[i];
		while (ch === " " || ch === "	") ch = this.buffer[++i];
		if (!ch || ch === "#" || ch === "\n") return true;
		if (ch === "\r") return this.buffer[i + 1] === "\n";
		return false;
	}
	charAt(n) {
		return this.buffer[this.pos + n];
	}
	continueScalar(offset$3) {
		let ch = this.buffer[offset$3];
		if (this.indentNext > 0) {
			let indent = 0;
			while (ch === " ") ch = this.buffer[++indent + offset$3];
			if (ch === "\r") {
				const next = this.buffer[indent + offset$3 + 1];
				if (next === "\n" || !next && !this.atEnd) return offset$3 + indent + 1;
			}
			return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset$3 + indent : -1;
		}
		if (ch === "-" || ch === ".") {
			const dt = this.buffer.substr(offset$3, 3);
			if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset$3 + 3])) return -1;
		}
		return offset$3;
	}
	getLine() {
		let end = this.lineEndPos;
		if (typeof end !== "number" || end !== -1 && end < this.pos) {
			end = this.buffer.indexOf("\n", this.pos);
			this.lineEndPos = end;
		}
		if (end === -1) return this.atEnd ? this.buffer.substring(this.pos) : null;
		if (this.buffer[end - 1] === "\r") end -= 1;
		return this.buffer.substring(this.pos, end);
	}
	hasChars(n) {
		return this.pos + n <= this.buffer.length;
	}
	setNext(state) {
		this.buffer = this.buffer.substring(this.pos);
		this.pos = 0;
		this.lineEndPos = null;
		this.next = state;
		return null;
	}
	peek(n) {
		return this.buffer.substr(this.pos, n);
	}
	*parseNext(next) {
		switch (next) {
			case "stream": return yield* this.parseStream();
			case "line-start": return yield* this.parseLineStart();
			case "block-start": return yield* this.parseBlockStart();
			case "doc": return yield* this.parseDocument();
			case "flow": return yield* this.parseFlowCollection();
			case "quoted-scalar": return yield* this.parseQuotedScalar();
			case "block-scalar": return yield* this.parseBlockScalar();
			case "plain-scalar": return yield* this.parsePlainScalar();
		}
	}
	*parseStream() {
		let line = this.getLine();
		if (line === null) return this.setNext("stream");
		if (line[0] === "") {
			yield* this.pushCount(1);
			line = line.substring(1);
		}
		if (line[0] === "%") {
			let dirEnd = line.length;
			let cs = line.indexOf("#");
			while (cs !== -1) {
				const ch = line[cs - 1];
				if (ch === " " || ch === "	") {
					dirEnd = cs - 1;
					break;
				} else cs = line.indexOf("#", cs + 1);
			}
			while (true) {
				const ch = line[dirEnd - 1];
				if (ch === " " || ch === "	") dirEnd -= 1;
				else break;
			}
			const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
			yield* this.pushCount(line.length - n);
			this.pushNewline();
			return "stream";
		}
		if (this.atLineEnd()) {
			const sp = yield* this.pushSpaces(true);
			yield* this.pushCount(line.length - sp);
			yield* this.pushNewline();
			return "stream";
		}
		yield "";
		return yield* this.parseLineStart();
	}
	*parseLineStart() {
		const ch = this.charAt(0);
		if (!ch && !this.atEnd) return this.setNext("line-start");
		if (ch === "-" || ch === ".") {
			if (!this.atEnd && !this.hasChars(4)) return this.setNext("line-start");
			const s = this.peek(3);
			if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
				yield* this.pushCount(3);
				this.indentValue = 0;
				this.indentNext = 0;
				return s === "---" ? "doc" : "stream";
			}
		}
		this.indentValue = yield* this.pushSpaces(false);
		if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1))) this.indentNext = this.indentValue;
		return yield* this.parseBlockStart();
	}
	*parseBlockStart() {
		const [ch0, ch1] = this.peek(2);
		if (!ch1 && !this.atEnd) return this.setNext("block-start");
		if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
			const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
			this.indentNext = this.indentValue + 1;
			this.indentValue += n;
			return yield* this.parseBlockStart();
		}
		return "doc";
	}
	*parseDocument() {
		yield* this.pushSpaces(true);
		const line = this.getLine();
		if (line === null) return this.setNext("doc");
		let n = yield* this.pushIndicators();
		switch (line[n]) {
			case "#": yield* this.pushCount(line.length - n);
			case void 0:
				yield* this.pushNewline();
				return yield* this.parseLineStart();
			case "{":
			case "[":
				yield* this.pushCount(1);
				this.flowKey = false;
				this.flowLevel = 1;
				return "flow";
			case "}":
			case "]":
				yield* this.pushCount(1);
				return "doc";
			case "*":
				yield* this.pushUntil(isNotAnchorChar);
				return "doc";
			case "\"":
			case "'": return yield* this.parseQuotedScalar();
			case "|":
			case ">":
				n += yield* this.parseBlockScalarHeader();
				n += yield* this.pushSpaces(true);
				yield* this.pushCount(line.length - n);
				yield* this.pushNewline();
				return yield* this.parseBlockScalar();
			default: return yield* this.parsePlainScalar();
		}
	}
	*parseFlowCollection() {
		let nl, sp;
		let indent = -1;
		do {
			nl = yield* this.pushNewline();
			if (nl > 0) {
				sp = yield* this.pushSpaces(false);
				this.indentValue = indent = sp;
			} else sp = 0;
			sp += yield* this.pushSpaces(true);
		} while (nl + sp > 0);
		const line = this.getLine();
		if (line === null) return this.setNext("flow");
		if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
			if (!(indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}"))) {
				this.flowLevel = 0;
				yield "";
				return yield* this.parseLineStart();
			}
		}
		let n = 0;
		while (line[n] === ",") {
			n += yield* this.pushCount(1);
			n += yield* this.pushSpaces(true);
			this.flowKey = false;
		}
		n += yield* this.pushIndicators();
		switch (line[n]) {
			case void 0: return "flow";
			case "#":
				yield* this.pushCount(line.length - n);
				return "flow";
			case "{":
			case "[":
				yield* this.pushCount(1);
				this.flowKey = false;
				this.flowLevel += 1;
				return "flow";
			case "}":
			case "]":
				yield* this.pushCount(1);
				this.flowKey = true;
				this.flowLevel -= 1;
				return this.flowLevel ? "flow" : "doc";
			case "*":
				yield* this.pushUntil(isNotAnchorChar);
				return "flow";
			case "\"":
			case "'":
				this.flowKey = true;
				return yield* this.parseQuotedScalar();
			case ":": {
				const next = this.charAt(1);
				if (this.flowKey || isEmpty(next) || next === ",") {
					this.flowKey = false;
					yield* this.pushCount(1);
					yield* this.pushSpaces(true);
					return "flow";
				}
			}
			default:
				this.flowKey = false;
				return yield* this.parsePlainScalar();
		}
	}
	*parseQuotedScalar() {
		const quote = this.charAt(0);
		let end = this.buffer.indexOf(quote, this.pos + 1);
		if (quote === "'") while (end !== -1 && this.buffer[end + 1] === "'") end = this.buffer.indexOf("'", end + 2);
		else while (end !== -1) {
			let n = 0;
			while (this.buffer[end - 1 - n] === "\\") n += 1;
			if (n % 2 === 0) break;
			end = this.buffer.indexOf("\"", end + 1);
		}
		const qb = this.buffer.substring(0, end);
		let nl = qb.indexOf("\n", this.pos);
		if (nl !== -1) {
			while (nl !== -1) {
				const cs = this.continueScalar(nl + 1);
				if (cs === -1) break;
				nl = qb.indexOf("\n", cs);
			}
			if (nl !== -1) end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
		}
		if (end === -1) {
			if (!this.atEnd) return this.setNext("quoted-scalar");
			end = this.buffer.length;
		}
		yield* this.pushToIndex(end + 1, false);
		return this.flowLevel ? "flow" : "doc";
	}
	*parseBlockScalarHeader() {
		this.blockScalarIndent = -1;
		this.blockScalarKeep = false;
		let i = this.pos;
		while (true) {
			const ch = this.buffer[++i];
			if (ch === "+") this.blockScalarKeep = true;
			else if (ch > "0" && ch <= "9") this.blockScalarIndent = Number(ch) - 1;
			else if (ch !== "-") break;
		}
		return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
	}
	*parseBlockScalar() {
		let nl = this.pos - 1;
		let indent = 0;
		let ch;
		loop: for (let i$1 = this.pos; ch = this.buffer[i$1]; ++i$1) switch (ch) {
			case " ":
				indent += 1;
				break;
			case "\n":
				nl = i$1;
				indent = 0;
				break;
			case "\r": {
				const next = this.buffer[i$1 + 1];
				if (!next && !this.atEnd) return this.setNext("block-scalar");
				if (next === "\n") break;
			}
			default: break loop;
		}
		if (!ch && !this.atEnd) return this.setNext("block-scalar");
		if (indent >= this.indentNext) {
			if (this.blockScalarIndent === -1) this.indentNext = indent;
			else this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
			do {
				const cs = this.continueScalar(nl + 1);
				if (cs === -1) break;
				nl = this.buffer.indexOf("\n", cs);
			} while (nl !== -1);
			if (nl === -1) {
				if (!this.atEnd) return this.setNext("block-scalar");
				nl = this.buffer.length;
			}
		}
		let i = nl + 1;
		ch = this.buffer[i];
		while (ch === " ") ch = this.buffer[++i];
		if (ch === "	") {
			while (ch === "	" || ch === " " || ch === "\r" || ch === "\n") ch = this.buffer[++i];
			nl = i - 1;
		} else if (!this.blockScalarKeep) do {
			let i$1 = nl - 1;
			let ch$1 = this.buffer[i$1];
			if (ch$1 === "\r") ch$1 = this.buffer[--i$1];
			const lastChar = i$1;
			while (ch$1 === " ") ch$1 = this.buffer[--i$1];
			if (ch$1 === "\n" && i$1 >= this.pos && i$1 + 1 + indent > lastChar) nl = i$1;
			else break;
		} while (true);
		yield "";
		yield* this.pushToIndex(nl + 1, true);
		return yield* this.parseLineStart();
	}
	*parsePlainScalar() {
		const inFlow = this.flowLevel > 0;
		let end = this.pos - 1;
		let i = this.pos - 1;
		let ch;
		while (ch = this.buffer[++i]) if (ch === ":") {
			const next = this.buffer[i + 1];
			if (isEmpty(next) || inFlow && flowIndicatorChars.has(next)) break;
			end = i;
		} else if (isEmpty(ch)) {
			let next = this.buffer[i + 1];
			if (ch === "\r") if (next === "\n") {
				i += 1;
				ch = "\n";
				next = this.buffer[i + 1];
			} else end = i;
			if (next === "#" || inFlow && flowIndicatorChars.has(next)) break;
			if (ch === "\n") {
				const cs = this.continueScalar(i + 1);
				if (cs === -1) break;
				i = Math.max(i, cs - 2);
			}
		} else {
			if (inFlow && flowIndicatorChars.has(ch)) break;
			end = i;
		}
		if (!ch && !this.atEnd) return this.setNext("plain-scalar");
		yield "";
		yield* this.pushToIndex(end + 1, true);
		return inFlow ? "flow" : "doc";
	}
	*pushCount(n) {
		if (n > 0) {
			yield this.buffer.substr(this.pos, n);
			this.pos += n;
			return n;
		}
		return 0;
	}
	*pushToIndex(i, allowEmpty) {
		const s = this.buffer.slice(this.pos, i);
		if (s) {
			yield s;
			this.pos += s.length;
			return s.length;
		} else if (allowEmpty) yield "";
		return 0;
	}
	*pushIndicators() {
		switch (this.charAt(0)) {
			case "!": return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
			case "&": return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
			case "-":
			case "?":
			case ":": {
				const inFlow = this.flowLevel > 0;
				const ch1 = this.charAt(1);
				if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
					if (!inFlow) this.indentNext = this.indentValue + 1;
					else if (this.flowKey) this.flowKey = false;
					return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
				}
			}
		}
		return 0;
	}
	*pushTag() {
		if (this.charAt(1) === "<") {
			let i = this.pos + 2;
			let ch = this.buffer[i];
			while (!isEmpty(ch) && ch !== ">") ch = this.buffer[++i];
			return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
		} else {
			let i = this.pos + 1;
			let ch = this.buffer[i];
			while (ch) if (tagChars.has(ch)) ch = this.buffer[++i];
			else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) ch = this.buffer[i += 3];
			else break;
			return yield* this.pushToIndex(i, false);
		}
	}
	*pushNewline() {
		const ch = this.buffer[this.pos];
		if (ch === "\n") return yield* this.pushCount(1);
		else if (ch === "\r" && this.charAt(1) === "\n") return yield* this.pushCount(2);
		else return 0;
	}
	*pushSpaces(allowTabs) {
		let i = this.pos - 1;
		let ch;
		do
			ch = this.buffer[++i];
		while (ch === " " || allowTabs && ch === "	");
		const n = i - this.pos;
		if (n > 0) {
			yield this.buffer.substr(this.pos, n);
			this.pos = i;
		}
		return n;
	}
	*pushUntil(test) {
		let i = this.pos;
		let ch = this.buffer[i];
		while (!test(ch)) ch = this.buffer[++i];
		return yield* this.pushToIndex(i, false);
	}
};
var LineCounter = class {
	constructor() {
		this.lineStarts = [];
		this.addNewLine = (offset$3) => this.lineStarts.push(offset$3);
		this.linePos = (offset$3) => {
			let low = 0;
			let high = this.lineStarts.length;
			while (low < high) {
				const mid = low + high >> 1;
				if (this.lineStarts[mid] < offset$3) low = mid + 1;
				else high = mid;
			}
			if (this.lineStarts[low] === offset$3) return {
				line: low + 1,
				col: 1
			};
			if (low === 0) return {
				line: 0,
				col: offset$3
			};
			const start = this.lineStarts[low - 1];
			return {
				line: low,
				col: offset$3 - start + 1
			};
		};
	}
};
function includesToken(list, type) {
	for (let i = 0; i < list.length; ++i) if (list[i].type === type) return true;
	return false;
}
function findNonEmptyIndex(list) {
	for (let i = 0; i < list.length; ++i) switch (list[i].type) {
		case "space":
		case "comment":
		case "newline": break;
		default: return i;
	}
	return -1;
}
function isFlowToken(token) {
	switch (token?.type) {
		case "alias":
		case "scalar":
		case "single-quoted-scalar":
		case "double-quoted-scalar":
		case "flow-collection": return true;
		default: return false;
	}
}
function getPrevProps(parent) {
	switch (parent.type) {
		case "document": return parent.start;
		case "block-map": {
			const it = parent.items[parent.items.length - 1];
			return it.sep ?? it.start;
		}
		case "block-seq": return parent.items[parent.items.length - 1].start;
		default: return [];
	}
}
function getFirstKeyStartProps(prev) {
	if (prev.length === 0) return [];
	let i = prev.length;
	loop: while (--i >= 0) switch (prev[i].type) {
		case "doc-start":
		case "explicit-key-ind":
		case "map-value-ind":
		case "seq-item-ind":
		case "newline": break loop;
	}
	while (prev[++i]?.type === "space");
	return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
	if (fc.start.type === "flow-seq-start") {
		for (const it of fc.items) if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
			if (it.key) it.value = it.key;
			delete it.key;
			if (isFlowToken(it.value)) if (it.value.end) Array.prototype.push.apply(it.value.end, it.sep);
			else it.value.end = it.sep;
			else Array.prototype.push.apply(it.start, it.sep);
			delete it.sep;
		}
	}
}
var Parser = class {
	constructor(onNewLine) {
		this.atNewLine = true;
		this.atScalar = false;
		this.indent = 0;
		this.offset = 0;
		this.onKeyLine = false;
		this.stack = [];
		this.source = "";
		this.type = "";
		this.lexer = new Lexer();
		this.onNewLine = onNewLine;
	}
	*parse(source, incomplete = false) {
		if (this.onNewLine && this.offset === 0) this.onNewLine(0);
		for (const lexeme of this.lexer.lex(source, incomplete)) yield* this.next(lexeme);
		if (!incomplete) yield* this.end();
	}
	*next(source) {
		this.source = source;
		if (this.atScalar) {
			this.atScalar = false;
			yield* this.step();
			this.offset += source.length;
			return;
		}
		const type = tokenType(source);
		if (!type) {
			const message = `Not a YAML token: ${source}`;
			yield* this.pop({
				type: "error",
				offset: this.offset,
				message,
				source
			});
			this.offset += source.length;
		} else if (type === "scalar") {
			this.atNewLine = false;
			this.atScalar = true;
			this.type = "scalar";
		} else {
			this.type = type;
			yield* this.step();
			switch (type) {
				case "newline":
					this.atNewLine = true;
					this.indent = 0;
					if (this.onNewLine) this.onNewLine(this.offset + source.length);
					break;
				case "space":
					if (this.atNewLine && source[0] === " ") this.indent += source.length;
					break;
				case "explicit-key-ind":
				case "map-value-ind":
				case "seq-item-ind":
					if (this.atNewLine) this.indent += source.length;
					break;
				case "doc-mode":
				case "flow-error-end": return;
				default: this.atNewLine = false;
			}
			this.offset += source.length;
		}
	}
	*end() {
		while (this.stack.length > 0) yield* this.pop();
	}
	get sourceToken() {
		return {
			type: this.type,
			offset: this.offset,
			indent: this.indent,
			source: this.source
		};
	}
	*step() {
		const top = this.peek(1);
		if (this.type === "doc-end" && top?.type !== "doc-end") {
			while (this.stack.length > 0) yield* this.pop();
			this.stack.push({
				type: "doc-end",
				offset: this.offset,
				source: this.source
			});
			return;
		}
		if (!top) return yield* this.stream();
		switch (top.type) {
			case "document": return yield* this.document(top);
			case "alias":
			case "scalar":
			case "single-quoted-scalar":
			case "double-quoted-scalar": return yield* this.scalar(top);
			case "block-scalar": return yield* this.blockScalar(top);
			case "block-map": return yield* this.blockMap(top);
			case "block-seq": return yield* this.blockSequence(top);
			case "flow-collection": return yield* this.flowCollection(top);
			case "doc-end": return yield* this.documentEnd(top);
		}
		/* istanbul ignore next should not happen */
		yield* this.pop();
	}
	peek(n) {
		return this.stack[this.stack.length - n];
	}
	*pop(error) {
		const token = error ?? this.stack.pop();
		/* istanbul ignore if should not happen */
		if (!token) yield {
			type: "error",
			offset: this.offset,
			source: "",
			message: "Tried to pop an empty stack"
		};
		else if (this.stack.length === 0) yield token;
		else {
			const top = this.peek(1);
			if (token.type === "block-scalar") token.indent = "indent" in top ? top.indent : 0;
			else if (token.type === "flow-collection" && top.type === "document") token.indent = 0;
			if (token.type === "flow-collection") fixFlowSeqItems(token);
			switch (top.type) {
				case "document":
					top.value = token;
					break;
				case "block-scalar":
					top.props.push(token);
					break;
				case "block-map": {
					const it = top.items[top.items.length - 1];
					if (it.value) {
						top.items.push({
							start: [],
							key: token,
							sep: []
						});
						this.onKeyLine = true;
						return;
					} else if (it.sep) it.value = token;
					else {
						Object.assign(it, {
							key: token,
							sep: []
						});
						this.onKeyLine = !it.explicitKey;
						return;
					}
					break;
				}
				case "block-seq": {
					const it = top.items[top.items.length - 1];
					if (it.value) top.items.push({
						start: [],
						value: token
					});
					else it.value = token;
					break;
				}
				case "flow-collection": {
					const it = top.items[top.items.length - 1];
					if (!it || it.value) top.items.push({
						start: [],
						key: token,
						sep: []
					});
					else if (it.sep) it.value = token;
					else Object.assign(it, {
						key: token,
						sep: []
					});
					return;
				}
				default:
					yield* this.pop();
					yield* this.pop(token);
			}
			if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
				const last = token.items[token.items.length - 1];
				if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
					if (top.type === "document") top.end = last.start;
					else top.items.push({ start: last.start });
					token.items.splice(-1, 1);
				}
			}
		}
	}
	*stream() {
		switch (this.type) {
			case "directive-line":
				yield {
					type: "directive",
					offset: this.offset,
					source: this.source
				};
				return;
			case "byte-order-mark":
			case "space":
			case "comment":
			case "newline":
				yield this.sourceToken;
				return;
			case "doc-mode":
			case "doc-start": {
				const doc = {
					type: "document",
					offset: this.offset,
					start: []
				};
				if (this.type === "doc-start") doc.start.push(this.sourceToken);
				this.stack.push(doc);
				return;
			}
		}
		yield {
			type: "error",
			offset: this.offset,
			message: `Unexpected ${this.type} token in YAML stream`,
			source: this.source
		};
	}
	*document(doc) {
		if (doc.value) return yield* this.lineEnd(doc);
		switch (this.type) {
			case "doc-start":
				if (findNonEmptyIndex(doc.start) !== -1) {
					yield* this.pop();
					yield* this.step();
				} else doc.start.push(this.sourceToken);
				return;
			case "anchor":
			case "tag":
			case "space":
			case "comment":
			case "newline":
				doc.start.push(this.sourceToken);
				return;
		}
		const bv = this.startBlockValue(doc);
		if (bv) this.stack.push(bv);
		else yield {
			type: "error",
			offset: this.offset,
			message: `Unexpected ${this.type} token in YAML document`,
			source: this.source
		};
	}
	*scalar(scalar) {
		if (this.type === "map-value-ind") {
			const start = getFirstKeyStartProps(getPrevProps(this.peek(2)));
			let sep;
			if (scalar.end) {
				sep = scalar.end;
				sep.push(this.sourceToken);
				delete scalar.end;
			} else sep = [this.sourceToken];
			const map$1 = {
				type: "block-map",
				offset: scalar.offset,
				indent: scalar.indent,
				items: [{
					start,
					key: scalar,
					sep
				}]
			};
			this.onKeyLine = true;
			this.stack[this.stack.length - 1] = map$1;
		} else yield* this.lineEnd(scalar);
	}
	*blockScalar(scalar) {
		switch (this.type) {
			case "space":
			case "comment":
			case "newline":
				scalar.props.push(this.sourceToken);
				return;
			case "scalar":
				scalar.source = this.source;
				this.atNewLine = true;
				this.indent = 0;
				if (this.onNewLine) {
					let nl = this.source.indexOf("\n") + 1;
					while (nl !== 0) {
						this.onNewLine(this.offset + nl);
						nl = this.source.indexOf("\n", nl) + 1;
					}
				}
				yield* this.pop();
				break;
			default:
				yield* this.pop();
				yield* this.step();
		}
	}
	*blockMap(map$1) {
		const it = map$1.items[map$1.items.length - 1];
		switch (this.type) {
			case "newline":
				this.onKeyLine = false;
				if (it.value) {
					const end = "end" in it.value ? it.value.end : void 0;
					if ((Array.isArray(end) ? end[end.length - 1] : void 0)?.type === "comment") end?.push(this.sourceToken);
					else map$1.items.push({ start: [this.sourceToken] });
				} else if (it.sep) it.sep.push(this.sourceToken);
				else it.start.push(this.sourceToken);
				return;
			case "space":
			case "comment":
				if (it.value) map$1.items.push({ start: [this.sourceToken] });
				else if (it.sep) it.sep.push(this.sourceToken);
				else {
					if (this.atIndentedComment(it.start, map$1.indent)) {
						const end = map$1.items[map$1.items.length - 2]?.value?.end;
						if (Array.isArray(end)) {
							Array.prototype.push.apply(end, it.start);
							end.push(this.sourceToken);
							map$1.items.pop();
							return;
						}
					}
					it.start.push(this.sourceToken);
				}
				return;
		}
		if (this.indent >= map$1.indent) {
			const atMapIndent = !this.onKeyLine && this.indent === map$1.indent;
			const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
			let start = [];
			if (atNextItem && it.sep && !it.value) {
				const nl = [];
				for (let i = 0; i < it.sep.length; ++i) {
					const st = it.sep[i];
					switch (st.type) {
						case "newline":
							nl.push(i);
							break;
						case "space": break;
						case "comment":
							if (st.indent > map$1.indent) nl.length = 0;
							break;
						default: nl.length = 0;
					}
				}
				if (nl.length >= 2) start = it.sep.splice(nl[1]);
			}
			switch (this.type) {
				case "anchor":
				case "tag":
					if (atNextItem || it.value) {
						start.push(this.sourceToken);
						map$1.items.push({ start });
						this.onKeyLine = true;
					} else if (it.sep) it.sep.push(this.sourceToken);
					else it.start.push(this.sourceToken);
					return;
				case "explicit-key-ind":
					if (!it.sep && !it.explicitKey) {
						it.start.push(this.sourceToken);
						it.explicitKey = true;
					} else if (atNextItem || it.value) {
						start.push(this.sourceToken);
						map$1.items.push({
							start,
							explicitKey: true
						});
					} else this.stack.push({
						type: "block-map",
						offset: this.offset,
						indent: this.indent,
						items: [{
							start: [this.sourceToken],
							explicitKey: true
						}]
					});
					this.onKeyLine = true;
					return;
				case "map-value-ind":
					if (it.explicitKey) if (!it.sep) if (includesToken(it.start, "newline")) Object.assign(it, {
						key: null,
						sep: [this.sourceToken]
					});
					else {
						const start$1 = getFirstKeyStartProps(it.start);
						this.stack.push({
							type: "block-map",
							offset: this.offset,
							indent: this.indent,
							items: [{
								start: start$1,
								key: null,
								sep: [this.sourceToken]
							}]
						});
					}
					else if (it.value) map$1.items.push({
						start: [],
						key: null,
						sep: [this.sourceToken]
					});
					else if (includesToken(it.sep, "map-value-ind")) this.stack.push({
						type: "block-map",
						offset: this.offset,
						indent: this.indent,
						items: [{
							start,
							key: null,
							sep: [this.sourceToken]
						}]
					});
					else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
						const start$1 = getFirstKeyStartProps(it.start);
						const key = it.key;
						const sep = it.sep;
						sep.push(this.sourceToken);
						delete it.key;
						delete it.sep;
						this.stack.push({
							type: "block-map",
							offset: this.offset,
							indent: this.indent,
							items: [{
								start: start$1,
								key,
								sep
							}]
						});
					} else if (start.length > 0) it.sep = it.sep.concat(start, this.sourceToken);
					else it.sep.push(this.sourceToken);
					else if (!it.sep) Object.assign(it, {
						key: null,
						sep: [this.sourceToken]
					});
					else if (it.value || atNextItem) map$1.items.push({
						start,
						key: null,
						sep: [this.sourceToken]
					});
					else if (includesToken(it.sep, "map-value-ind")) this.stack.push({
						type: "block-map",
						offset: this.offset,
						indent: this.indent,
						items: [{
							start: [],
							key: null,
							sep: [this.sourceToken]
						}]
					});
					else it.sep.push(this.sourceToken);
					this.onKeyLine = true;
					return;
				case "alias":
				case "scalar":
				case "single-quoted-scalar":
				case "double-quoted-scalar": {
					const fs = this.flowScalar(this.type);
					if (atNextItem || it.value) {
						map$1.items.push({
							start,
							key: fs,
							sep: []
						});
						this.onKeyLine = true;
					} else if (it.sep) this.stack.push(fs);
					else {
						Object.assign(it, {
							key: fs,
							sep: []
						});
						this.onKeyLine = true;
					}
					return;
				}
				default: {
					const bv = this.startBlockValue(map$1);
					if (bv) {
						if (bv.type === "block-seq") {
							if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
								yield* this.pop({
									type: "error",
									offset: this.offset,
									message: "Unexpected block-seq-ind on same line with key",
									source: this.source
								});
								return;
							}
						} else if (atMapIndent) map$1.items.push({ start });
						this.stack.push(bv);
						return;
					}
				}
			}
		}
		yield* this.pop();
		yield* this.step();
	}
	*blockSequence(seq$1) {
		const it = seq$1.items[seq$1.items.length - 1];
		switch (this.type) {
			case "newline":
				if (it.value) {
					const end = "end" in it.value ? it.value.end : void 0;
					if ((Array.isArray(end) ? end[end.length - 1] : void 0)?.type === "comment") end?.push(this.sourceToken);
					else seq$1.items.push({ start: [this.sourceToken] });
				} else it.start.push(this.sourceToken);
				return;
			case "space":
			case "comment":
				if (it.value) seq$1.items.push({ start: [this.sourceToken] });
				else {
					if (this.atIndentedComment(it.start, seq$1.indent)) {
						const end = seq$1.items[seq$1.items.length - 2]?.value?.end;
						if (Array.isArray(end)) {
							Array.prototype.push.apply(end, it.start);
							end.push(this.sourceToken);
							seq$1.items.pop();
							return;
						}
					}
					it.start.push(this.sourceToken);
				}
				return;
			case "anchor":
			case "tag":
				if (it.value || this.indent <= seq$1.indent) break;
				it.start.push(this.sourceToken);
				return;
			case "seq-item-ind":
				if (this.indent !== seq$1.indent) break;
				if (it.value || includesToken(it.start, "seq-item-ind")) seq$1.items.push({ start: [this.sourceToken] });
				else it.start.push(this.sourceToken);
				return;
		}
		if (this.indent > seq$1.indent) {
			const bv = this.startBlockValue(seq$1);
			if (bv) {
				this.stack.push(bv);
				return;
			}
		}
		yield* this.pop();
		yield* this.step();
	}
	*flowCollection(fc) {
		const it = fc.items[fc.items.length - 1];
		if (this.type === "flow-error-end") {
			let top;
			do {
				yield* this.pop();
				top = this.peek(1);
			} while (top?.type === "flow-collection");
		} else if (fc.end.length === 0) {
			switch (this.type) {
				case "comma":
				case "explicit-key-ind":
					if (!it || it.sep) fc.items.push({ start: [this.sourceToken] });
					else it.start.push(this.sourceToken);
					return;
				case "map-value-ind":
					if (!it || it.value) fc.items.push({
						start: [],
						key: null,
						sep: [this.sourceToken]
					});
					else if (it.sep) it.sep.push(this.sourceToken);
					else Object.assign(it, {
						key: null,
						sep: [this.sourceToken]
					});
					return;
				case "space":
				case "comment":
				case "newline":
				case "anchor":
				case "tag":
					if (!it || it.value) fc.items.push({ start: [this.sourceToken] });
					else if (it.sep) it.sep.push(this.sourceToken);
					else it.start.push(this.sourceToken);
					return;
				case "alias":
				case "scalar":
				case "single-quoted-scalar":
				case "double-quoted-scalar": {
					const fs = this.flowScalar(this.type);
					if (!it || it.value) fc.items.push({
						start: [],
						key: fs,
						sep: []
					});
					else if (it.sep) this.stack.push(fs);
					else Object.assign(it, {
						key: fs,
						sep: []
					});
					return;
				}
				case "flow-map-end":
				case "flow-seq-end":
					fc.end.push(this.sourceToken);
					return;
			}
			const bv = this.startBlockValue(fc);
			/* istanbul ignore else should not happen */
			if (bv) this.stack.push(bv);
			else {
				yield* this.pop();
				yield* this.step();
			}
		} else {
			const parent = this.peek(2);
			if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
				yield* this.pop();
				yield* this.step();
			} else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
				const start = getFirstKeyStartProps(getPrevProps(parent));
				fixFlowSeqItems(fc);
				const sep = fc.end.splice(1, fc.end.length);
				sep.push(this.sourceToken);
				const map$1 = {
					type: "block-map",
					offset: fc.offset,
					indent: fc.indent,
					items: [{
						start,
						key: fc,
						sep
					}]
				};
				this.onKeyLine = true;
				this.stack[this.stack.length - 1] = map$1;
			} else yield* this.lineEnd(fc);
		}
	}
	flowScalar(type) {
		if (this.onNewLine) {
			let nl = this.source.indexOf("\n") + 1;
			while (nl !== 0) {
				this.onNewLine(this.offset + nl);
				nl = this.source.indexOf("\n", nl) + 1;
			}
		}
		return {
			type,
			offset: this.offset,
			indent: this.indent,
			source: this.source
		};
	}
	startBlockValue(parent) {
		switch (this.type) {
			case "alias":
			case "scalar":
			case "single-quoted-scalar":
			case "double-quoted-scalar": return this.flowScalar(this.type);
			case "block-scalar-header": return {
				type: "block-scalar",
				offset: this.offset,
				indent: this.indent,
				props: [this.sourceToken],
				source: ""
			};
			case "flow-map-start":
			case "flow-seq-start": return {
				type: "flow-collection",
				offset: this.offset,
				indent: this.indent,
				start: this.sourceToken,
				items: [],
				end: []
			};
			case "seq-item-ind": return {
				type: "block-seq",
				offset: this.offset,
				indent: this.indent,
				items: [{ start: [this.sourceToken] }]
			};
			case "explicit-key-ind": {
				this.onKeyLine = true;
				const start = getFirstKeyStartProps(getPrevProps(parent));
				start.push(this.sourceToken);
				return {
					type: "block-map",
					offset: this.offset,
					indent: this.indent,
					items: [{
						start,
						explicitKey: true
					}]
				};
			}
			case "map-value-ind": {
				this.onKeyLine = true;
				const start = getFirstKeyStartProps(getPrevProps(parent));
				return {
					type: "block-map",
					offset: this.offset,
					indent: this.indent,
					items: [{
						start,
						key: null,
						sep: [this.sourceToken]
					}]
				};
			}
		}
		return null;
	}
	atIndentedComment(start, indent) {
		if (this.type !== "comment") return false;
		if (this.indent <= indent) return false;
		return start.every((st) => st.type === "newline" || st.type === "space");
	}
	*documentEnd(docEnd) {
		if (this.type !== "doc-mode") {
			if (docEnd.end) docEnd.end.push(this.sourceToken);
			else docEnd.end = [this.sourceToken];
			if (this.type === "newline") yield* this.pop();
		}
	}
	*lineEnd(token) {
		switch (this.type) {
			case "comma":
			case "doc-start":
			case "doc-end":
			case "flow-seq-end":
			case "flow-map-end":
			case "map-value-ind":
				yield* this.pop();
				yield* this.step();
				break;
			case "newline": this.onKeyLine = false;
			case "space":
			case "comment":
			default:
				if (token.end) token.end.push(this.sourceToken);
				else token.end = [this.sourceToken];
				if (this.type === "newline") yield* this.pop();
		}
	}
};
function parseOptions(options$1) {
	const prettyErrors = options$1.prettyErrors !== false;
	return {
		lineCounter: options$1.lineCounter || prettyErrors && new LineCounter() || null,
		prettyErrors
	};
}
function parseDocument(source, options$1 = {}) {
	const { lineCounter, prettyErrors } = parseOptions(options$1);
	const parser = new Parser(lineCounter?.addNewLine);
	const composer = new Composer(options$1);
	let doc = null;
	for (const _doc of composer.compose(parser.parse(source), true, source.length)) if (!doc) doc = _doc;
	else if (doc.options.logLevel !== "silent") {
		doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
		break;
	}
	if (prettyErrors && lineCounter) {
		doc.errors.forEach(prettifyError(source, lineCounter));
		doc.warnings.forEach(prettifyError(source, lineCounter));
	}
	return doc;
}
function parse(src, reviver, options$1) {
	let _reviver = void 0;
	if (typeof reviver === "function") _reviver = reviver;
	else if (options$1 === void 0 && reviver && typeof reviver === "object") options$1 = reviver;
	const doc = parseDocument(src, options$1);
	if (!doc) return null;
	doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
	if (doc.errors.length > 0) if (doc.options.logLevel !== "silent") throw doc.errors[0];
	else doc.errors = [];
	return doc.toJS(Object.assign({ reviver: _reviver }, options$1));
}
function stringify(value, replacer, options$1) {
	let _replacer = null;
	if (typeof replacer === "function" || Array.isArray(replacer)) _replacer = replacer;
	else if (options$1 === void 0 && replacer) options$1 = replacer;
	if (typeof options$1 === "string") options$1 = options$1.length;
	if (typeof options$1 === "number") {
		const indent = Math.round(options$1);
		options$1 = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
	}
	if (value === void 0) {
		const { keepUndefined } = options$1 ?? replacer ?? {};
		if (!keepUndefined) return void 0;
	}
	if (isDocument(value) && !_replacer) return value.toString(options$1);
	return new Document$1(value, _replacer, options$1).toString(options$1);
}
function toDefaultArgs(args) {
	return args.map((a) => ({
		id: a.id,
		value: a.default
	}));
}
function argsToPayloadReduce(total, current) {
	total[current.id] = current.value;
	return total;
}
const useAppStore = create((set$1, get) => ({
	serverAddress: window.location.origin,
	detectorIndex: 0,
	detectors: [],
	segmenterIndex: 0,
	segmenters: [],
	translatorIndex: 0,
	translators: [],
	ocrIndex: 0,
	ocrs: [],
	drawerIndex: 0,
	drawers: [],
	cleanerIndex: 0,
	cleaners: [],
	detectorArgs: [],
	segmenterArgs: [],
	translatorArgs: [],
	ocrArgs: [],
	drawerArgs: [],
	cleanerArgs: [],
	operation: EAppOperation.CLEANING,
	originalImageAddress: "",
	convertedImageAddress: "",
	convertedImageLoading: false,
	imageFit: EImageFit.FIT_TO_PAGE,
	setDetectorIndex: (id) => set$1({
		detectorIndex: id,
		translatorArgs: toDefaultArgs(get().detectors[id].args)
	}),
	setSegmenterIndex: (id) => set$1({
		segmenterIndex: id,
		translatorArgs: toDefaultArgs(get().segmenters[id].args)
	}),
	setTranslatorIndex: (id) => set$1({
		translatorIndex: id,
		translatorArgs: toDefaultArgs(get().translators[id].args)
	}),
	setOcrIndex: (id) => set$1({
		ocrIndex: id,
		ocrArgs: toDefaultArgs(get().ocrs[id].args)
	}),
	setDrawerIndex: (id) => set$1({
		drawerIndex: id,
		drawerArgs: toDefaultArgs(get().drawers[id].args)
	}),
	setCleanerIndex: (id) => set$1({
		cleanerIndex: id,
		cleanerArgs: toDefaultArgs(get().cleaners[id].args)
	}),
	setServerAddress: (address) => set$1({ serverAddress: address }),
	setImageAddress: (address) => set$1({
		originalImageAddress: address,
		convertedImageAddress: "",
		convertedImageLoading: false
	}),
	setConvertedAddress: (address) => set$1({ convertedImageAddress: address }),
	setSelectedOperation: (operation) => set$1({ operation }),
	setImageFit: (fit) => set$1({ imageFit: fit }),
	setConvertedImageLoading: (state) => set$1({ convertedImageLoading: state }),
	setDetectorArgument: (index$3, value) => {
		const args = get().detectorArgs;
		args[index$3].value = value;
		set$1({ detectorArgs: [...args] });
	},
	setSegmenterArgument: (index$3, value) => {
		const args = get().segmenterArgs;
		args[index$3].value = value;
		set$1({ segmenterArgs: [...args] });
	},
	setTranslatorArgument: (index$3, value) => {
		const args = get().translatorArgs;
		args[index$3].value = value;
		set$1({ translatorArgs: [...args] });
	},
	setOcrArgument: (index$3, value) => {
		const args = get().ocrArgs;
		args[index$3].value = value;
		set$1({ ocrArgs: [...args] });
	},
	setDrawerArgument: (index$3, value) => {
		const args = get().drawerArgs;
		args[index$3].value = value;
		set$1({ drawerArgs: [...args] });
	},
	setCleanerArgument: (index$3, value) => {
		const args = get().cleanerArgs;
		args[index$3].value = value;
		set$1({ cleanerArgs: [...args] });
	},
	getServerInfo: async () => {
		const { serverAddress } = get();
		const serverApiInfo = await fetch(serverAddress + "/info").then((a) => a.json());
		set$1({
			detectors: serverApiInfo.detectors,
			segmenters: serverApiInfo.segmenters,
			translators: serverApiInfo.translators,
			ocrs: serverApiInfo.ocrs,
			cleaners: serverApiInfo.cleaners,
			drawers: serverApiInfo.drawers,
			detectorIndex: 0,
			segmenterIndex: 0,
			translatorIndex: 0,
			ocrIndex: 0,
			cleanerIndex: 0,
			detectorArgs: toDefaultArgs(serverApiInfo.detectors[0].args),
			segmenterArgs: toDefaultArgs(serverApiInfo.segmenters[0].args),
			translatorArgs: toDefaultArgs(serverApiInfo.translators[0].args),
			ocrArgs: toDefaultArgs(serverApiInfo.ocrs[0].args),
			cleanerArgs: toDefaultArgs(serverApiInfo.cleaners[0].args),
			drawerArgs: toDefaultArgs(serverApiInfo.drawers[0].args)
		});
		console.log(serverApiInfo);
		return serverApiInfo;
	},
	performCurrentOperation: async () => {
		try {
			const { operation, serverAddress, originalImageAddress, convertedImageAddress } = get();
			if (convertedImageAddress !== "") {
				URL.revokeObjectURL(convertedImageAddress);
				set$1({ convertedImageAddress: "" });
			}
			set$1({ convertedImageLoading: true });
			const data = get().makeServerPayload();
			const formData = new FormData();
			formData.append("data", JSON.stringify(data));
			formData.append("file", await fetch(originalImageAddress).then((a) => a.blob()));
			set$1({
				convertedImageAddress: await fetch(serverAddress + (operation === EAppOperation.CLEANING ? "/clean" : "/translate"), {
					method: "POST",
					body: formData
				}).then(async (a) => {
					if (a.status === 500) throw new Error(await a.text());
					return a.blob();
				}).then(URL.createObjectURL),
				convertedImageLoading: false
			});
			return convertedImageAddress;
		} catch (error) {
			set$1({ convertedImageLoading: false });
			throw error;
		}
	},
	loadConfig: async (file) => {
		const data = parse(await file.text())["pipeline"];
		const detector = data["detector"];
		const segmenter = data["segmenter"];
		const translator = data["translator"];
		const cleaner = data["cleaner"];
		const drawer = data["drawer"];
		const ocr = data["ocr"];
		const state = get();
		const newState = {};
		const tryUpdateState = (prefix$1, inputData, newState$1) => {
			const idx = state[`${prefix$1}s`].findIndex((c) => c.id === inputData["class"]);
			newState$1[`${prefix$1}Index`] = idx === -1 ? 0 : idx;
			if (state[`${prefix$1}s`][idx]) {
				newState$1[`${prefix$1}Args`] = toDefaultArgs(state[`${prefix$1}s`][idx].args);
				if (inputData["args"]) {
					const stateArgs = newState$1[`${prefix$1}Args`];
					for (const arg of Object.entries(inputData["args"])) {
						const stateArg = stateArgs.find((c) => c.id === arg[0]);
						if (stateArg) stateArg.value = arg[1];
					}
				}
			}
		};
		if (detector) tryUpdateState("detector", detector, newState);
		if (segmenter) tryUpdateState("segmenter", segmenter, newState);
		if (translator) tryUpdateState("translator", translator, newState);
		if (cleaner) tryUpdateState("cleaner", cleaner, newState);
		if (drawer) tryUpdateState("drawer", drawer, newState);
		if (ocr) tryUpdateState("ocr", ocr, newState);
		console.log("YAML", data, newState);
		set$1(newState);
	},
	makeServerPayload: () => {
		const { detectorIndex, segmenterIndex, translatorIndex, ocrIndex, drawerIndex, cleanerIndex, detectors, segmenters, translators, ocrs, drawers, cleaners, detectorArgs, segmenterArgs, translatorArgs, ocrArgs, drawerArgs, cleanerArgs } = get();
		return {
			detector: {
				id: detectors[detectorIndex].id,
				args: detectorArgs.reduce(argsToPayloadReduce, {})
			},
			segmenter: {
				id: segmenters[segmenterIndex].id,
				args: segmenterArgs.reduce(argsToPayloadReduce, {})
			},
			translator: {
				id: translators[translatorIndex].id,
				args: translatorArgs.reduce(argsToPayloadReduce, {})
			},
			ocr: {
				id: ocrs[ocrIndex].id,
				args: ocrArgs.reduce(argsToPayloadReduce, {})
			},
			drawer: {
				id: drawers[drawerIndex].id,
				args: drawerArgs.reduce(argsToPayloadReduce, {})
			},
			cleaner: {
				id: cleaners[cleanerIndex].id,
				args: cleanerArgs.reduce(argsToPayloadReduce, {})
			}
		};
	},
	exportConfig: () => {
		const data = get().makeServerPayload();
		for (const key of Object.keys(data)) {
			data[key]["class"] = data[key]["id"];
			delete data[key]["id"];
		}
		return stringify({ pipeline: data }, {}).replaceAll("{}", "");
	}
}));
/**
* @license React
* react-jsx-runtime.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_react_jsx_runtime_production = /* @__PURE__ */ __commonJSMin(((exports) => {
	var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
	function jsxProd(type, config, maybeKey) {
		var key = null;
		void 0 !== maybeKey && (key = "" + maybeKey);
		void 0 !== config.key && (key = "" + config.key);
		if ("key" in config) {
			maybeKey = {};
			for (var propName in config) "key" !== propName && (maybeKey[propName] = config[propName]);
		} else maybeKey = config;
		config = maybeKey.ref;
		return {
			$$typeof: REACT_ELEMENT_TYPE,
			type,
			key,
			ref: void 0 !== config ? config : null,
			props: maybeKey
		};
	}
	exports.Fragment = REACT_FRAGMENT_TYPE;
	exports.jsx = jsxProd;
	exports.jsxs = jsxProd;
}));
var import_jsx_runtime = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_react_jsx_runtime_production();
})))(), 1);
function ImageConverter() {
	const originalImageAddress = useAppStore((s) => s.originalImageAddress);
	const convertedImageAddress = useAppStore((s) => s.convertedImageAddress);
	const convertedImageLoading = useAppStore((s) => s.convertedImageLoading);
	const setConvertedImageLoading = useAppStore((s) => s.setConvertedImageLoading);
	const imageFit = useAppStore((s) => s.imageFit);
	const [hasMainImageLoaded, setHasMainImageLoaded] = (0, import_react.useState)(false);
	if (originalImageAddress.length > 0) return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: "tile",
		"data-fit": imageFit === EImageFit.FIT_TO_PAGE ? "page" : "scroll",
		style: { justifyContent: "flex-start" },
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("img", {
			className: `original${!convertedImageLoading ? "" : " loading"}`,
			src: originalImageAddress,
			alt: "original",
			onLoadStart: () => {
				setHasMainImageLoaded(false);
			},
			onLoad: () => {
				setTimeout(() => {
					setHasMainImageLoaded(true);
				}, 1e3);
			}
		}), hasMainImageLoaded && convertedImageAddress.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("img", {
			className: "converted",
			src: convertedImageAddress,
			alt: "converted",
			onLoad: () => {
				if (hasMainImageLoaded) setConvertedImageLoading(false);
			},
			style: !convertedImageLoading && hasMainImageLoaded && convertedImageAddress.length > 0 ? void 0 : { opacity: 0 }
		})]
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: "tile" });
}
var DefaultContext = {
	color: void 0,
	size: void 0,
	className: void 0,
	style: void 0,
	attr: void 0
};
var IconContext = import_react.createContext && /* @__PURE__ */ import_react.createContext(DefaultContext);
var _excluded = [
	"attr",
	"size",
	"title"
];
function _objectWithoutProperties(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _extends() {
	_extends = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends.apply(this, arguments);
}
function ownKeys(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys(Object(t), !0).forEach(function(r$2) {
			_defineProperty(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty(obj, key, value) {
	key = _toPropertyKey(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey(t) {
	var i = _toPrimitive(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function Tree2Element(tree) {
	return tree && tree.map((node, i) => /* @__PURE__ */ import_react.createElement(node.tag, _objectSpread({ key: i }, node.attr), Tree2Element(node.child)));
}
function GenIcon(data) {
	return (props) => /* @__PURE__ */ import_react.createElement(IconBase, _extends({ attr: _objectSpread({}, data.attr) }, props), Tree2Element(data.child));
}
function IconBase(props) {
	var elem = (conf) => {
		var { attr, size: size$3, title } = props, svgProps = _objectWithoutProperties(props, _excluded);
		var computedSize = size$3 || conf.size || "1em";
		var className;
		if (conf.className) className = conf.className;
		if (props.className) className = (className ? className + " " : "") + props.className;
		return /* @__PURE__ */ import_react.createElement("svg", _extends({
			stroke: "currentColor",
			fill: "currentColor",
			strokeWidth: "0"
		}, conf.attr, attr, svgProps, {
			className,
			style: _objectSpread(_objectSpread({ color: props.color || conf.color }, conf.style), props.style),
			height: computedSize,
			width: computedSize,
			xmlns: "http://www.w3.org/2000/svg"
		}), title && /* @__PURE__ */ import_react.createElement("title", null, title), props.children);
	};
	return IconContext !== void 0 ? /* @__PURE__ */ import_react.createElement(IconContext.Consumer, null, (conf) => elem(conf)) : elem(DefaultContext);
}
function FaFileUpload(props) {
	return GenIcon({
		"tag": "svg",
		"attr": { "viewBox": "0 0 384 512" },
		"child": [{
			"tag": "path",
			"attr": { "d": "M224 136V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zm65.18 216.01H224v80c0 8.84-7.16 16-16 16h-32c-8.84 0-16-7.16-16-16v-80H94.82c-14.28 0-21.41-17.29-11.27-27.36l96.42-95.7c6.65-6.61 17.39-6.61 24.04 0l96.42 95.7c10.15 10.07 3.03 27.36-11.25 27.36zM377 105L279.1 7c-4.5-4.5-10.6-7-17-7H256v128h128v-6.1c0-6.3-2.5-12.4-7-16.9z" },
			"child": []
		}]
	})(props);
}
function TileRow(props) {
	const rowId = import_react.useId();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: "tile-row",
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("label", {
			htmlFor: rowId,
			children: props.name
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			id: rowId,
			className: "tile-row-content",
			style: props.style,
			children: props.children
		})]
	});
}
function keys(object) {
	return Object.keys(object);
}
function isObject(item) {
	return item && typeof item === "object" && !Array.isArray(item);
}
function deepMerge(target, source) {
	const result = { ...target };
	const _source = source;
	if (isObject(target) && isObject(source)) Object.keys(source).forEach((key) => {
		if (isObject(_source[key])) if (!(key in target)) result[key] = _source[key];
		else result[key] = deepMerge(result[key], _source[key]);
		else result[key] = _source[key];
	});
	return result;
}
function camelToKebabCase(value) {
	return value.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
}
function getTransformedScaledValue(value) {
	if (typeof value !== "string" || !value.includes("var(--mantine-scale)")) return value;
	return value.match(/^calc\((.*?)\)$/)?.[1].split("*")[0].trim();
}
function px(value) {
	const transformedValue = getTransformedScaledValue(value);
	if (typeof transformedValue === "number") return transformedValue;
	if (typeof transformedValue === "string") {
		if (transformedValue.includes("calc") || transformedValue.includes("var")) return transformedValue;
		if (transformedValue.includes("px")) return Number(transformedValue.replace("px", ""));
		if (transformedValue.includes("rem")) return Number(transformedValue.replace("rem", "")) * 16;
		if (transformedValue.includes("em")) return Number(transformedValue.replace("em", "")) * 16;
		return Number(transformedValue);
	}
	return NaN;
}
function scaleRem(remValue) {
	if (remValue === "0rem") return "0rem";
	return `calc(${remValue} * var(--mantine-scale))`;
}
function createConverter(units, { shouldScale = false } = {}) {
	function converter(value) {
		if (value === 0 || value === "0") return `0${units}`;
		if (typeof value === "number") {
			const val = `${value / 16}${units}`;
			return shouldScale ? scaleRem(val) : val;
		}
		if (typeof value === "string") {
			if (value === "") return value;
			if (value.startsWith("calc(") || value.startsWith("clamp(") || value.includes("rgba(")) return value;
			if (value.includes(",")) return value.split(",").map((val) => converter(val)).join(",");
			if (value.includes(" ")) return value.split(" ").map((val) => converter(val)).join(" ");
			const replaced = value.replace("px", "");
			if (!Number.isNaN(Number(replaced))) {
				const val = `${Number(replaced) / 16}${units}`;
				return shouldScale ? scaleRem(val) : val;
			}
		}
		return value;
	}
	return converter;
}
var rem = createConverter("rem", { shouldScale: true });
var em = createConverter("em");
function filterProps(props) {
	return Object.keys(props).reduce((acc, key) => {
		if (props[key] !== void 0) acc[key] = props[key];
		return acc;
	}, {});
}
function isNumberLike(value) {
	if (typeof value === "number") return true;
	if (typeof value === "string") {
		if (value.startsWith("calc(") || value.startsWith("var(") || value.includes(" ") && value.trim() !== "") return true;
		const cssUnitsRegex = /^[+-]?[0-9]+(\.[0-9]+)?(px|em|rem|ex|ch|lh|rlh|vw|vh|vmin|vmax|vb|vi|svw|svh|lvw|lvh|dvw|dvh|cm|mm|in|pt|pc|q|cqw|cqh|cqi|cqb|cqmin|cqmax|%)?$/;
		return value.trim().split(/\s+/).every((val) => cssUnitsRegex.test(val));
	}
	return false;
}
function isElement(value) {
	if (Array.isArray(value) || value === null) return false;
	if (typeof value === "object") {
		if (value.type === import_react.Fragment) return false;
		return true;
	}
	return false;
}
function createSafeContext(errorMessage) {
	const Context = (0, import_react.createContext)(null);
	const useSafeContext = () => {
		const ctx = (0, import_react.useContext)(Context);
		if (ctx === null) throw new Error(errorMessage);
		return ctx;
	};
	const Provider = ({ children, value }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Context.Provider, {
		value,
		children
	});
	return [Provider, useSafeContext];
}
function createOptionalContext(initialValue = null) {
	const Context = (0, import_react.createContext)(initialValue);
	const useOptionalContext = () => (0, import_react.useContext)(Context);
	const Provider = ({ children, value }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Context.Provider, {
		value,
		children
	});
	return [Provider, useOptionalContext];
}
var elevations = {
	app: 100,
	modal: 200,
	popover: 300,
	overlay: 400,
	max: 9999
};
function getDefaultZIndex(level) {
	return elevations[level];
}
var noop = () => {};
function closeOnEscape(callback, options$1 = { active: true }) {
	if (typeof callback !== "function" || !options$1.active) return options$1.onKeyDown || noop;
	return (event) => {
		if (event.key === "Escape") {
			callback(event);
			options$1.onTrigger?.();
		}
	};
}
function getSize(size$3, prefix$1 = "size", convertToRem = true) {
	if (size$3 === void 0) return;
	return isNumberLike(size$3) ? convertToRem ? rem(size$3) : size$3 : `var(--${prefix$1}-${size$3})`;
}
function getRadius(size$3) {
	if (size$3 === void 0) return "var(--mantine-radius-default)";
	return getSize(size$3, "mantine-radius");
}
function getFontSize(size$3) {
	return getSize(size$3, "mantine-font-size");
}
function getShadow(size$3) {
	if (!size$3) return;
	return getSize(size$3, "mantine-shadow", false);
}
function clamp(value, min$1, max$1) {
	if (min$1 === void 0 && max$1 === void 0) return value;
	if (min$1 !== void 0 && max$1 === void 0) return Math.max(value, min$1);
	if (min$1 === void 0 && max$1 !== void 0) return Math.min(value, max$1);
	return Math.min(Math.max(value, min$1), max$1);
}
function randomId(prefix$1 = "mantine-") {
	return `${prefix$1}${Math.random().toString(36).slice(2, 11)}`;
}
function useCallbackRef(callback) {
	const callbackRef = (0, import_react.useRef)(callback);
	(0, import_react.useEffect)(() => {
		callbackRef.current = callback;
	});
	return (0, import_react.useMemo)(() => ((...args) => callbackRef.current?.(...args)), []);
}
function useDebouncedCallback(callback, options$1) {
	const { delay, flushOnUnmount, leading } = typeof options$1 === "number" ? {
		delay: options$1,
		flushOnUnmount: false,
		leading: false
	} : options$1;
	const handleCallback = useCallbackRef(callback);
	const debounceTimerRef = (0, import_react.useRef)(0);
	const lastCallback = (0, import_react.useMemo)(() => {
		const currentCallback = Object.assign((...args) => {
			window.clearTimeout(debounceTimerRef.current);
			const isFirstCall = currentCallback._isFirstCall;
			currentCallback._isFirstCall = false;
			function clearTimeoutAndLeadingRef() {
				window.clearTimeout(debounceTimerRef.current);
				debounceTimerRef.current = 0;
				currentCallback._isFirstCall = true;
			}
			if (leading && isFirstCall) {
				handleCallback(...args);
				const resetLeadingState = () => {
					clearTimeoutAndLeadingRef();
				};
				const flush2 = () => {
					if (debounceTimerRef.current !== 0) {
						clearTimeoutAndLeadingRef();
						handleCallback(...args);
					}
				};
				const cancel2 = () => {
					clearTimeoutAndLeadingRef();
				};
				currentCallback.flush = flush2;
				currentCallback.cancel = cancel2;
				debounceTimerRef.current = window.setTimeout(resetLeadingState, delay);
				return;
			}
			if (leading && !isFirstCall) {
				const flush2 = () => {
					if (debounceTimerRef.current !== 0) {
						clearTimeoutAndLeadingRef();
						handleCallback(...args);
					}
				};
				const cancel2 = () => {
					clearTimeoutAndLeadingRef();
				};
				currentCallback.flush = flush2;
				currentCallback.cancel = cancel2;
				const resetLeadingState = () => {
					clearTimeoutAndLeadingRef();
				};
				debounceTimerRef.current = window.setTimeout(resetLeadingState, delay);
				return;
			}
			const flush = () => {
				if (debounceTimerRef.current !== 0) {
					clearTimeoutAndLeadingRef();
					handleCallback(...args);
				}
			};
			const cancel = () => {
				clearTimeoutAndLeadingRef();
			};
			currentCallback.flush = flush;
			currentCallback.cancel = cancel;
			debounceTimerRef.current = window.setTimeout(flush, delay);
		}, {
			flush: () => {},
			cancel: () => {},
			_isFirstCall: true
		});
		return currentCallback;
	}, [
		handleCallback,
		delay,
		leading
	]);
	(0, import_react.useEffect)(() => () => {
		if (flushOnUnmount) lastCallback.flush();
		else lastCallback.cancel();
	}, [lastCallback, flushOnUnmount]);
	return lastCallback;
}
var DEFAULT_EVENTS = ["mousedown", "touchstart"];
function useClickOutside(callback, events, nodes) {
	const ref = (0, import_react.useRef)(null);
	const eventsList = events || DEFAULT_EVENTS;
	(0, import_react.useEffect)(() => {
		const listener = (event) => {
			const { target } = event ?? {};
			if (Array.isArray(nodes)) {
				const shouldIgnore = !document.body.contains(target) && target?.tagName !== "HTML";
				nodes.every((node) => !!node && !event.composedPath().includes(node)) && !shouldIgnore && callback(event);
			} else if (ref.current && !ref.current.contains(target)) callback(event);
		};
		eventsList.forEach((fn) => document.addEventListener(fn, listener));
		return () => {
			eventsList.forEach((fn) => document.removeEventListener(fn, listener));
		};
	}, [
		ref,
		callback,
		nodes
	]);
	return ref;
}
function attachMediaListener(query, callback) {
	try {
		query.addEventListener("change", callback);
		return () => query.removeEventListener("change", callback);
	} catch (e) {
		query.addListener(callback);
		return () => query.removeListener(callback);
	}
}
function getInitialValue(query, initialValue) {
	if (typeof window !== "undefined" && "matchMedia" in window) return window.matchMedia(query).matches;
	return false;
}
function useMediaQuery(query, initialValue, { getInitialValueInEffect } = { getInitialValueInEffect: true }) {
	const [matches, setMatches] = (0, import_react.useState)(getInitialValueInEffect ? initialValue : getInitialValue(query));
	(0, import_react.useEffect)(() => {
		try {
			const mediaQuery = window.matchMedia(query);
			setMatches(mediaQuery.matches);
			return attachMediaListener(mediaQuery, (event) => setMatches(event.matches));
		} catch (e) {
			return;
		}
	}, [query]);
	return matches || false;
}
var useIsomorphicEffect = typeof document !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
function useDidUpdate(fn, dependencies) {
	const mounted = (0, import_react.useRef)(false);
	(0, import_react.useEffect)(() => () => {
		mounted.current = false;
	}, []);
	(0, import_react.useEffect)(() => {
		if (mounted.current) return fn();
		mounted.current = true;
	}, dependencies);
}
function useFocusReturn({ opened, shouldReturnFocus = true }) {
	const lastActiveElement = (0, import_react.useRef)(null);
	const returnFocus = () => {
		if (lastActiveElement.current && "focus" in lastActiveElement.current && typeof lastActiveElement.current.focus === "function") lastActiveElement.current?.focus({ preventScroll: true });
	};
	useDidUpdate(() => {
		let timeout = -1;
		const clearFocusTimeout = (event) => {
			if (event.key === "Tab") window.clearTimeout(timeout);
		};
		document.addEventListener("keydown", clearFocusTimeout);
		if (opened) lastActiveElement.current = document.activeElement;
		else if (shouldReturnFocus) timeout = window.setTimeout(returnFocus, 10);
		return () => {
			window.clearTimeout(timeout);
			document.removeEventListener("keydown", clearFocusTimeout);
		};
	}, [opened, shouldReturnFocus]);
	return returnFocus;
}
var TABBABLE_NODES = /input|select|textarea|button|object/;
var FOCUS_SELECTOR = "a, input, select, textarea, button, object, [tabindex]";
function hidden(element) {
	return element.style.display === "none";
}
function visible(element) {
	if (element.getAttribute("aria-hidden") || element.getAttribute("hidden") || element.getAttribute("type") === "hidden") return false;
	let parentElement = element;
	while (parentElement) {
		if (parentElement === document.body || parentElement.nodeType === 11) break;
		if (hidden(parentElement)) return false;
		parentElement = parentElement.parentNode;
	}
	return true;
}
function getElementTabIndex(element) {
	let tabIndex = element.getAttribute("tabindex");
	if (tabIndex === null) tabIndex = void 0;
	return parseInt(tabIndex, 10);
}
function focusable(element) {
	const nodeName = element.nodeName.toLowerCase();
	const isTabIndexNotNaN = !Number.isNaN(getElementTabIndex(element));
	return (TABBABLE_NODES.test(nodeName) && !element.disabled || (element instanceof HTMLAnchorElement ? element.href || isTabIndexNotNaN : isTabIndexNotNaN)) && visible(element);
}
function tabbable(element) {
	const tabIndex = getElementTabIndex(element);
	return (Number.isNaN(tabIndex) || tabIndex >= 0) && focusable(element);
}
function findTabbableDescendants(element) {
	return Array.from(element.querySelectorAll(FOCUS_SELECTOR)).filter(tabbable);
}
function scopeTab(node, event) {
	const tabbable$1 = findTabbableDescendants(node);
	if (!tabbable$1.length) {
		event.preventDefault();
		return;
	}
	const finalTabbable = tabbable$1[event.shiftKey ? 0 : tabbable$1.length - 1];
	const root$1 = node.getRootNode();
	let leavingFinalTabbable = finalTabbable === root$1.activeElement || node === root$1.activeElement;
	const activeElement$3 = root$1.activeElement;
	if (activeElement$3.tagName === "INPUT" && activeElement$3.getAttribute("type") === "radio") leavingFinalTabbable = tabbable$1.filter((element) => element.getAttribute("type") === "radio" && element.getAttribute("name") === activeElement$3.getAttribute("name")).includes(finalTabbable);
	if (!leavingFinalTabbable) return;
	event.preventDefault();
	const target = tabbable$1[event.shiftKey ? tabbable$1.length - 1 : 0];
	if (target) target.focus();
}
function useFocusTrap(active = true) {
	const ref = (0, import_react.useRef)(null);
	const focusNode = (node) => {
		let focusElement = node.querySelector("[data-autofocus]");
		if (!focusElement) {
			const children = Array.from(node.querySelectorAll(FOCUS_SELECTOR));
			focusElement = children.find(tabbable) || children.find(focusable) || null;
			if (!focusElement && focusable(node)) focusElement = node;
		}
		if (focusElement) focusElement.focus({ preventScroll: true });
	};
	const setRef = (0, import_react.useCallback)((node) => {
		if (!active) return;
		if (node === null) return;
		if (ref.current === node) return;
		if (node) {
			setTimeout(() => {
				if (node.getRootNode()) focusNode(node);
			});
			ref.current = node;
		} else ref.current = null;
	}, [active]);
	(0, import_react.useEffect)(() => {
		if (!active) return;
		ref.current && setTimeout(() => focusNode(ref.current));
		const handleKeyDown = (event) => {
			if (event.key === "Tab" && ref.current) scopeTab(ref.current, event);
		};
		document.addEventListener("keydown", handleKeyDown);
		return () => document.removeEventListener("keydown", handleKeyDown);
	}, [active]);
	return setRef;
}
var __useId = import_react.default["useId".toString()] || (() => void 0);
function useReactId() {
	const id = __useId();
	return id ? `mantine-${id.replace(/:/g, "")}` : "";
}
function useId(staticId) {
	const reactId = useReactId();
	const [uuid, setUuid] = (0, import_react.useState)(reactId);
	useIsomorphicEffect(() => {
		setUuid(randomId());
	}, []);
	if (typeof staticId === "string") return staticId;
	if (typeof window === "undefined") return reactId;
	return uuid;
}
function assignRef(ref, value) {
	if (typeof ref === "function") return ref(value);
	else if (typeof ref === "object" && ref !== null && "current" in ref) ref.current = value;
}
function mergeRefs(...refs) {
	const cleanupMap = /* @__PURE__ */ new Map();
	return (node) => {
		refs.forEach((ref) => {
			const cleanup = assignRef(ref, node);
			if (cleanup) cleanupMap.set(ref, cleanup);
		});
		if (cleanupMap.size > 0) return () => {
			refs.forEach((ref) => {
				const cleanup = cleanupMap.get(ref);
				if (cleanup && typeof cleanup === "function") cleanup();
				else assignRef(ref, null);
			});
			cleanupMap.clear();
		};
	};
}
function useMergedRef(...refs) {
	return (0, import_react.useCallback)(mergeRefs(...refs), refs);
}
function useUncontrolled({ value, defaultValue, finalValue, onChange = () => {} }) {
	const [uncontrolledValue, setUncontrolledValue] = (0, import_react.useState)(defaultValue !== void 0 ? defaultValue : finalValue);
	const handleUncontrolledChange = (val, ...payload) => {
		setUncontrolledValue(val);
		onChange?.(val, ...payload);
	};
	if (value !== void 0) return [
		value,
		onChange,
		true
	];
	return [
		uncontrolledValue,
		handleUncontrolledChange,
		false
	];
}
function useReducedMotion(initialValue, options$1) {
	return useMediaQuery("(prefers-reduced-motion: reduce)", initialValue, options$1);
}
function usePrevious(value) {
	const ref = (0, import_react.useRef)(void 0);
	(0, import_react.useEffect)(() => {
		ref.current = value;
	}, [value]);
	return ref.current;
}
function getRefProp(element) {
	if ("19.2.3".startsWith("18."));
	return element?.props?.ref;
}
function findElementBySelector(selector, root$1 = document) {
	const element = root$1.querySelector(selector);
	if (element) return element;
	const allElements = root$1.querySelectorAll("*");
	for (let i = 0; i < allElements.length; i += 1) {
		const el = allElements[i];
		if (el.shadowRoot) {
			const shadowElement = findElementBySelector(selector, el.shadowRoot);
			if (shadowElement) return shadowElement;
		}
	}
	return null;
}
function findElementsBySelector(selector, root$1 = document) {
	const results = [];
	const elements = root$1.querySelectorAll(selector);
	results.push(...Array.from(elements));
	const allElements = root$1.querySelectorAll("*");
	for (let i = 0; i < allElements.length; i += 1) {
		const el = allElements[i];
		if (el.shadowRoot) {
			const shadowElements = findElementsBySelector(selector, el.shadowRoot);
			results.push(...shadowElements);
		}
	}
	return results;
}
function getRootElement(targetElement) {
	if (!targetElement) return document;
	const root$1 = targetElement.getRootNode();
	return root$1 instanceof ShadowRoot || root$1 instanceof Document ? root$1 : document;
}
function getSingleElementChild(children) {
	const _children = import_react.Children.toArray(children);
	if (_children.length !== 1 || !isElement(_children[0])) return null;
	return _children[0];
}
function createVarsResolver(resolver) {
	return resolver;
}
function r(e) {
	var t, f, n = "";
	if ("string" == typeof e || "number" == typeof e) n += e;
	else if ("object" == typeof e) if (Array.isArray(e)) {
		var o = e.length;
		for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
	} else for (f in e) e[f] && (n && (n += " "), n += f);
	return n;
}
function clsx() {
	for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
	return n;
}
var clsx_default = clsx;
var EMPTY_CLASS_NAMES = {};
function mergeClassNames(objects) {
	const merged = {};
	objects.forEach((obj) => {
		Object.entries(obj).forEach(([key, value]) => {
			if (merged[key]) merged[key] = clsx_default(merged[key], value);
			else merged[key] = value;
		});
	});
	return merged;
}
function resolveClassNames({ theme: theme$1, classNames, props, stylesCtx }) {
	return mergeClassNames((Array.isArray(classNames) ? classNames : [classNames]).map((item) => typeof item === "function" ? item(theme$1, props, stylesCtx) : item || EMPTY_CLASS_NAMES));
}
function resolveStyles({ theme: theme$1, styles, props, stylesCtx }) {
	return (Array.isArray(styles) ? styles : [styles]).reduce((acc, style$1) => {
		if (typeof style$1 === "function") return {
			...acc,
			...style$1(theme$1, props, stylesCtx)
		};
		return {
			...acc,
			...style$1
		};
	}, {});
}
var MantineContext = (0, import_react.createContext)(null);
function useMantineContext() {
	const ctx = (0, import_react.useContext)(MantineContext);
	if (!ctx) throw new Error("[@mantine/core] MantineProvider was not found in tree");
	return ctx;
}
function useMantineCssVariablesResolver() {
	return useMantineContext().cssVariablesResolver;
}
function useMantineClassNamesPrefix() {
	return useMantineContext().classNamesPrefix;
}
function useMantineStyleNonce() {
	return useMantineContext().getStyleNonce;
}
function useMantineWithStaticClasses() {
	return useMantineContext().withStaticClasses;
}
function useMantineIsHeadless() {
	return useMantineContext().headless;
}
function useMantineSxTransform() {
	return useMantineContext().stylesTransform?.sx;
}
function useMantineStylesTransform() {
	return useMantineContext().stylesTransform?.styles;
}
function useMantineEnv() {
	return useMantineContext().env || "default";
}
function isHexColor(hex) {
	return /^#?([0-9A-F]{3}){1,2}([0-9A-F]{2})?$/i.test(hex);
}
function hexToRgba(color) {
	let hexString = color.replace("#", "");
	if (hexString.length === 3) {
		const shorthandHex = hexString.split("");
		hexString = [
			shorthandHex[0],
			shorthandHex[0],
			shorthandHex[1],
			shorthandHex[1],
			shorthandHex[2],
			shorthandHex[2]
		].join("");
	}
	if (hexString.length === 8) {
		const alpha$1 = parseInt(hexString.slice(6, 8), 16) / 255;
		return {
			r: parseInt(hexString.slice(0, 2), 16),
			g: parseInt(hexString.slice(2, 4), 16),
			b: parseInt(hexString.slice(4, 6), 16),
			a: alpha$1
		};
	}
	const parsed = parseInt(hexString, 16);
	return {
		r: parsed >> 16 & 255,
		g: parsed >> 8 & 255,
		b: parsed & 255,
		a: 1
	};
}
function rgbStringToRgba(color) {
	const [r$1, g, b, a] = color.replace(/[^0-9,./]/g, "").split(/[/,]/).map(Number);
	return {
		r: r$1,
		g,
		b,
		a: a === void 0 ? 1 : a
	};
}
function hslStringToRgba(hslaString) {
	const matches = hslaString.match(/^hsla?\(\s*(\d+)\s*,\s*(\d+%)\s*,\s*(\d+%)\s*(,\s*(0?\.\d+|\d+(\.\d+)?))?\s*\)$/i);
	if (!matches) return {
		r: 0,
		g: 0,
		b: 0,
		a: 1
	};
	const h = parseInt(matches[1], 10);
	const s = parseInt(matches[2], 10) / 100;
	const l = parseInt(matches[3], 10) / 100;
	const a = matches[5] ? parseFloat(matches[5]) : void 0;
	const chroma = (1 - Math.abs(2 * l - 1)) * s;
	const huePrime = h / 60;
	const x = chroma * (1 - Math.abs(huePrime % 2 - 1));
	const m = l - chroma / 2;
	let r$1;
	let g;
	let b;
	if (huePrime >= 0 && huePrime < 1) {
		r$1 = chroma;
		g = x;
		b = 0;
	} else if (huePrime >= 1 && huePrime < 2) {
		r$1 = x;
		g = chroma;
		b = 0;
	} else if (huePrime >= 2 && huePrime < 3) {
		r$1 = 0;
		g = chroma;
		b = x;
	} else if (huePrime >= 3 && huePrime < 4) {
		r$1 = 0;
		g = x;
		b = chroma;
	} else if (huePrime >= 4 && huePrime < 5) {
		r$1 = x;
		g = 0;
		b = chroma;
	} else {
		r$1 = chroma;
		g = 0;
		b = x;
	}
	return {
		r: Math.round((r$1 + m) * 255),
		g: Math.round((g + m) * 255),
		b: Math.round((b + m) * 255),
		a: a || 1
	};
}
function toRgba(color) {
	if (isHexColor(color)) return hexToRgba(color);
	if (color.startsWith("rgb")) return rgbStringToRgba(color);
	if (color.startsWith("hsl")) return hslStringToRgba(color);
	return {
		r: 0,
		g: 0,
		b: 0,
		a: 1
	};
}
function darken(color, alpha$1) {
	if (color.startsWith("var(")) return `color-mix(in srgb, ${color}, black ${alpha$1 * 100}%)`;
	const { r: r$1, g, b, a } = toRgba(color);
	const f = 1 - alpha$1;
	const dark = (input) => Math.round(input * f);
	return `rgba(${dark(r$1)}, ${dark(g)}, ${dark(b)}, ${a})`;
}
function getPrimaryShade(theme$1, colorScheme) {
	if (typeof theme$1.primaryShade === "number") return theme$1.primaryShade;
	if (colorScheme === "dark") return theme$1.primaryShade.dark;
	return theme$1.primaryShade.light;
}
function gammaCorrect(c) {
	return c <= .03928 ? c / 12.92 : ((c + .055) / 1.055) ** 2.4;
}
function getLightnessFromOklch(oklchColor) {
	const match = oklchColor.match(/oklch\((.*?)%\s/);
	return match ? parseFloat(match[1]) : null;
}
function luminance(color) {
	if (color.startsWith("oklch(")) return (getLightnessFromOklch(color) || 0) / 100;
	const { r: r$1, g, b } = toRgba(color);
	const sR = r$1 / 255;
	const sG = g / 255;
	const sB = b / 255;
	const rLinear = gammaCorrect(sR);
	const gLinear = gammaCorrect(sG);
	const bLinear = gammaCorrect(sB);
	return .2126 * rLinear + .7152 * gLinear + .0722 * bLinear;
}
function isLightColor(color, luminanceThreshold = .179) {
	if (color.startsWith("var(")) return false;
	return luminance(color) > luminanceThreshold;
}
function parseThemeColor({ color, theme: theme$1, colorScheme }) {
	if (typeof color !== "string") throw new Error(`[@mantine/core] Failed to parse color. Expected color to be a string, instead got ${typeof color}`);
	if (color === "bright") return {
		color,
		value: colorScheme === "dark" ? theme$1.white : theme$1.black,
		shade: void 0,
		isThemeColor: false,
		isLight: isLightColor(colorScheme === "dark" ? theme$1.white : theme$1.black, theme$1.luminanceThreshold),
		variable: "--mantine-color-bright"
	};
	if (color === "dimmed") return {
		color,
		value: colorScheme === "dark" ? theme$1.colors.dark[2] : theme$1.colors.gray[7],
		shade: void 0,
		isThemeColor: false,
		isLight: isLightColor(colorScheme === "dark" ? theme$1.colors.dark[2] : theme$1.colors.gray[6], theme$1.luminanceThreshold),
		variable: "--mantine-color-dimmed"
	};
	if (color === "white" || color === "black") return {
		color,
		value: color === "white" ? theme$1.white : theme$1.black,
		shade: void 0,
		isThemeColor: false,
		isLight: isLightColor(color === "white" ? theme$1.white : theme$1.black, theme$1.luminanceThreshold),
		variable: `--mantine-color-${color}`
	};
	const [_color, shade] = color.split(".");
	const colorShade = shade ? Number(shade) : void 0;
	const isThemeColor = _color in theme$1.colors;
	if (isThemeColor) {
		const colorValue = colorShade !== void 0 ? theme$1.colors[_color][colorShade] : theme$1.colors[_color][getPrimaryShade(theme$1, colorScheme || "light")];
		return {
			color: _color,
			value: colorValue,
			shade: colorShade,
			isThemeColor,
			isLight: isLightColor(colorValue, theme$1.luminanceThreshold),
			variable: shade ? `--mantine-color-${_color}-${colorShade}` : `--mantine-color-${_color}-filled`
		};
	}
	return {
		color,
		value: color,
		isThemeColor,
		isLight: isLightColor(color, theme$1.luminanceThreshold),
		shade: colorShade,
		variable: void 0
	};
}
function getThemeColor(color, theme$1) {
	const parsed = parseThemeColor({
		color: color || theme$1.primaryColor,
		theme: theme$1
	});
	return parsed.variable ? `var(${parsed.variable})` : color;
}
function getGradient(gradient, theme$1) {
	const merged = {
		from: gradient?.from || theme$1.defaultGradient.from,
		to: gradient?.to || theme$1.defaultGradient.to,
		deg: gradient?.deg ?? theme$1.defaultGradient.deg ?? 0
	};
	const fromColor = getThemeColor(merged.from, theme$1);
	const toColor = getThemeColor(merged.to, theme$1);
	return `linear-gradient(${merged.deg}deg, ${fromColor} 0%, ${toColor} 100%)`;
}
function rgba(color, alpha2) {
	if (typeof color !== "string" || alpha2 > 1 || alpha2 < 0) return "rgba(0, 0, 0, 1)";
	if (color.startsWith("var(")) return `color-mix(in srgb, ${color}, transparent ${(1 - alpha2) * 100}%)`;
	if (color.startsWith("oklch")) {
		if (color.includes("/")) return color.replace(/\/\s*[\d.]+\s*\)/, `/ ${alpha2})`);
		return color.replace(")", ` / ${alpha2})`);
	}
	const { r: r$1, g, b } = toRgba(color);
	return `rgba(${r$1}, ${g}, ${b}, ${alpha2})`;
}
var alpha = rgba;
var defaultVariantColorsResolver = ({ color, theme: theme$1, variant, gradient, autoContrast }) => {
	const parsed = parseThemeColor({
		color,
		theme: theme$1
	});
	const _autoContrast = typeof autoContrast === "boolean" ? autoContrast : theme$1.autoContrast;
	if (variant === "none") return {
		background: "transparent",
		hover: "transparent",
		color: "inherit",
		border: "none"
	};
	if (variant === "filled") {
		const textColor = _autoContrast ? parsed.isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)" : "var(--mantine-color-white)";
		if (parsed.isThemeColor) {
			if (parsed.shade === void 0) return {
				background: `var(--mantine-color-${color}-filled)`,
				hover: `var(--mantine-color-${color}-filled-hover)`,
				color: textColor,
				border: `${rem(1)} solid transparent`
			};
			return {
				background: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
				hover: `var(--mantine-color-${parsed.color}-${parsed.shade === 9 ? 8 : parsed.shade + 1})`,
				color: textColor,
				border: `${rem(1)} solid transparent`
			};
		}
		return {
			background: color,
			hover: darken(color, .1),
			color: textColor,
			border: `${rem(1)} solid transparent`
		};
	}
	if (variant === "light") {
		if (parsed.isThemeColor) {
			if (parsed.shade === void 0) return {
				background: `var(--mantine-color-${color}-light)`,
				hover: `var(--mantine-color-${color}-light-hover)`,
				color: `var(--mantine-color-${color}-light-color)`,
				border: `${rem(1)} solid transparent`
			};
			const parsedColor = theme$1.colors[parsed.color][parsed.shade];
			return {
				background: rgba(parsedColor, .1),
				hover: rgba(parsedColor, .12),
				color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
				border: `${rem(1)} solid transparent`
			};
		}
		return {
			background: rgba(color, .1),
			hover: rgba(color, .12),
			color,
			border: `${rem(1)} solid transparent`
		};
	}
	if (variant === "outline") {
		if (parsed.isThemeColor) {
			if (parsed.shade === void 0) return {
				background: "transparent",
				hover: `var(--mantine-color-${color}-outline-hover)`,
				color: `var(--mantine-color-${color}-outline)`,
				border: `${rem(1)} solid var(--mantine-color-${color}-outline)`
			};
			return {
				background: "transparent",
				hover: rgba(theme$1.colors[parsed.color][parsed.shade], .05),
				color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
				border: `${rem(1)} solid var(--mantine-color-${parsed.color}-${parsed.shade})`
			};
		}
		return {
			background: "transparent",
			hover: rgba(color, .05),
			color,
			border: `${rem(1)} solid ${color}`
		};
	}
	if (variant === "subtle") {
		if (parsed.isThemeColor) {
			if (parsed.shade === void 0) return {
				background: "transparent",
				hover: `var(--mantine-color-${color}-light-hover)`,
				color: `var(--mantine-color-${color}-light-color)`,
				border: `${rem(1)} solid transparent`
			};
			const parsedColor = theme$1.colors[parsed.color][parsed.shade];
			return {
				background: "transparent",
				hover: rgba(parsedColor, .12),
				color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
				border: `${rem(1)} solid transparent`
			};
		}
		return {
			background: "transparent",
			hover: rgba(color, .12),
			color,
			border: `${rem(1)} solid transparent`
		};
	}
	if (variant === "transparent") {
		if (parsed.isThemeColor) {
			if (parsed.shade === void 0) return {
				background: "transparent",
				hover: "transparent",
				color: `var(--mantine-color-${color}-light-color)`,
				border: `${rem(1)} solid transparent`
			};
			return {
				background: "transparent",
				hover: "transparent",
				color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
				border: `${rem(1)} solid transparent`
			};
		}
		return {
			background: "transparent",
			hover: "transparent",
			color,
			border: `${rem(1)} solid transparent`
		};
	}
	if (variant === "white") {
		if (parsed.isThemeColor) {
			if (parsed.shade === void 0) return {
				background: "var(--mantine-color-white)",
				hover: darken(theme$1.white, .01),
				color: `var(--mantine-color-${color}-filled)`,
				border: `${rem(1)} solid transparent`
			};
			return {
				background: "var(--mantine-color-white)",
				hover: darken(theme$1.white, .01),
				color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
				border: `${rem(1)} solid transparent`
			};
		}
		return {
			background: "var(--mantine-color-white)",
			hover: darken(theme$1.white, .01),
			color,
			border: `${rem(1)} solid transparent`
		};
	}
	if (variant === "gradient") return {
		background: getGradient(gradient, theme$1),
		hover: getGradient(gradient, theme$1),
		color: "var(--mantine-color-white)",
		border: "none"
	};
	if (variant === "default") return {
		background: "var(--mantine-color-default)",
		hover: "var(--mantine-color-default-hover)",
		color: "var(--mantine-color-default-color)",
		border: `${rem(1)} solid var(--mantine-color-default-border)`
	};
	return {};
};
var DEFAULT_COLORS = {
	dark: [
		"#C9C9C9",
		"#b8b8b8",
		"#828282",
		"#696969",
		"#424242",
		"#3b3b3b",
		"#2e2e2e",
		"#242424",
		"#1f1f1f",
		"#141414"
	],
	gray: [
		"#f8f9fa",
		"#f1f3f5",
		"#e9ecef",
		"#dee2e6",
		"#ced4da",
		"#adb5bd",
		"#868e96",
		"#495057",
		"#343a40",
		"#212529"
	],
	red: [
		"#fff5f5",
		"#ffe3e3",
		"#ffc9c9",
		"#ffa8a8",
		"#ff8787",
		"#ff6b6b",
		"#fa5252",
		"#f03e3e",
		"#e03131",
		"#c92a2a"
	],
	pink: [
		"#fff0f6",
		"#ffdeeb",
		"#fcc2d7",
		"#faa2c1",
		"#f783ac",
		"#f06595",
		"#e64980",
		"#d6336c",
		"#c2255c",
		"#a61e4d"
	],
	grape: [
		"#f8f0fc",
		"#f3d9fa",
		"#eebefa",
		"#e599f7",
		"#da77f2",
		"#cc5de8",
		"#be4bdb",
		"#ae3ec9",
		"#9c36b5",
		"#862e9c"
	],
	violet: [
		"#f3f0ff",
		"#e5dbff",
		"#d0bfff",
		"#b197fc",
		"#9775fa",
		"#845ef7",
		"#7950f2",
		"#7048e8",
		"#6741d9",
		"#5f3dc4"
	],
	indigo: [
		"#edf2ff",
		"#dbe4ff",
		"#bac8ff",
		"#91a7ff",
		"#748ffc",
		"#5c7cfa",
		"#4c6ef5",
		"#4263eb",
		"#3b5bdb",
		"#364fc7"
	],
	blue: [
		"#e7f5ff",
		"#d0ebff",
		"#a5d8ff",
		"#74c0fc",
		"#4dabf7",
		"#339af0",
		"#228be6",
		"#1c7ed6",
		"#1971c2",
		"#1864ab"
	],
	cyan: [
		"#e3fafc",
		"#c5f6fa",
		"#99e9f2",
		"#66d9e8",
		"#3bc9db",
		"#22b8cf",
		"#15aabf",
		"#1098ad",
		"#0c8599",
		"#0b7285"
	],
	teal: [
		"#e6fcf5",
		"#c3fae8",
		"#96f2d7",
		"#63e6be",
		"#38d9a9",
		"#20c997",
		"#12b886",
		"#0ca678",
		"#099268",
		"#087f5b"
	],
	green: [
		"#ebfbee",
		"#d3f9d8",
		"#b2f2bb",
		"#8ce99a",
		"#69db7c",
		"#51cf66",
		"#40c057",
		"#37b24d",
		"#2f9e44",
		"#2b8a3e"
	],
	lime: [
		"#f4fce3",
		"#e9fac8",
		"#d8f5a2",
		"#c0eb75",
		"#a9e34b",
		"#94d82d",
		"#82c91e",
		"#74b816",
		"#66a80f",
		"#5c940d"
	],
	yellow: [
		"#fff9db",
		"#fff3bf",
		"#ffec99",
		"#ffe066",
		"#ffd43b",
		"#fcc419",
		"#fab005",
		"#f59f00",
		"#f08c00",
		"#e67700"
	],
	orange: [
		"#fff4e6",
		"#ffe8cc",
		"#ffd8a8",
		"#ffc078",
		"#ffa94d",
		"#ff922b",
		"#fd7e14",
		"#f76707",
		"#e8590c",
		"#d9480f"
	]
};
var DEFAULT_FONT_FAMILY = "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji";
var DEFAULT_THEME = {
	scale: 1,
	fontSmoothing: true,
	focusRing: "auto",
	white: "#fff",
	black: "#000",
	colors: DEFAULT_COLORS,
	primaryShade: {
		light: 6,
		dark: 8
	},
	primaryColor: "blue",
	variantColorResolver: defaultVariantColorsResolver,
	autoContrast: false,
	luminanceThreshold: .3,
	fontFamily: DEFAULT_FONT_FAMILY,
	fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
	respectReducedMotion: false,
	cursorType: "default",
	defaultGradient: {
		from: "blue",
		to: "cyan",
		deg: 45
	},
	defaultRadius: "sm",
	activeClassName: "mantine-active",
	focusClassName: "",
	headings: {
		fontFamily: DEFAULT_FONT_FAMILY,
		fontWeight: "700",
		textWrap: "wrap",
		sizes: {
			h1: {
				fontSize: rem(34),
				lineHeight: "1.3"
			},
			h2: {
				fontSize: rem(26),
				lineHeight: "1.35"
			},
			h3: {
				fontSize: rem(22),
				lineHeight: "1.4"
			},
			h4: {
				fontSize: rem(18),
				lineHeight: "1.45"
			},
			h5: {
				fontSize: rem(16),
				lineHeight: "1.5"
			},
			h6: {
				fontSize: rem(14),
				lineHeight: "1.5"
			}
		}
	},
	fontSizes: {
		xs: rem(12),
		sm: rem(14),
		md: rem(16),
		lg: rem(18),
		xl: rem(20)
	},
	lineHeights: {
		xs: "1.4",
		sm: "1.45",
		md: "1.55",
		lg: "1.6",
		xl: "1.65"
	},
	radius: {
		xs: rem(2),
		sm: rem(4),
		md: rem(8),
		lg: rem(16),
		xl: rem(32)
	},
	spacing: {
		xs: rem(10),
		sm: rem(12),
		md: rem(16),
		lg: rem(20),
		xl: rem(32)
	},
	breakpoints: {
		xs: "36em",
		sm: "48em",
		md: "62em",
		lg: "75em",
		xl: "88em"
	},
	shadows: {
		xs: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), 0 ${rem(1)} ${rem(2)} rgba(0, 0, 0, 0.1)`,
		sm: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(10)} ${rem(15)} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(7)} ${rem(7)} ${rem(-5)}`,
		md: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(20)} ${rem(25)} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(10)} ${rem(10)} ${rem(-5)}`,
		lg: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(28)} ${rem(23)} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(12)} ${rem(12)} ${rem(-7)}`,
		xl: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(36)} ${rem(28)} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(17)} ${rem(17)} ${rem(-7)}`
	},
	other: {},
	components: {}
};
function isMantineColorScheme(value) {
	return value === "auto" || value === "dark" || value === "light";
}
function localStorageColorSchemeManager({ key = "mantine-color-scheme-value" } = {}) {
	let handleStorageEvent;
	return {
		get: (defaultValue) => {
			if (typeof window === "undefined") return defaultValue;
			try {
				const storedColorScheme = window.localStorage.getItem(key);
				return isMantineColorScheme(storedColorScheme) ? storedColorScheme : defaultValue;
			} catch {
				return defaultValue;
			}
		},
		set: (value) => {
			try {
				window.localStorage.setItem(key, value);
			} catch (error) {
				console.warn("[@mantine/core] Local storage color scheme manager was unable to save color scheme.", error);
			}
		},
		subscribe: (onUpdate) => {
			handleStorageEvent = (event) => {
				if (event.storageArea === window.localStorage && event.key === key) isMantineColorScheme(event.newValue) && onUpdate(event.newValue);
			};
			window.addEventListener("storage", handleStorageEvent);
		},
		unsubscribe: () => {
			window.removeEventListener("storage", handleStorageEvent);
		},
		clear: () => {
			window.localStorage.removeItem(key);
		}
	};
}
var INVALID_PRIMARY_COLOR_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more  https://mantine.dev/theming/colors/#primary-color";
var INVALID_PRIMARY_SHADE_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryShade, it accepts only 0-9 integers or an object { light: 0-9, dark: 0-9 }";
function isValidPrimaryShade(shade) {
	if (shade < 0 || shade > 9) return false;
	return parseInt(shade.toString(), 10) === shade;
}
function validateMantineTheme(theme$1) {
	if (!(theme$1.primaryColor in theme$1.colors)) throw new Error(INVALID_PRIMARY_COLOR_ERROR);
	if (typeof theme$1.primaryShade === "object") {
		if (!isValidPrimaryShade(theme$1.primaryShade.dark) || !isValidPrimaryShade(theme$1.primaryShade.light)) throw new Error(INVALID_PRIMARY_SHADE_ERROR);
	}
	if (typeof theme$1.primaryShade === "number" && !isValidPrimaryShade(theme$1.primaryShade)) throw new Error(INVALID_PRIMARY_SHADE_ERROR);
}
function mergeMantineTheme(currentTheme, themeOverride) {
	if (!themeOverride) {
		validateMantineTheme(currentTheme);
		return currentTheme;
	}
	const result = deepMerge(currentTheme, themeOverride);
	if (themeOverride.fontFamily && !themeOverride.headings?.fontFamily) result.headings.fontFamily = themeOverride.fontFamily;
	validateMantineTheme(result);
	return result;
}
var MantineThemeContext = (0, import_react.createContext)(null);
var useSafeMantineTheme = () => (0, import_react.useContext)(MantineThemeContext) || DEFAULT_THEME;
function useMantineTheme() {
	const ctx = (0, import_react.useContext)(MantineThemeContext);
	if (!ctx) throw new Error("@mantine/core: MantineProvider was not found in component tree, make sure you have it in your app");
	return ctx;
}
function MantineThemeProvider({ theme: theme$1, children, inherit = true }) {
	const parentTheme = useSafeMantineTheme();
	const mergedTheme = (0, import_react.useMemo)(() => mergeMantineTheme(inherit ? parentTheme : DEFAULT_THEME, theme$1), [
		theme$1,
		parentTheme,
		inherit
	]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MantineThemeContext.Provider, {
		value: mergedTheme,
		children
	});
}
MantineThemeProvider.displayName = "@mantine/core/MantineThemeProvider";
function MantineClasses() {
	const theme$1 = useMantineTheme();
	const nonce = useMantineStyleNonce();
	const classes$14 = keys(theme$1.breakpoints).reduce((acc, breakpoint) => {
		const isPxBreakpoint = theme$1.breakpoints[breakpoint].includes("px");
		const pxValue = px(theme$1.breakpoints[breakpoint]);
		return `${acc}@media (max-width: ${isPxBreakpoint ? `${pxValue - .1}px` : em(pxValue - .1)}) {.mantine-visible-from-${breakpoint} {display: none !important;}}@media (min-width: ${isPxBreakpoint ? `${pxValue}px` : em(pxValue)}) {.mantine-hidden-from-${breakpoint} {display: none !important;}}`;
	}, "");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("style", {
		"data-mantine-styles": "classes",
		nonce: nonce?.(),
		dangerouslySetInnerHTML: { __html: classes$14 }
	});
}
function cssVariablesObjectToString(variables) {
	return Object.entries(variables).map(([name, value]) => `${name}: ${value};`).join("");
}
function convertCssVariables(input, selectorOverride) {
	const selectors = selectorOverride ? [selectorOverride] : [":root", ":host"];
	const sharedVariables = cssVariablesObjectToString(input.variables);
	const shared = sharedVariables ? `${selectors.join(", ")}{${sharedVariables}}` : "";
	const dark = cssVariablesObjectToString(input.dark);
	const light = cssVariablesObjectToString(input.light);
	const selectorsWithScheme = (scheme) => selectors.map((selector) => selector === ":host" ? `${selector}([data-mantine-color-scheme="${scheme}"])` : `${selector}[data-mantine-color-scheme="${scheme}"]`).join(", ");
	return `${shared}

${dark ? `${selectorsWithScheme("dark")}{${dark}}` : ""}

${light ? `${selectorsWithScheme("light")}{${light}}` : ""}`;
}
function getContrastColor({ color, theme: theme$1, autoContrast }) {
	if (!(typeof autoContrast === "boolean" ? autoContrast : theme$1.autoContrast)) return "var(--mantine-color-white)";
	return parseThemeColor({
		color: color || theme$1.primaryColor,
		theme: theme$1
	}).isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
}
function getPrimaryContrastColor(theme$1, colorScheme) {
	return getContrastColor({
		color: theme$1.colors[theme$1.primaryColor][getPrimaryShade(theme$1, colorScheme)],
		theme: theme$1,
		autoContrast: null
	});
}
function getCSSColorVariables({ theme: theme$1, color, colorScheme, name = color, withColorValues = true }) {
	if (!theme$1.colors[color]) return {};
	if (colorScheme === "light") {
		const primaryShade2 = getPrimaryShade(theme$1, "light");
		const dynamicVariables2 = {
			[`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-filled)`,
			[`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade2})`,
			[`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade2 === 9 ? 8 : primaryShade2 + 1})`,
			[`--mantine-color-${name}-light`]: alpha(theme$1.colors[color][primaryShade2], .1),
			[`--mantine-color-${name}-light-hover`]: alpha(theme$1.colors[color][primaryShade2], .12),
			[`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${primaryShade2})`,
			[`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${primaryShade2})`,
			[`--mantine-color-${name}-outline-hover`]: alpha(theme$1.colors[color][primaryShade2], .05)
		};
		if (!withColorValues) return dynamicVariables2;
		return {
			[`--mantine-color-${name}-0`]: theme$1.colors[color][0],
			[`--mantine-color-${name}-1`]: theme$1.colors[color][1],
			[`--mantine-color-${name}-2`]: theme$1.colors[color][2],
			[`--mantine-color-${name}-3`]: theme$1.colors[color][3],
			[`--mantine-color-${name}-4`]: theme$1.colors[color][4],
			[`--mantine-color-${name}-5`]: theme$1.colors[color][5],
			[`--mantine-color-${name}-6`]: theme$1.colors[color][6],
			[`--mantine-color-${name}-7`]: theme$1.colors[color][7],
			[`--mantine-color-${name}-8`]: theme$1.colors[color][8],
			[`--mantine-color-${name}-9`]: theme$1.colors[color][9],
			...dynamicVariables2
		};
	}
	const primaryShade = getPrimaryShade(theme$1, "dark");
	const dynamicVariables = {
		[`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-4)`,
		[`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade})`,
		[`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade === 9 ? 8 : primaryShade + 1})`,
		[`--mantine-color-${name}-light`]: alpha(theme$1.colors[color][Math.max(0, primaryShade - 2)], .15),
		[`--mantine-color-${name}-light-hover`]: alpha(theme$1.colors[color][Math.max(0, primaryShade - 2)], .2),
		[`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 5, 0)})`,
		[`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 4, 0)})`,
		[`--mantine-color-${name}-outline-hover`]: alpha(theme$1.colors[color][Math.max(primaryShade - 4, 0)], .05)
	};
	if (!withColorValues) return dynamicVariables;
	return {
		[`--mantine-color-${name}-0`]: theme$1.colors[color][0],
		[`--mantine-color-${name}-1`]: theme$1.colors[color][1],
		[`--mantine-color-${name}-2`]: theme$1.colors[color][2],
		[`--mantine-color-${name}-3`]: theme$1.colors[color][3],
		[`--mantine-color-${name}-4`]: theme$1.colors[color][4],
		[`--mantine-color-${name}-5`]: theme$1.colors[color][5],
		[`--mantine-color-${name}-6`]: theme$1.colors[color][6],
		[`--mantine-color-${name}-7`]: theme$1.colors[color][7],
		[`--mantine-color-${name}-8`]: theme$1.colors[color][8],
		[`--mantine-color-${name}-9`]: theme$1.colors[color][9],
		...dynamicVariables
	};
}
function isVirtualColor(value) {
	return !!value && typeof value === "object" && "mantine-virtual-color" in value;
}
function assignSizeVariables(variables, sizes, name) {
	keys(sizes).forEach((size$3) => Object.assign(variables, { [`--mantine-${name}-${size$3}`]: sizes[size$3] }));
}
var defaultCssVariablesResolver = (theme$1) => {
	const lightPrimaryShade = getPrimaryShade(theme$1, "light");
	const defaultRadius = theme$1.defaultRadius in theme$1.radius ? theme$1.radius[theme$1.defaultRadius] : rem(theme$1.defaultRadius);
	const result = {
		variables: {
			"--mantine-z-index-app": "100",
			"--mantine-z-index-modal": "200",
			"--mantine-z-index-popover": "300",
			"--mantine-z-index-overlay": "400",
			"--mantine-z-index-max": "9999",
			"--mantine-scale": theme$1.scale.toString(),
			"--mantine-cursor-type": theme$1.cursorType,
			"--mantine-webkit-font-smoothing": theme$1.fontSmoothing ? "antialiased" : "unset",
			"--mantine-moz-font-smoothing": theme$1.fontSmoothing ? "grayscale" : "unset",
			"--mantine-color-white": theme$1.white,
			"--mantine-color-black": theme$1.black,
			"--mantine-line-height": theme$1.lineHeights.md,
			"--mantine-font-family": theme$1.fontFamily,
			"--mantine-font-family-monospace": theme$1.fontFamilyMonospace,
			"--mantine-font-family-headings": theme$1.headings.fontFamily,
			"--mantine-heading-font-weight": theme$1.headings.fontWeight,
			"--mantine-heading-text-wrap": theme$1.headings.textWrap,
			"--mantine-radius-default": defaultRadius,
			"--mantine-primary-color-filled": `var(--mantine-color-${theme$1.primaryColor}-filled)`,
			"--mantine-primary-color-filled-hover": `var(--mantine-color-${theme$1.primaryColor}-filled-hover)`,
			"--mantine-primary-color-light": `var(--mantine-color-${theme$1.primaryColor}-light)`,
			"--mantine-primary-color-light-hover": `var(--mantine-color-${theme$1.primaryColor}-light-hover)`,
			"--mantine-primary-color-light-color": `var(--mantine-color-${theme$1.primaryColor}-light-color)`
		},
		light: {
			"--mantine-color-scheme": "light",
			"--mantine-primary-color-contrast": getPrimaryContrastColor(theme$1, "light"),
			"--mantine-color-bright": "var(--mantine-color-black)",
			"--mantine-color-text": theme$1.black,
			"--mantine-color-body": theme$1.white,
			"--mantine-color-error": "var(--mantine-color-red-6)",
			"--mantine-color-placeholder": "var(--mantine-color-gray-5)",
			"--mantine-color-anchor": `var(--mantine-color-${theme$1.primaryColor}-${lightPrimaryShade})`,
			"--mantine-color-default": "var(--mantine-color-white)",
			"--mantine-color-default-hover": "var(--mantine-color-gray-0)",
			"--mantine-color-default-color": "var(--mantine-color-black)",
			"--mantine-color-default-border": "var(--mantine-color-gray-4)",
			"--mantine-color-dimmed": "var(--mantine-color-gray-6)",
			"--mantine-color-disabled": "var(--mantine-color-gray-2)",
			"--mantine-color-disabled-color": "var(--mantine-color-gray-5)",
			"--mantine-color-disabled-border": "var(--mantine-color-gray-3)"
		},
		dark: {
			"--mantine-color-scheme": "dark",
			"--mantine-primary-color-contrast": getPrimaryContrastColor(theme$1, "dark"),
			"--mantine-color-bright": "var(--mantine-color-white)",
			"--mantine-color-text": "var(--mantine-color-dark-0)",
			"--mantine-color-body": "var(--mantine-color-dark-7)",
			"--mantine-color-error": "var(--mantine-color-red-8)",
			"--mantine-color-placeholder": "var(--mantine-color-dark-3)",
			"--mantine-color-anchor": `var(--mantine-color-${theme$1.primaryColor}-4)`,
			"--mantine-color-default": "var(--mantine-color-dark-6)",
			"--mantine-color-default-hover": "var(--mantine-color-dark-5)",
			"--mantine-color-default-color": "var(--mantine-color-white)",
			"--mantine-color-default-border": "var(--mantine-color-dark-4)",
			"--mantine-color-dimmed": "var(--mantine-color-dark-2)",
			"--mantine-color-disabled": "var(--mantine-color-dark-6)",
			"--mantine-color-disabled-color": "var(--mantine-color-dark-3)",
			"--mantine-color-disabled-border": "var(--mantine-color-dark-4)"
		}
	};
	assignSizeVariables(result.variables, theme$1.breakpoints, "breakpoint");
	assignSizeVariables(result.variables, theme$1.spacing, "spacing");
	assignSizeVariables(result.variables, theme$1.fontSizes, "font-size");
	assignSizeVariables(result.variables, theme$1.lineHeights, "line-height");
	assignSizeVariables(result.variables, theme$1.shadows, "shadow");
	assignSizeVariables(result.variables, theme$1.radius, "radius");
	theme$1.colors[theme$1.primaryColor].forEach((_, index$3) => {
		result.variables[`--mantine-primary-color-${index$3}`] = `var(--mantine-color-${theme$1.primaryColor}-${index$3})`;
	});
	keys(theme$1.colors).forEach((color) => {
		const value = theme$1.colors[color];
		if (isVirtualColor(value)) {
			Object.assign(result.light, getCSSColorVariables({
				theme: theme$1,
				name: value.name,
				color: value.light,
				colorScheme: "light",
				withColorValues: true
			}));
			Object.assign(result.dark, getCSSColorVariables({
				theme: theme$1,
				name: value.name,
				color: value.dark,
				colorScheme: "dark",
				withColorValues: true
			}));
			return;
		}
		value.forEach((shade, index$3) => {
			result.variables[`--mantine-color-${color}-${index$3}`] = shade;
		});
		Object.assign(result.light, getCSSColorVariables({
			theme: theme$1,
			color,
			colorScheme: "light",
			withColorValues: false
		}));
		Object.assign(result.dark, getCSSColorVariables({
			theme: theme$1,
			color,
			colorScheme: "dark",
			withColorValues: false
		}));
	});
	const headings$2 = theme$1.headings.sizes;
	keys(headings$2).forEach((heading) => {
		result.variables[`--mantine-${heading}-font-size`] = headings$2[heading].fontSize;
		result.variables[`--mantine-${heading}-line-height`] = headings$2[heading].lineHeight;
		result.variables[`--mantine-${heading}-font-weight`] = headings$2[heading].fontWeight || theme$1.headings.fontWeight;
	});
	return result;
};
function getMergedVariables({ theme: theme$1, generator }) {
	const defaultResolver = defaultCssVariablesResolver(theme$1);
	const providerGenerator = generator?.(theme$1);
	return providerGenerator ? deepMerge(defaultResolver, providerGenerator) : defaultResolver;
}
var defaultCssVariables = defaultCssVariablesResolver(DEFAULT_THEME);
function removeDefaultVariables(input) {
	const cleaned = {
		variables: {},
		light: {},
		dark: {}
	};
	keys(input.variables).forEach((key) => {
		if (defaultCssVariables.variables[key] !== input.variables[key]) cleaned.variables[key] = input.variables[key];
	});
	keys(input.light).forEach((key) => {
		if (defaultCssVariables.light[key] !== input.light[key]) cleaned.light[key] = input.light[key];
	});
	keys(input.dark).forEach((key) => {
		if (defaultCssVariables.dark[key] !== input.dark[key]) cleaned.dark[key] = input.dark[key];
	});
	return cleaned;
}
function getColorSchemeCssVariables(selectorOverride) {
	return convertCssVariables({
		variables: {},
		dark: { "--mantine-color-scheme": "dark" },
		light: { "--mantine-color-scheme": "light" }
	}, selectorOverride);
}
function MantineCssVariables({ cssVariablesSelector, deduplicateCssVariables }) {
	const theme$1 = useMantineTheme();
	const nonce = useMantineStyleNonce();
	const mergedVariables = getMergedVariables({
		theme: theme$1,
		generator: useMantineCssVariablesResolver()
	});
	const shouldCleanVariables = (cssVariablesSelector === void 0 || cssVariablesSelector === ":root" || cssVariablesSelector === ":host") && deduplicateCssVariables;
	const css = convertCssVariables(shouldCleanVariables ? removeDefaultVariables(mergedVariables) : mergedVariables, cssVariablesSelector);
	if (css) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("style", {
		"data-mantine-styles": true,
		nonce: nonce?.(),
		dangerouslySetInnerHTML: { __html: `${css}${shouldCleanVariables ? "" : getColorSchemeCssVariables(cssVariablesSelector)}` }
	});
	return null;
}
MantineCssVariables.displayName = "@mantine/CssVariables";
function setColorSchemeAttribute(colorScheme, getRootElement$1) {
	const hasDarkColorScheme = typeof window !== "undefined" && "matchMedia" in window && window.matchMedia("(prefers-color-scheme: dark)")?.matches;
	const computedColorScheme = colorScheme !== "auto" ? colorScheme : hasDarkColorScheme ? "dark" : "light";
	getRootElement$1()?.setAttribute("data-mantine-color-scheme", computedColorScheme);
}
function useProviderColorScheme({ manager, defaultColorScheme, getRootElement: getRootElement$1, forceColorScheme }) {
	const media = (0, import_react.useRef)(null);
	const [value, setValue] = (0, import_react.useState)(() => manager.get(defaultColorScheme));
	const colorSchemeValue = forceColorScheme || value;
	const setColorScheme = (0, import_react.useCallback)((colorScheme) => {
		if (!forceColorScheme) {
			setColorSchemeAttribute(colorScheme, getRootElement$1);
			setValue(colorScheme);
			manager.set(colorScheme);
		}
	}, [
		manager.set,
		colorSchemeValue,
		forceColorScheme
	]);
	const clearColorScheme = (0, import_react.useCallback)(() => {
		setValue(defaultColorScheme);
		setColorSchemeAttribute(defaultColorScheme, getRootElement$1);
		manager.clear();
	}, [manager.clear, defaultColorScheme]);
	(0, import_react.useEffect)(() => {
		manager.subscribe(setColorScheme);
		return manager.unsubscribe;
	}, [manager.subscribe, manager.unsubscribe]);
	useIsomorphicEffect(() => {
		setColorSchemeAttribute(manager.get(defaultColorScheme), getRootElement$1);
	}, []);
	(0, import_react.useEffect)(() => {
		if (forceColorScheme) {
			setColorSchemeAttribute(forceColorScheme, getRootElement$1);
			return () => {};
		}
		if (forceColorScheme === void 0) setColorSchemeAttribute(value, getRootElement$1);
		if (typeof window !== "undefined" && "matchMedia" in window) media.current = window.matchMedia("(prefers-color-scheme: dark)");
		const listener = (event) => {
			if (value === "auto") setColorSchemeAttribute(event.matches ? "dark" : "light", getRootElement$1);
		};
		media.current?.addEventListener("change", listener);
		return () => media.current?.removeEventListener("change", listener);
	}, [value, forceColorScheme]);
	return {
		colorScheme: colorSchemeValue,
		setColorScheme,
		clearColorScheme
	};
}
function useRespectReduceMotion({ respectReducedMotion, getRootElement: getRootElement$1 }) {
	useIsomorphicEffect(() => {
		if (respectReducedMotion) getRootElement$1()?.setAttribute("data-respect-reduced-motion", "true");
	}, [respectReducedMotion]);
}
function MantineProvider({ theme: theme$1, children, getStyleNonce, withStaticClasses = true, withGlobalClasses = true, deduplicateCssVariables = true, withCssVariables = true, cssVariablesSelector, classNamesPrefix = "mantine", colorSchemeManager = localStorageColorSchemeManager(), defaultColorScheme = "light", getRootElement: getRootElement$1 = () => document.documentElement, cssVariablesResolver, forceColorScheme, stylesTransform, env }) {
	const { colorScheme, setColorScheme, clearColorScheme } = useProviderColorScheme({
		defaultColorScheme,
		forceColorScheme,
		manager: colorSchemeManager,
		getRootElement: getRootElement$1
	});
	useRespectReduceMotion({
		respectReducedMotion: theme$1?.respectReducedMotion || false,
		getRootElement: getRootElement$1
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MantineContext.Provider, {
		value: {
			colorScheme,
			setColorScheme,
			clearColorScheme,
			getRootElement: getRootElement$1,
			classNamesPrefix,
			getStyleNonce,
			cssVariablesResolver,
			cssVariablesSelector: cssVariablesSelector ?? ":root",
			withStaticClasses,
			stylesTransform,
			env
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(MantineThemeProvider, {
			theme: theme$1,
			children: [
				withCssVariables && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MantineCssVariables, {
					cssVariablesSelector,
					deduplicateCssVariables
				}),
				withGlobalClasses && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MantineClasses, {}),
				children
			]
		})
	});
}
MantineProvider.displayName = "@mantine/core/MantineProvider";
function HeadlessMantineProvider({ children, theme: theme$1, env }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MantineContext.Provider, {
		value: {
			colorScheme: "auto",
			setColorScheme: () => {},
			clearColorScheme: () => {},
			getRootElement: () => document.documentElement,
			classNamesPrefix: "mantine",
			cssVariablesSelector: ":root",
			withStaticClasses: false,
			headless: true,
			env
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MantineThemeProvider, {
			theme: theme$1,
			children
		})
	});
}
HeadlessMantineProvider.displayName = "@mantine/core/HeadlessMantineProvider";
function useResolvedStylesApi({ classNames, styles, props, stylesCtx }) {
	const theme$1 = useMantineTheme();
	return {
		resolvedClassNames: resolveClassNames({
			theme: theme$1,
			classNames,
			props,
			stylesCtx: stylesCtx || void 0
		}),
		resolvedStyles: resolveStyles({
			theme: theme$1,
			styles,
			props,
			stylesCtx: stylesCtx || void 0
		})
	};
}
var FOCUS_CLASS_NAMES = {
	always: "mantine-focus-always",
	auto: "mantine-focus-auto",
	never: "mantine-focus-never"
};
function getGlobalClassNames({ theme: theme$1, options: options$1, unstyled }) {
	return clsx_default(options$1?.focusable && !unstyled && (theme$1.focusClassName || FOCUS_CLASS_NAMES[theme$1.focusRing]), options$1?.active && !unstyled && theme$1.activeClassName);
}
function getOptionsClassNames({ selector, stylesCtx, options: options$1, props, theme: theme$1 }) {
	return resolveClassNames({
		theme: theme$1,
		classNames: options$1?.classNames,
		props: options$1?.props || props,
		stylesCtx
	})[selector];
}
function getResolvedClassNames({ selector, stylesCtx, theme: theme$1, classNames, props }) {
	return resolveClassNames({
		theme: theme$1,
		classNames,
		props,
		stylesCtx
	})[selector];
}
function getRootClassName({ rootSelector, selector, className }) {
	return rootSelector === selector ? className : void 0;
}
function getSelectorClassName({ selector, classes: classes$14, unstyled }) {
	return unstyled ? void 0 : classes$14[selector];
}
function getStaticClassNames({ themeName, classNamesPrefix, selector, withStaticClass }) {
	if (withStaticClass === false) return [];
	return themeName.map((n) => `${classNamesPrefix}-${n}-${selector}`);
}
function getThemeClassNames({ themeName, theme: theme$1, selector, props, stylesCtx }) {
	return themeName.map((n) => resolveClassNames({
		theme: theme$1,
		classNames: theme$1.components[n]?.classNames,
		props,
		stylesCtx
	})?.[selector]);
}
function getVariantClassName({ options: options$1, classes: classes$14, selector, unstyled }) {
	return options$1?.variant && !unstyled ? classes$14[`${selector}--${options$1.variant}`] : void 0;
}
function getClassName({ theme: theme$1, options: options$1, themeName, selector, classNamesPrefix, classNames, classes: classes$14, unstyled, className, rootSelector, props, stylesCtx, withStaticClasses, headless, transformedStyles }) {
	return clsx_default(getGlobalClassNames({
		theme: theme$1,
		options: options$1,
		unstyled: unstyled || headless
	}), getThemeClassNames({
		theme: theme$1,
		themeName,
		selector,
		props,
		stylesCtx
	}), getVariantClassName({
		options: options$1,
		classes: classes$14,
		selector,
		unstyled
	}), getResolvedClassNames({
		selector,
		stylesCtx,
		theme: theme$1,
		classNames,
		props
	}), getResolvedClassNames({
		selector,
		stylesCtx,
		theme: theme$1,
		classNames: transformedStyles,
		props
	}), getOptionsClassNames({
		selector,
		stylesCtx,
		options: options$1,
		props,
		theme: theme$1
	}), getRootClassName({
		rootSelector,
		selector,
		className
	}), getSelectorClassName({
		selector,
		classes: classes$14,
		unstyled: unstyled || headless
	}), withStaticClasses && !headless && getStaticClassNames({
		themeName,
		classNamesPrefix,
		selector,
		withStaticClass: options$1?.withStaticClass
	}), options$1?.className);
}
function getThemeStyles({ theme: theme$1, themeName, props, stylesCtx, selector }) {
	return themeName.map((n) => resolveStyles({
		theme: theme$1,
		styles: theme$1.components[n]?.styles,
		props,
		stylesCtx
	})[selector]).reduce((acc, val) => ({
		...acc,
		...val
	}), {});
}
function resolveStyle({ style: style$1, theme: theme$1 }) {
	if (Array.isArray(style$1)) return [...style$1].reduce((acc, item) => ({
		...acc,
		...resolveStyle({
			style: item,
			theme: theme$1
		})
	}), {});
	if (typeof style$1 === "function") return style$1(theme$1);
	if (style$1 == null) return {};
	return style$1;
}
function mergeVars(vars) {
	return vars.reduce((acc, current) => {
		if (current) Object.keys(current).forEach((key) => {
			acc[key] = {
				...acc[key],
				...filterProps(current[key])
			};
		});
		return acc;
	}, {});
}
function resolveVars({ vars, varsResolver: varsResolver$17, theme: theme$1, props, stylesCtx, selector, themeName, headless }) {
	return mergeVars([
		headless ? {} : varsResolver$17?.(theme$1, props, stylesCtx),
		...themeName.map((name) => theme$1.components?.[name]?.vars?.(theme$1, props, stylesCtx)),
		vars?.(theme$1, props, stylesCtx)
	])?.[selector];
}
function getStyle({ theme: theme$1, themeName, selector, options: options$1, props, stylesCtx, rootSelector, styles, style: style$1, vars, varsResolver: varsResolver$17, headless, withStylesTransform }) {
	return {
		...!withStylesTransform && getThemeStyles({
			theme: theme$1,
			themeName,
			props,
			stylesCtx,
			selector
		}),
		...!withStylesTransform && resolveStyles({
			theme: theme$1,
			styles,
			props,
			stylesCtx
		})[selector],
		...!withStylesTransform && resolveStyles({
			theme: theme$1,
			styles: options$1?.styles,
			props: options$1?.props || props,
			stylesCtx
		})[selector],
		...resolveVars({
			theme: theme$1,
			props,
			stylesCtx,
			vars,
			varsResolver: varsResolver$17,
			selector,
			themeName,
			headless
		}),
		...rootSelector === selector ? resolveStyle({
			style: style$1,
			theme: theme$1
		}) : null,
		...resolveStyle({
			style: options$1?.style,
			theme: theme$1
		})
	};
}
function useStylesTransform({ props, stylesCtx, themeName }) {
	const theme$1 = useMantineTheme();
	const stylesTransform = useMantineStylesTransform()?.();
	const getTransformedStyles = (styles) => {
		if (!stylesTransform) return [];
		return [...styles.map((style$1) => stylesTransform(style$1, {
			props,
			theme: theme$1,
			ctx: stylesCtx
		})), ...themeName.map((n) => stylesTransform(theme$1.components[n]?.styles, {
			props,
			theme: theme$1,
			ctx: stylesCtx
		}))].filter(Boolean);
	};
	return {
		getTransformedStyles,
		withStylesTransform: !!stylesTransform
	};
}
function useStyles({ name, classes: classes$14, props, stylesCtx, className, style: style$1, rootSelector = "root", unstyled, classNames, styles, vars, varsResolver: varsResolver$17, attributes }) {
	const theme$1 = useMantineTheme();
	const classNamesPrefix = useMantineClassNamesPrefix();
	const withStaticClasses = useMantineWithStaticClasses();
	const headless = useMantineIsHeadless();
	const themeName = (Array.isArray(name) ? name : [name]).filter((n) => n);
	const { withStylesTransform, getTransformedStyles } = useStylesTransform({
		props,
		stylesCtx,
		themeName
	});
	return (selector, options$1) => ({
		className: getClassName({
			theme: theme$1,
			options: options$1,
			themeName,
			selector,
			classNamesPrefix,
			classNames,
			classes: classes$14,
			unstyled,
			className,
			rootSelector,
			props,
			stylesCtx,
			withStaticClasses,
			headless,
			transformedStyles: getTransformedStyles([options$1?.styles, styles])
		}),
		style: getStyle({
			theme: theme$1,
			themeName,
			selector,
			options: options$1,
			props,
			stylesCtx,
			rootSelector,
			styles,
			style: style$1,
			vars,
			varsResolver: varsResolver$17,
			headless,
			withStylesTransform
		}),
		...attributes?.[selector]
	});
}
function useProps(component, defaultProps$23, props) {
	const theme$1 = useMantineTheme();
	const contextPropsPayload = theme$1.components[component]?.defaultProps;
	const contextProps = typeof contextPropsPayload === "function" ? contextPropsPayload(theme$1) : contextPropsPayload;
	return {
		...defaultProps$23,
		...contextProps,
		...filterProps(props)
	};
}
function createTheme(theme$1) {
	return theme$1;
}
function cssObjectToString(css) {
	return keys(css).reduce((acc, rule) => css[rule] !== void 0 ? `${acc}${camelToKebabCase(rule)}:${css[rule]};` : acc, "").trim();
}
function stylesToString({ selector, styles, media, container }) {
	const baseStyles = styles ? cssObjectToString(styles) : "";
	const mediaQueryStyles = !Array.isArray(media) ? [] : media.map((item) => `@media${item.query}{${selector}{${cssObjectToString(item.styles)}}}`);
	const containerStyles = !Array.isArray(container) ? [] : container.map((item) => `@container ${item.query}{${selector}{${cssObjectToString(item.styles)}}}`);
	return `${baseStyles ? `${selector}{${baseStyles}}` : ""}${mediaQueryStyles.join("")}${containerStyles.join("")}`.trim();
}
function InlineStyles(props) {
	const nonce = useMantineStyleNonce();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("style", {
		"data-mantine-styles": "inline",
		nonce: nonce?.(),
		dangerouslySetInnerHTML: { __html: stylesToString(props) }
	});
}
function extractStyleProps(others) {
	const { m, mx, my, mt, mb, ml, mr, me, ms, p, px: px$1, py, pt, pb, pl, pr, pe, ps, bd, bdrs, bg, c, opacity, ff, fz, fw, lts, ta, lh, fs, tt, td, w, miw, maw, h, mih, mah, bgsz, bgp, bgr, bga, pos, top, left, bottom, right, inset, display, flex, hiddenFrom, visibleFrom, lightHidden, darkHidden, sx, ...rest } = others;
	return {
		styleProps: filterProps({
			m,
			mx,
			my,
			mt,
			mb,
			ml,
			mr,
			me,
			ms,
			p,
			px: px$1,
			py,
			pt,
			pb,
			pl,
			pr,
			pe,
			ps,
			bd,
			bg,
			c,
			opacity,
			ff,
			fz,
			fw,
			lts,
			ta,
			lh,
			fs,
			tt,
			td,
			w,
			miw,
			maw,
			h,
			mih,
			mah,
			bgsz,
			bgp,
			bgr,
			bga,
			pos,
			top,
			left,
			bottom,
			right,
			inset,
			display,
			flex,
			bdrs,
			hiddenFrom,
			visibleFrom,
			lightHidden,
			darkHidden,
			sx
		}),
		rest
	};
}
var STYlE_PROPS_DATA = {
	m: {
		type: "spacing",
		property: "margin"
	},
	mt: {
		type: "spacing",
		property: "marginTop"
	},
	mb: {
		type: "spacing",
		property: "marginBottom"
	},
	ml: {
		type: "spacing",
		property: "marginLeft"
	},
	mr: {
		type: "spacing",
		property: "marginRight"
	},
	ms: {
		type: "spacing",
		property: "marginInlineStart"
	},
	me: {
		type: "spacing",
		property: "marginInlineEnd"
	},
	mx: {
		type: "spacing",
		property: "marginInline"
	},
	my: {
		type: "spacing",
		property: "marginBlock"
	},
	p: {
		type: "spacing",
		property: "padding"
	},
	pt: {
		type: "spacing",
		property: "paddingTop"
	},
	pb: {
		type: "spacing",
		property: "paddingBottom"
	},
	pl: {
		type: "spacing",
		property: "paddingLeft"
	},
	pr: {
		type: "spacing",
		property: "paddingRight"
	},
	ps: {
		type: "spacing",
		property: "paddingInlineStart"
	},
	pe: {
		type: "spacing",
		property: "paddingInlineEnd"
	},
	px: {
		type: "spacing",
		property: "paddingInline"
	},
	py: {
		type: "spacing",
		property: "paddingBlock"
	},
	bd: {
		type: "border",
		property: "border"
	},
	bdrs: {
		type: "radius",
		property: "borderRadius"
	},
	bg: {
		type: "color",
		property: "background"
	},
	c: {
		type: "textColor",
		property: "color"
	},
	opacity: {
		type: "identity",
		property: "opacity"
	},
	ff: {
		type: "fontFamily",
		property: "fontFamily"
	},
	fz: {
		type: "fontSize",
		property: "fontSize"
	},
	fw: {
		type: "identity",
		property: "fontWeight"
	},
	lts: {
		type: "size",
		property: "letterSpacing"
	},
	ta: {
		type: "identity",
		property: "textAlign"
	},
	lh: {
		type: "lineHeight",
		property: "lineHeight"
	},
	fs: {
		type: "identity",
		property: "fontStyle"
	},
	tt: {
		type: "identity",
		property: "textTransform"
	},
	td: {
		type: "identity",
		property: "textDecoration"
	},
	w: {
		type: "spacing",
		property: "width"
	},
	miw: {
		type: "spacing",
		property: "minWidth"
	},
	maw: {
		type: "spacing",
		property: "maxWidth"
	},
	h: {
		type: "spacing",
		property: "height"
	},
	mih: {
		type: "spacing",
		property: "minHeight"
	},
	mah: {
		type: "spacing",
		property: "maxHeight"
	},
	bgsz: {
		type: "size",
		property: "backgroundSize"
	},
	bgp: {
		type: "identity",
		property: "backgroundPosition"
	},
	bgr: {
		type: "identity",
		property: "backgroundRepeat"
	},
	bga: {
		type: "identity",
		property: "backgroundAttachment"
	},
	pos: {
		type: "identity",
		property: "position"
	},
	top: {
		type: "size",
		property: "top"
	},
	left: {
		type: "size",
		property: "left"
	},
	bottom: {
		type: "size",
		property: "bottom"
	},
	right: {
		type: "size",
		property: "right"
	},
	inset: {
		type: "size",
		property: "inset"
	},
	display: {
		type: "identity",
		property: "display"
	},
	flex: {
		type: "identity",
		property: "flex"
	}
};
function colorResolver(color, theme$1) {
	const parsedColor = parseThemeColor({
		color,
		theme: theme$1
	});
	if (parsedColor.color === "dimmed") return "var(--mantine-color-dimmed)";
	if (parsedColor.color === "bright") return "var(--mantine-color-bright)";
	return parsedColor.variable ? `var(${parsedColor.variable})` : parsedColor.color;
}
function textColorResolver(color, theme$1) {
	const parsedColor = parseThemeColor({
		color,
		theme: theme$1
	});
	if (parsedColor.isThemeColor && parsedColor.shade === void 0) return `var(--mantine-color-${parsedColor.color}-text)`;
	return colorResolver(color, theme$1);
}
function borderResolver(value, theme$1) {
	if (typeof value === "number") return rem(value);
	if (typeof value === "string") {
		const [size$3, style$1, ...colorTuple] = value.split(" ").filter((val) => val.trim() !== "");
		let result = `${rem(size$3)}`;
		style$1 && (result += ` ${style$1}`);
		colorTuple.length > 0 && (result += ` ${colorResolver(colorTuple.join(" "), theme$1)}`);
		return result.trim();
	}
	return value;
}
var values = {
	text: "var(--mantine-font-family)",
	mono: "var(--mantine-font-family-monospace)",
	monospace: "var(--mantine-font-family-monospace)",
	heading: "var(--mantine-font-family-headings)",
	headings: "var(--mantine-font-family-headings)"
};
function fontFamilyResolver(fontFamily) {
	if (typeof fontFamily === "string" && fontFamily in values) return values[fontFamily];
	return fontFamily;
}
var headings$1 = [
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6"
];
function fontSizeResolver(value, theme$1) {
	if (typeof value === "string" && value in theme$1.fontSizes) return `var(--mantine-font-size-${value})`;
	if (typeof value === "string" && headings$1.includes(value)) return `var(--mantine-${value}-font-size)`;
	if (typeof value === "number") return rem(value);
	if (typeof value === "string") return rem(value);
	return value;
}
function identityResolver(value) {
	return value;
}
var headings = [
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6"
];
function lineHeightResolver(value, theme$1) {
	if (typeof value === "string" && value in theme$1.lineHeights) return `var(--mantine-line-height-${value})`;
	if (typeof value === "string" && headings.includes(value)) return `var(--mantine-${value}-line-height)`;
	return value;
}
function radiusResolver(value, theme$1) {
	if (typeof value === "string" && value in theme$1.radius) return `var(--mantine-radius-${value})`;
	if (typeof value === "number") return rem(value);
	if (typeof value === "string") return rem(value);
	return value;
}
function sizeResolver(value) {
	if (typeof value === "number") return rem(value);
	return value;
}
function spacingResolver(value, theme$1) {
	if (typeof value === "number") return rem(value);
	if (typeof value === "string") {
		const mod = value.replace("-", "");
		if (!(mod in theme$1.spacing)) return rem(value);
		const variable = `--mantine-spacing-${mod}`;
		return value.startsWith("-") ? `calc(var(${variable}) * -1)` : `var(${variable})`;
	}
	return value;
}
var resolvers = {
	color: colorResolver,
	textColor: textColorResolver,
	fontSize: fontSizeResolver,
	spacing: spacingResolver,
	radius: radiusResolver,
	identity: identityResolver,
	size: sizeResolver,
	lineHeight: lineHeightResolver,
	fontFamily: fontFamilyResolver,
	border: borderResolver
};
function replaceMediaQuery(query) {
	return query.replace("(min-width: ", "").replace("em)", "");
}
function sortMediaQueries({ media, ...props }) {
	const sortedMedia = Object.keys(media).sort((a, b) => Number(replaceMediaQuery(a)) - Number(replaceMediaQuery(b))).map((query) => ({
		query,
		styles: media[query]
	}));
	return {
		...props,
		media: sortedMedia
	};
}
function hasResponsiveStyles(styleProp) {
	if (typeof styleProp !== "object" || styleProp === null) return false;
	const breakpoints = Object.keys(styleProp);
	if (breakpoints.length === 1 && breakpoints[0] === "base") return false;
	return true;
}
function getBaseValue(value) {
	if (typeof value === "object" && value !== null) {
		if ("base" in value) return value.base;
		return;
	}
	return value;
}
function getBreakpointKeys(value) {
	if (typeof value === "object" && value !== null) return keys(value).filter((key) => key !== "base");
	return [];
}
function getBreakpointValue(value, breakpoint) {
	if (typeof value === "object" && value !== null && breakpoint in value) return value[breakpoint];
	return value;
}
function parseStyleProps({ styleProps, data, theme: theme$1 }) {
	return sortMediaQueries(keys(styleProps).reduce((acc, styleProp) => {
		if (styleProp === "hiddenFrom" || styleProp === "visibleFrom" || styleProp === "sx") return acc;
		const propertyData = data[styleProp];
		const properties = Array.isArray(propertyData.property) ? propertyData.property : [propertyData.property];
		const baseValue = getBaseValue(styleProps[styleProp]);
		if (!hasResponsiveStyles(styleProps[styleProp])) {
			properties.forEach((property) => {
				acc.inlineStyles[property] = resolvers[propertyData.type](baseValue, theme$1);
			});
			return acc;
		}
		acc.hasResponsiveStyles = true;
		const breakpoints = getBreakpointKeys(styleProps[styleProp]);
		properties.forEach((property) => {
			if (baseValue != null) acc.styles[property] = resolvers[propertyData.type](baseValue, theme$1);
			breakpoints.forEach((breakpoint) => {
				const bp = `(min-width: ${theme$1.breakpoints[breakpoint]})`;
				acc.media[bp] = {
					...acc.media[bp],
					[property]: resolvers[propertyData.type](getBreakpointValue(styleProps[styleProp], breakpoint), theme$1)
				};
			});
		});
		return acc;
	}, {
		hasResponsiveStyles: false,
		styles: {},
		inlineStyles: {},
		media: {}
	}));
}
function useRandomClassName() {
	return `__m__-${(0, import_react.useId)().replace(/[:]/g, "")}`;
}
function createPolymorphicComponent(component) {
	return component;
}
function transformModKey(key) {
	return key.startsWith("data-") ? key : `data-${key}`;
}
function getMod(props) {
	return Object.keys(props).reduce((acc, key) => {
		const value = props[key];
		if (value === void 0 || value === "" || value === false || value === null) return acc;
		acc[transformModKey(key)] = props[key];
		return acc;
	}, {});
}
function getBoxMod(mod) {
	if (!mod) return null;
	if (typeof mod === "string") return { [transformModKey(mod)]: true };
	if (Array.isArray(mod)) return [...mod].reduce((acc, value) => ({
		...acc,
		...getBoxMod(value)
	}), {});
	return getMod(mod);
}
function mergeStyles(styles, theme$1) {
	if (Array.isArray(styles)) return [...styles].reduce((acc, item) => ({
		...acc,
		...mergeStyles(item, theme$1)
	}), {});
	if (typeof styles === "function") return styles(theme$1);
	if (styles == null) return {};
	return styles;
}
function getBoxStyle({ theme: theme$1, style: style$1, vars, styleProps }) {
	const _style = mergeStyles(style$1, theme$1);
	const _vars = mergeStyles(vars, theme$1);
	return {
		..._style,
		..._vars,
		...styleProps
	};
}
var _Box = (0, import_react.forwardRef)(({ component, style: style$1, __vars, className, variant, mod, size: size$3, hiddenFrom, visibleFrom, lightHidden, darkHidden, renderRoot, __size, ...others }, ref) => {
	const theme$1 = useMantineTheme();
	const Element$1 = component || "div";
	const { styleProps, rest } = extractStyleProps(others);
	const transformedSx = useMantineSxTransform()?.()?.(styleProps.sx);
	const responsiveClassName = useRandomClassName();
	const parsedStyleProps = parseStyleProps({
		styleProps,
		theme: theme$1,
		data: STYlE_PROPS_DATA
	});
	const props = {
		ref,
		style: getBoxStyle({
			theme: theme$1,
			style: style$1,
			vars: __vars,
			styleProps: parsedStyleProps.inlineStyles
		}),
		className: clsx_default(className, transformedSx, {
			[responsiveClassName]: parsedStyleProps.hasResponsiveStyles,
			"mantine-light-hidden": lightHidden,
			"mantine-dark-hidden": darkHidden,
			[`mantine-hidden-from-${hiddenFrom}`]: hiddenFrom,
			[`mantine-visible-from-${visibleFrom}`]: visibleFrom
		}),
		"data-variant": variant,
		"data-size": isNumberLike(size$3) ? void 0 : size$3 || void 0,
		size: __size,
		...getBoxMod(mod),
		...rest
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [parsedStyleProps.hasResponsiveStyles && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InlineStyles, {
		selector: `.${responsiveClassName}`,
		styles: parsedStyleProps.styles,
		media: parsedStyleProps.media
	}), typeof renderRoot === "function" ? renderRoot(props) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Element$1, { ...props })] });
});
_Box.displayName = "@mantine/core/Box";
var Box = createPolymorphicComponent(_Box);
function identity(value) {
	return value;
}
function factory(ui) {
	const Component$1 = (0, import_react.forwardRef)(ui);
	Component$1.extend = identity;
	Component$1.withProps = (fixedProps) => {
		const Extended = (0, import_react.forwardRef)((props, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component$1, {
			...fixedProps,
			...props,
			ref
		}));
		Extended.extend = Component$1.extend;
		Extended.displayName = `WithProps(${Component$1.displayName})`;
		return Extended;
	};
	return Component$1;
}
function polymorphicFactory(ui) {
	const Component$1 = (0, import_react.forwardRef)(ui);
	Component$1.withProps = (fixedProps) => {
		const Extended = (0, import_react.forwardRef)((props, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component$1, {
			...fixedProps,
			...props,
			ref
		}));
		Extended.extend = Component$1.extend;
		Extended.displayName = `WithProps(${Component$1.displayName})`;
		return Extended;
	};
	Component$1.extend = identity;
	return Component$1;
}
var DirectionContext = (0, import_react.createContext)({
	dir: "ltr",
	toggleDirection: () => {},
	setDirection: () => {}
});
function useDirection() {
	return (0, import_react.useContext)(DirectionContext);
}
function hasWindow() {
	return typeof window !== "undefined";
}
function getNodeName(node) {
	if (isNode(node)) return (node.nodeName || "").toLowerCase();
	return "#document";
}
function getWindow(node) {
	var _node$ownerDocument;
	return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
	var _ref;
	return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
	if (!hasWindow()) return false;
	return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement$1(value) {
	if (!hasWindow()) return false;
	return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
	if (!hasWindow()) return false;
	return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
	if (!hasWindow() || typeof ShadowRoot === "undefined") return false;
	return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
	const { overflow, overflowX, overflowY, display } = getComputedStyle$1(element);
	return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set([
	"table",
	"td",
	"th"
]);
function isTableElement(element) {
	return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
	return topLayerSelectors.some((selector) => {
		try {
			return element.matches(selector);
		} catch (_e) {
			return false;
		}
	});
}
var transformProperties = [
	"transform",
	"translate",
	"scale",
	"rotate",
	"perspective"
];
var willChangeValues = [
	"transform",
	"translate",
	"scale",
	"rotate",
	"perspective",
	"filter"
];
var containValues = [
	"paint",
	"layout",
	"strict",
	"content"
];
function isContainingBlock(elementOrCss) {
	const webkit = isWebKit();
	const css = isElement$1(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
	return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
	let currentNode = getParentNode(element);
	while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
		if (isContainingBlock(currentNode)) return currentNode;
		else if (isTopLayer(currentNode)) return null;
		currentNode = getParentNode(currentNode);
	}
	return null;
}
function isWebKit() {
	if (typeof CSS === "undefined" || !CSS.supports) return false;
	return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set([
	"html",
	"body",
	"#document"
]);
function isLastTraversableNode(node) {
	return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle$1(element) {
	return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
	if (isElement$1(element)) return {
		scrollLeft: element.scrollLeft,
		scrollTop: element.scrollTop
	};
	return {
		scrollLeft: element.scrollX,
		scrollTop: element.scrollY
	};
}
function getParentNode(node) {
	if (getNodeName(node) === "html") return node;
	const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
	return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
	const parentNode = getParentNode(node);
	if (isLastTraversableNode(parentNode)) return node.ownerDocument ? node.ownerDocument.body : node.body;
	if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) return parentNode;
	return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
	var _node$ownerDocument2;
	if (list === void 0) list = [];
	if (traverseIframes === void 0) traverseIframes = true;
	const scrollableAncestor = getNearestOverflowAncestor(node);
	const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
	const win = getWindow(scrollableAncestor);
	if (isBody) {
		const frameElement = getFrameElement(win);
		return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
	}
	return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
	return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
var sides = [
	"top",
	"right",
	"bottom",
	"left"
];
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
	x: v,
	y: v
});
var oppositeSideMap = {
	left: "right",
	right: "left",
	bottom: "top",
	top: "bottom"
};
var oppositeAlignmentMap = {
	start: "end",
	end: "start"
};
function clamp$3(start, value, end) {
	return max(start, min(value, end));
}
function evaluate(value, param) {
	return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
	return placement.split("-")[0];
}
function getAlignment(placement) {
	return placement.split("-")[1];
}
function getOppositeAxis(axis) {
	return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
	return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
	return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
	return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
	if (rtl === void 0) rtl = false;
	const alignment = getAlignment(placement);
	const alignmentAxis = getAlignmentAxis(placement);
	const length = getAxisLength(alignmentAxis);
	let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
	if (rects.reference[length] > rects.floating[length]) mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
	return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
	const oppositePlacement = getOppositePlacement(placement);
	return [
		getOppositeAlignmentPlacement(placement),
		oppositePlacement,
		getOppositeAlignmentPlacement(oppositePlacement)
	];
}
function getOppositeAlignmentPlacement(placement) {
	return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
	switch (side) {
		case "top":
		case "bottom":
			if (rtl) return isStart ? rlPlacement : lrPlacement;
			return isStart ? lrPlacement : rlPlacement;
		case "left":
		case "right": return isStart ? tbPlacement : btPlacement;
		default: return [];
	}
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
	const alignment = getAlignment(placement);
	let list = getSideList(getSide(placement), direction === "start", rtl);
	if (alignment) {
		list = list.map((side) => side + "-" + alignment);
		if (flipAlignment) list = list.concat(list.map(getOppositeAlignmentPlacement));
	}
	return list;
}
function getOppositePlacement(placement) {
	return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
	return {
		top: 0,
		right: 0,
		bottom: 0,
		left: 0,
		...padding
	};
}
function getPaddingObject(padding) {
	return typeof padding !== "number" ? expandPaddingObject(padding) : {
		top: padding,
		right: padding,
		bottom: padding,
		left: padding
	};
}
function rectToClientRect(rect) {
	const { x, y, width, height } = rect;
	return {
		width,
		height,
		top: y,
		left: x,
		right: x + width,
		bottom: y + height,
		x,
		y
	};
}
var index = typeof document !== "undefined" ? import_react.useLayoutEffect : function noop$5() {};
var useSafeInsertionEffect = { ...import_react }.useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
	const ref = import_react.useRef(() => {});
	useSafeInsertionEffect(() => {
		ref.current = callback;
	});
	return import_react.useCallback(function() {
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		return ref.current == null ? void 0 : ref.current(...args);
	}, []);
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
	let { reference, floating } = _ref;
	const sideAxis = getSideAxis(placement);
	const alignmentAxis = getAlignmentAxis(placement);
	const alignLength = getAxisLength(alignmentAxis);
	const side = getSide(placement);
	const isVertical = sideAxis === "y";
	const commonX = reference.x + reference.width / 2 - floating.width / 2;
	const commonY = reference.y + reference.height / 2 - floating.height / 2;
	const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
	let coords;
	switch (side) {
		case "top":
			coords = {
				x: commonX,
				y: reference.y - floating.height
			};
			break;
		case "bottom":
			coords = {
				x: commonX,
				y: reference.y + reference.height
			};
			break;
		case "right":
			coords = {
				x: reference.x + reference.width,
				y: commonY
			};
			break;
		case "left":
			coords = {
				x: reference.x - floating.width,
				y: commonY
			};
			break;
		default: coords = {
			x: reference.x,
			y: reference.y
		};
	}
	switch (getAlignment(placement)) {
		case "start":
			coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
			break;
		case "end":
			coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
			break;
	}
	return coords;
}
var computePosition$1 = async (reference, floating, config) => {
	const { placement = "bottom", strategy = "absolute", middleware = [], platform: platform$1 } = config;
	const validMiddleware = middleware.filter(Boolean);
	const rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(floating));
	let rects = await platform$1.getElementRects({
		reference,
		floating,
		strategy
	});
	let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);
	let statefulPlacement = placement;
	let middlewareData = {};
	let resetCount = 0;
	for (let i = 0; i < validMiddleware.length; i++) {
		const { name, fn } = validMiddleware[i];
		const { x: nextX, y: nextY, data, reset } = await fn({
			x,
			y,
			initialPlacement: placement,
			placement: statefulPlacement,
			strategy,
			middlewareData,
			rects,
			platform: platform$1,
			elements: {
				reference,
				floating
			}
		});
		x = nextX != null ? nextX : x;
		y = nextY != null ? nextY : y;
		middlewareData = {
			...middlewareData,
			[name]: {
				...middlewareData[name],
				...data
			}
		};
		if (reset && resetCount <= 50) {
			resetCount++;
			if (typeof reset === "object") {
				if (reset.placement) statefulPlacement = reset.placement;
				if (reset.rects) rects = reset.rects === true ? await platform$1.getElementRects({
					reference,
					floating,
					strategy
				}) : reset.rects;
				({x, y} = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
			}
			i = -1;
		}
	}
	return {
		x,
		y,
		placement: statefulPlacement,
		strategy,
		middlewareData
	};
};
async function detectOverflow$1(state, options$1) {
	var _await$platform$isEle;
	if (options$1 === void 0) options$1 = {};
	const { x, y, platform: platform$1, rects, elements, strategy } = state;
	const { boundary = "clippingAncestors", rootBoundary = "viewport", elementContext = "floating", altBoundary = false, padding = 0 } = evaluate(options$1, state);
	const paddingObject = getPaddingObject(padding);
	const element = elements[altBoundary ? elementContext === "floating" ? "reference" : "floating" : elementContext];
	const clippingClientRect = rectToClientRect(await platform$1.getClippingRect({
		element: ((_await$platform$isEle = await (platform$1.isElement == null ? void 0 : platform$1.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform$1.getDocumentElement == null ? void 0 : platform$1.getDocumentElement(elements.floating)),
		boundary,
		rootBoundary,
		strategy
	}));
	const rect = elementContext === "floating" ? {
		x,
		y,
		width: rects.floating.width,
		height: rects.floating.height
	} : rects.reference;
	const offsetParent = await (platform$1.getOffsetParent == null ? void 0 : platform$1.getOffsetParent(elements.floating));
	const offsetScale = await (platform$1.isElement == null ? void 0 : platform$1.isElement(offsetParent)) ? await (platform$1.getScale == null ? void 0 : platform$1.getScale(offsetParent)) || {
		x: 1,
		y: 1
	} : {
		x: 1,
		y: 1
	};
	const elementClientRect = rectToClientRect(platform$1.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform$1.convertOffsetParentRelativeRectToViewportRelativeRect({
		elements,
		rect,
		offsetParent,
		strategy
	}) : rect);
	return {
		top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
		bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
		left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
		right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
	};
}
var arrow$2 = (options$1) => ({
	name: "arrow",
	options: options$1,
	async fn(state) {
		const { x, y, placement, rects, platform: platform$1, elements, middlewareData } = state;
		const { element, padding = 0 } = evaluate(options$1, state) || {};
		if (element == null) return {};
		const paddingObject = getPaddingObject(padding);
		const coords = {
			x,
			y
		};
		const axis = getAlignmentAxis(placement);
		const length = getAxisLength(axis);
		const arrowDimensions = await platform$1.getDimensions(element);
		const isYAxis = axis === "y";
		const minProp = isYAxis ? "top" : "left";
		const maxProp = isYAxis ? "bottom" : "right";
		const clientProp = isYAxis ? "clientHeight" : "clientWidth";
		const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
		const startDiff = coords[axis] - rects.reference[axis];
		const arrowOffsetParent = await (platform$1.getOffsetParent == null ? void 0 : platform$1.getOffsetParent(element));
		let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
		if (!clientSize || !await (platform$1.isElement == null ? void 0 : platform$1.isElement(arrowOffsetParent))) clientSize = elements.floating[clientProp] || rects.floating[length];
		const centerToReference = endDiff / 2 - startDiff / 2;
		const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
		const minPadding = min(paddingObject[minProp], largestPossiblePadding);
		const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
		const min$1 = minPadding;
		const max$1 = clientSize - arrowDimensions[length] - maxPadding;
		const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
		const offset$3 = clamp$3(min$1, center, max$1);
		const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset$3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
		const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max$1 : 0;
		return {
			[axis]: coords[axis] + alignmentOffset,
			data: {
				[axis]: offset$3,
				centerOffset: center - offset$3 - alignmentOffset,
				...shouldAddOffset && { alignmentOffset }
			},
			reset: shouldAddOffset
		};
	}
});
var flip$2 = function(options$1) {
	if (options$1 === void 0) options$1 = {};
	return {
		name: "flip",
		options: options$1,
		async fn(state) {
			var _middlewareData$arrow, _middlewareData$flip;
			const { placement, middlewareData, rects, initialPlacement, platform: platform$1, elements } = state;
			const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = "bestFit", fallbackAxisSideDirection = "none", flipAlignment = true, ...detectOverflowOptions } = evaluate(options$1, state);
			if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) return {};
			const side = getSide(placement);
			const initialSideAxis = getSideAxis(initialPlacement);
			const isBasePlacement = getSide(initialPlacement) === initialPlacement;
			const rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating));
			const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
			const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
			if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
			const placements$1 = [initialPlacement, ...fallbackPlacements];
			const overflow = await detectOverflow$1(state, detectOverflowOptions);
			const overflows = [];
			let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
			if (checkMainAxis) overflows.push(overflow[side]);
			if (checkCrossAxis) {
				const sides$1 = getAlignmentSides(placement, rects, rtl);
				overflows.push(overflow[sides$1[0]], overflow[sides$1[1]]);
			}
			overflowsData = [...overflowsData, {
				placement,
				overflows
			}];
			if (!overflows.every((side$1) => side$1 <= 0)) {
				var _middlewareData$flip2, _overflowsData$filter;
				const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
				const nextPlacement = placements$1[nextIndex];
				if (nextPlacement) {
					if (!(checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false) || overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) return {
						data: {
							index: nextIndex,
							overflows: overflowsData
						},
						reset: { placement: nextPlacement }
					};
				}
				let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
				if (!resetPlacement) switch (fallbackStrategy) {
					case "bestFit": {
						var _overflowsData$filter2;
						const placement$1 = (_overflowsData$filter2 = overflowsData.filter((d) => {
							if (hasFallbackAxisSideDirection) {
								const currentSideAxis = getSideAxis(d.placement);
								return currentSideAxis === initialSideAxis || currentSideAxis === "y";
							}
							return true;
						}).map((d) => [d.placement, d.overflows.filter((overflow$1) => overflow$1 > 0).reduce((acc, overflow$1) => acc + overflow$1, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
						if (placement$1) resetPlacement = placement$1;
						break;
					}
					case "initialPlacement":
						resetPlacement = initialPlacement;
						break;
				}
				if (placement !== resetPlacement) return { reset: { placement: resetPlacement } };
			}
			return {};
		}
	};
};
function getSideOffsets(overflow, rect) {
	return {
		top: overflow.top - rect.height,
		right: overflow.right - rect.width,
		bottom: overflow.bottom - rect.height,
		left: overflow.left - rect.width
	};
}
function isAnySideFullyClipped(overflow) {
	return sides.some((side) => overflow[side] >= 0);
}
var hide$2 = function(options$1) {
	if (options$1 === void 0) options$1 = {};
	return {
		name: "hide",
		options: options$1,
		async fn(state) {
			const { rects } = state;
			const { strategy = "referenceHidden", ...detectOverflowOptions } = evaluate(options$1, state);
			switch (strategy) {
				case "referenceHidden": {
					const offsets = getSideOffsets(await detectOverflow$1(state, {
						...detectOverflowOptions,
						elementContext: "reference"
					}), rects.reference);
					return { data: {
						referenceHiddenOffsets: offsets,
						referenceHidden: isAnySideFullyClipped(offsets)
					} };
				}
				case "escaped": {
					const offsets = getSideOffsets(await detectOverflow$1(state, {
						...detectOverflowOptions,
						altBoundary: true
					}), rects.floating);
					return { data: {
						escapedOffsets: offsets,
						escaped: isAnySideFullyClipped(offsets)
					} };
				}
				default: return {};
			}
		}
	};
};
function getBoundingRect(rects) {
	const minX = min(...rects.map((rect) => rect.left));
	const minY = min(...rects.map((rect) => rect.top));
	const maxX = max(...rects.map((rect) => rect.right));
	const maxY = max(...rects.map((rect) => rect.bottom));
	return {
		x: minX,
		y: minY,
		width: maxX - minX,
		height: maxY - minY
	};
}
function getRectsByLine(rects) {
	const sortedRects = rects.slice().sort((a, b) => a.y - b.y);
	const groups = [];
	let prevRect = null;
	for (let i = 0; i < sortedRects.length; i++) {
		const rect = sortedRects[i];
		if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) groups.push([rect]);
		else groups[groups.length - 1].push(rect);
		prevRect = rect;
	}
	return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));
}
var inline$2 = function(options$1) {
	if (options$1 === void 0) options$1 = {};
	return {
		name: "inline",
		options: options$1,
		async fn(state) {
			const { placement, elements, rects, platform: platform$1, strategy } = state;
			const { padding = 2, x, y } = evaluate(options$1, state);
			const nativeClientRects = Array.from(await (platform$1.getClientRects == null ? void 0 : platform$1.getClientRects(elements.reference)) || []);
			const clientRects = getRectsByLine(nativeClientRects);
			const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
			const paddingObject = getPaddingObject(padding);
			function getBoundingClientRect$1() {
				if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) return clientRects.find((rect) => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
				if (clientRects.length >= 2) {
					if (getSideAxis(placement) === "y") {
						const firstRect = clientRects[0];
						const lastRect = clientRects[clientRects.length - 1];
						const isTop = getSide(placement) === "top";
						const top$1 = firstRect.top;
						const bottom$1 = lastRect.bottom;
						const left$1 = isTop ? firstRect.left : lastRect.left;
						const right$1 = isTop ? firstRect.right : lastRect.right;
						return {
							top: top$1,
							bottom: bottom$1,
							left: left$1,
							right: right$1,
							width: right$1 - left$1,
							height: bottom$1 - top$1,
							x: left$1,
							y: top$1
						};
					}
					const isLeftSide = getSide(placement) === "left";
					const maxRight = max(...clientRects.map((rect) => rect.right));
					const minLeft = min(...clientRects.map((rect) => rect.left));
					const measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
					const top = measureRects[0].top;
					const bottom = measureRects[measureRects.length - 1].bottom;
					const left = minLeft;
					const right = maxRight;
					return {
						top,
						bottom,
						left,
						right,
						width: right - left,
						height: bottom - top,
						x: left,
						y: top
					};
				}
				return fallback;
			}
			const resetRects = await platform$1.getElementRects({
				reference: { getBoundingClientRect: getBoundingClientRect$1 },
				floating: elements.floating,
				strategy
			});
			if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) return { reset: { rects: resetRects } };
			return {};
		}
	};
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options$1) {
	const { placement, platform: platform$1, elements } = state;
	const rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating));
	const side = getSide(placement);
	const alignment = getAlignment(placement);
	const isVertical = getSideAxis(placement) === "y";
	const mainAxisMulti = originSides.has(side) ? -1 : 1;
	const crossAxisMulti = rtl && isVertical ? -1 : 1;
	const rawValue = evaluate(options$1, state);
	let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === "number" ? {
		mainAxis: rawValue,
		crossAxis: 0,
		alignmentAxis: null
	} : {
		mainAxis: rawValue.mainAxis || 0,
		crossAxis: rawValue.crossAxis || 0,
		alignmentAxis: rawValue.alignmentAxis
	};
	if (alignment && typeof alignmentAxis === "number") crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
	return isVertical ? {
		x: crossAxis * crossAxisMulti,
		y: mainAxis * mainAxisMulti
	} : {
		x: mainAxis * mainAxisMulti,
		y: crossAxis * crossAxisMulti
	};
}
var offset$2 = function(options$1) {
	if (options$1 === void 0) options$1 = 0;
	return {
		name: "offset",
		options: options$1,
		async fn(state) {
			var _middlewareData$offse, _middlewareData$arrow;
			const { x, y, placement, middlewareData } = state;
			const diffCoords = await convertValueToCoords(state, options$1);
			if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) return {};
			return {
				x: x + diffCoords.x,
				y: y + diffCoords.y,
				data: {
					...diffCoords,
					placement
				}
			};
		}
	};
};
var shift$2 = function(options$1) {
	if (options$1 === void 0) options$1 = {};
	return {
		name: "shift",
		options: options$1,
		async fn(state) {
			const { x, y, placement } = state;
			const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = { fn: (_ref) => {
				let { x: x$1, y: y$1 } = _ref;
				return {
					x: x$1,
					y: y$1
				};
			} }, ...detectOverflowOptions } = evaluate(options$1, state);
			const coords = {
				x,
				y
			};
			const overflow = await detectOverflow$1(state, detectOverflowOptions);
			const crossAxis = getSideAxis(getSide(placement));
			const mainAxis = getOppositeAxis(crossAxis);
			let mainAxisCoord = coords[mainAxis];
			let crossAxisCoord = coords[crossAxis];
			if (checkMainAxis) {
				const minSide = mainAxis === "y" ? "top" : "left";
				const maxSide = mainAxis === "y" ? "bottom" : "right";
				const min$1 = mainAxisCoord + overflow[minSide];
				const max$1 = mainAxisCoord - overflow[maxSide];
				mainAxisCoord = clamp$3(min$1, mainAxisCoord, max$1);
			}
			if (checkCrossAxis) {
				const minSide = crossAxis === "y" ? "top" : "left";
				const maxSide = crossAxis === "y" ? "bottom" : "right";
				const min$1 = crossAxisCoord + overflow[minSide];
				const max$1 = crossAxisCoord - overflow[maxSide];
				crossAxisCoord = clamp$3(min$1, crossAxisCoord, max$1);
			}
			const limitedCoords = limiter.fn({
				...state,
				[mainAxis]: mainAxisCoord,
				[crossAxis]: crossAxisCoord
			});
			return {
				...limitedCoords,
				data: {
					x: limitedCoords.x - x,
					y: limitedCoords.y - y,
					enabled: {
						[mainAxis]: checkMainAxis,
						[crossAxis]: checkCrossAxis
					}
				}
			};
		}
	};
};
var limitShift$2 = function(options$1) {
	if (options$1 === void 0) options$1 = {};
	return {
		options: options$1,
		fn(state) {
			const { x, y, placement, rects, middlewareData } = state;
			const { offset: offset$3 = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = evaluate(options$1, state);
			const coords = {
				x,
				y
			};
			const crossAxis = getSideAxis(placement);
			const mainAxis = getOppositeAxis(crossAxis);
			let mainAxisCoord = coords[mainAxis];
			let crossAxisCoord = coords[crossAxis];
			const rawOffset = evaluate(offset$3, state);
			const computedOffset = typeof rawOffset === "number" ? {
				mainAxis: rawOffset,
				crossAxis: 0
			} : {
				mainAxis: 0,
				crossAxis: 0,
				...rawOffset
			};
			if (checkMainAxis) {
				const len = mainAxis === "y" ? "height" : "width";
				const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
				const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
				if (mainAxisCoord < limitMin) mainAxisCoord = limitMin;
				else if (mainAxisCoord > limitMax) mainAxisCoord = limitMax;
			}
			if (checkCrossAxis) {
				var _middlewareData$offse, _middlewareData$offse2;
				const len = mainAxis === "y" ? "width" : "height";
				const isOriginSide = originSides.has(getSide(placement));
				const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
				const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
				if (crossAxisCoord < limitMin) crossAxisCoord = limitMin;
				else if (crossAxisCoord > limitMax) crossAxisCoord = limitMax;
			}
			return {
				[mainAxis]: mainAxisCoord,
				[crossAxis]: crossAxisCoord
			};
		}
	};
};
var size$2 = function(options$1) {
	if (options$1 === void 0) options$1 = {};
	return {
		name: "size",
		options: options$1,
		async fn(state) {
			var _state$middlewareData, _state$middlewareData2;
			const { placement, rects, platform: platform$1, elements } = state;
			const { apply = () => {}, ...detectOverflowOptions } = evaluate(options$1, state);
			const overflow = await detectOverflow$1(state, detectOverflowOptions);
			const side = getSide(placement);
			const alignment = getAlignment(placement);
			const isYAxis = getSideAxis(placement) === "y";
			const { width, height } = rects.floating;
			let heightSide;
			let widthSide;
			if (side === "top" || side === "bottom") {
				heightSide = side;
				widthSide = alignment === (await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
			} else {
				widthSide = side;
				heightSide = alignment === "end" ? "top" : "bottom";
			}
			const maximumClippingHeight = height - overflow.top - overflow.bottom;
			const maximumClippingWidth = width - overflow.left - overflow.right;
			const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
			const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
			const noShift = !state.middlewareData.shift;
			let availableHeight = overflowAvailableHeight;
			let availableWidth = overflowAvailableWidth;
			if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) availableWidth = maximumClippingWidth;
			if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) availableHeight = maximumClippingHeight;
			if (noShift && !alignment) {
				const xMin = max(overflow.left, 0);
				const xMax = max(overflow.right, 0);
				const yMin = max(overflow.top, 0);
				const yMax = max(overflow.bottom, 0);
				if (isYAxis) availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
				else availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
			}
			await apply({
				...state,
				availableWidth,
				availableHeight
			});
			const nextDimensions = await platform$1.getDimensions(elements.floating);
			if (width !== nextDimensions.width || height !== nextDimensions.height) return { reset: { rects: true } };
			return {};
		}
	};
};
function getCssDimensions(element) {
	const css = getComputedStyle$1(element);
	let width = parseFloat(css.width) || 0;
	let height = parseFloat(css.height) || 0;
	const hasOffset = isHTMLElement(element);
	const offsetWidth = hasOffset ? element.offsetWidth : width;
	const offsetHeight = hasOffset ? element.offsetHeight : height;
	const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
	if (shouldFallback) {
		width = offsetWidth;
		height = offsetHeight;
	}
	return {
		width,
		height,
		$: shouldFallback
	};
}
function unwrapElement(element) {
	return !isElement$1(element) ? element.contextElement : element;
}
function getScale(element) {
	const domElement = unwrapElement(element);
	if (!isHTMLElement(domElement)) return createCoords(1);
	const rect = domElement.getBoundingClientRect();
	const { width, height, $ } = getCssDimensions(domElement);
	let x = ($ ? round(rect.width) : rect.width) / width;
	let y = ($ ? round(rect.height) : rect.height) / height;
	if (!x || !Number.isFinite(x)) x = 1;
	if (!y || !Number.isFinite(y)) y = 1;
	return {
		x,
		y
	};
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
	const win = getWindow(element);
	if (!isWebKit() || !win.visualViewport) return noOffsets;
	return {
		x: win.visualViewport.offsetLeft,
		y: win.visualViewport.offsetTop
	};
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
	if (isFixed === void 0) isFixed = false;
	if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) return false;
	return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
	if (includeScale === void 0) includeScale = false;
	if (isFixedStrategy === void 0) isFixedStrategy = false;
	const clientRect = element.getBoundingClientRect();
	const domElement = unwrapElement(element);
	let scale = createCoords(1);
	if (includeScale) if (offsetParent) {
		if (isElement$1(offsetParent)) scale = getScale(offsetParent);
	} else scale = getScale(element);
	const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
	let x = (clientRect.left + visualOffsets.x) / scale.x;
	let y = (clientRect.top + visualOffsets.y) / scale.y;
	let width = clientRect.width / scale.x;
	let height = clientRect.height / scale.y;
	if (domElement) {
		const win = getWindow(domElement);
		const offsetWin = offsetParent && isElement$1(offsetParent) ? getWindow(offsetParent) : offsetParent;
		let currentWin = win;
		let currentIFrame = getFrameElement(currentWin);
		while (currentIFrame && offsetParent && offsetWin !== currentWin) {
			const iframeScale = getScale(currentIFrame);
			const iframeRect = currentIFrame.getBoundingClientRect();
			const css = getComputedStyle$1(currentIFrame);
			const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
			const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
			x *= iframeScale.x;
			y *= iframeScale.y;
			width *= iframeScale.x;
			height *= iframeScale.y;
			x += left;
			y += top;
			currentWin = getWindow(currentIFrame);
			currentIFrame = getFrameElement(currentWin);
		}
	}
	return rectToClientRect({
		width,
		height,
		x,
		y
	});
}
function getWindowScrollBarX(element, rect) {
	const leftScroll = getNodeScroll(element).scrollLeft;
	if (!rect) return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
	return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
	const htmlRect = documentElement.getBoundingClientRect();
	return {
		x: htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect),
		y: htmlRect.top + scroll.scrollTop
	};
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
	let { elements, rect, offsetParent, strategy } = _ref;
	const isFixed = strategy === "fixed";
	const documentElement = getDocumentElement(offsetParent);
	const topLayer = elements ? isTopLayer(elements.floating) : false;
	if (offsetParent === documentElement || topLayer && isFixed) return rect;
	let scroll = {
		scrollLeft: 0,
		scrollTop: 0
	};
	let scale = createCoords(1);
	const offsets = createCoords(0);
	const isOffsetParentAnElement = isHTMLElement(offsetParent);
	if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
		if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) scroll = getNodeScroll(offsetParent);
		if (isHTMLElement(offsetParent)) {
			const offsetRect = getBoundingClientRect(offsetParent);
			scale = getScale(offsetParent);
			offsets.x = offsetRect.x + offsetParent.clientLeft;
			offsets.y = offsetRect.y + offsetParent.clientTop;
		}
	}
	const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
	return {
		width: rect.width * scale.x,
		height: rect.height * scale.y,
		x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
		y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
	};
}
function getClientRects(element) {
	return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
	const html = getDocumentElement(element);
	const scroll = getNodeScroll(element);
	const body = element.ownerDocument.body;
	const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
	const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
	let x = -scroll.scrollLeft + getWindowScrollBarX(element);
	const y = -scroll.scrollTop;
	if (getComputedStyle$1(body).direction === "rtl") x += max(html.clientWidth, body.clientWidth) - width;
	return {
		width,
		height,
		x,
		y
	};
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
	const win = getWindow(element);
	const html = getDocumentElement(element);
	const visualViewport = win.visualViewport;
	let width = html.clientWidth;
	let height = html.clientHeight;
	let x = 0;
	let y = 0;
	if (visualViewport) {
		width = visualViewport.width;
		height = visualViewport.height;
		const visualViewportBased = isWebKit();
		if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
			x = visualViewport.offsetLeft;
			y = visualViewport.offsetTop;
		}
	}
	const windowScrollbarX = getWindowScrollBarX(html);
	if (windowScrollbarX <= 0) {
		const doc = html.ownerDocument;
		const body = doc.body;
		const bodyStyles = getComputedStyle(body);
		const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
		const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
		if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) width -= clippingStableScrollbarWidth;
	} else if (windowScrollbarX <= SCROLLBAR_MAX) width += windowScrollbarX;
	return {
		width,
		height,
		x,
		y
	};
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
	const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
	const top = clientRect.top + element.clientTop;
	const left = clientRect.left + element.clientLeft;
	const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
	return {
		width: element.clientWidth * scale.x,
		height: element.clientHeight * scale.y,
		x: left * scale.x,
		y: top * scale.y
	};
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
	let rect;
	if (clippingAncestor === "viewport") rect = getViewportRect(element, strategy);
	else if (clippingAncestor === "document") rect = getDocumentRect(getDocumentElement(element));
	else if (isElement$1(clippingAncestor)) rect = getInnerBoundingClientRect(clippingAncestor, strategy);
	else {
		const visualOffsets = getVisualOffsets(element);
		rect = {
			x: clippingAncestor.x - visualOffsets.x,
			y: clippingAncestor.y - visualOffsets.y,
			width: clippingAncestor.width,
			height: clippingAncestor.height
		};
	}
	return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
	const parentNode = getParentNode(element);
	if (parentNode === stopNode || !isElement$1(parentNode) || isLastTraversableNode(parentNode)) return false;
	return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
	const cachedResult = cache.get(element);
	if (cachedResult) return cachedResult;
	let result = getOverflowAncestors(element, [], false).filter((el) => isElement$1(el) && getNodeName(el) !== "body");
	let currentContainingBlockComputedStyle = null;
	const elementIsFixed = getComputedStyle$1(element).position === "fixed";
	let currentNode = elementIsFixed ? getParentNode(element) : element;
	while (isElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
		const computedStyle = getComputedStyle$1(currentNode);
		const currentNodeIsContaining = isContainingBlock(currentNode);
		if (!currentNodeIsContaining && computedStyle.position === "fixed") currentContainingBlockComputedStyle = null;
		if (elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode)) result = result.filter((ancestor) => ancestor !== currentNode);
		else currentContainingBlockComputedStyle = computedStyle;
		currentNode = getParentNode(currentNode);
	}
	cache.set(element, result);
	return result;
}
function getClippingRect(_ref) {
	let { element, boundary, rootBoundary, strategy } = _ref;
	const clippingAncestors = [...boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary), rootBoundary];
	const firstClippingAncestor = clippingAncestors[0];
	const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
		const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
		accRect.top = max(rect.top, accRect.top);
		accRect.right = min(rect.right, accRect.right);
		accRect.bottom = min(rect.bottom, accRect.bottom);
		accRect.left = max(rect.left, accRect.left);
		return accRect;
	}, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
	return {
		width: clippingRect.right - clippingRect.left,
		height: clippingRect.bottom - clippingRect.top,
		x: clippingRect.left,
		y: clippingRect.top
	};
}
function getDimensions(element) {
	const { width, height } = getCssDimensions(element);
	return {
		width,
		height
	};
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
	const isOffsetParentAnElement = isHTMLElement(offsetParent);
	const documentElement = getDocumentElement(offsetParent);
	const isFixed = strategy === "fixed";
	const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
	let scroll = {
		scrollLeft: 0,
		scrollTop: 0
	};
	const offsets = createCoords(0);
	function setLeftRTLScrollbarOffset() {
		offsets.x = getWindowScrollBarX(documentElement);
	}
	if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
		if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) scroll = getNodeScroll(offsetParent);
		if (isOffsetParentAnElement) {
			const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
			offsets.x = offsetRect.x + offsetParent.clientLeft;
			offsets.y = offsetRect.y + offsetParent.clientTop;
		} else if (documentElement) setLeftRTLScrollbarOffset();
	}
	if (isFixed && !isOffsetParentAnElement && documentElement) setLeftRTLScrollbarOffset();
	const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
	return {
		x: rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x,
		y: rect.top + scroll.scrollTop - offsets.y - htmlOffset.y,
		width: rect.width,
		height: rect.height
	};
}
function isStaticPositioned(element) {
	return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
	if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") return null;
	if (polyfill) return polyfill(element);
	let rawOffsetParent = element.offsetParent;
	if (getDocumentElement(element) === rawOffsetParent) rawOffsetParent = rawOffsetParent.ownerDocument.body;
	return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
	const win = getWindow(element);
	if (isTopLayer(element)) return win;
	if (!isHTMLElement(element)) {
		let svgOffsetParent = getParentNode(element);
		while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
			if (isElement$1(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) return svgOffsetParent;
			svgOffsetParent = getParentNode(svgOffsetParent);
		}
		return win;
	}
	let offsetParent = getTrueOffsetParent(element, polyfill);
	while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) offsetParent = getTrueOffsetParent(offsetParent, polyfill);
	if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) return win;
	return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
	const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
	const getDimensionsFn = this.getDimensions;
	const floatingDimensions = await getDimensionsFn(data.floating);
	return {
		reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
		floating: {
			x: 0,
			y: 0,
			width: floatingDimensions.width,
			height: floatingDimensions.height
		}
	};
};
function isRTL(element) {
	return getComputedStyle$1(element).direction === "rtl";
}
var platform = {
	convertOffsetParentRelativeRectToViewportRelativeRect,
	getDocumentElement,
	getClippingRect,
	getOffsetParent,
	getElementRects,
	getClientRects,
	getDimensions,
	getScale,
	isElement: isElement$1,
	isRTL
};
function rectsAreEqual(a, b) {
	return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
	let io = null;
	let timeoutId;
	const root$1 = getDocumentElement(element);
	function cleanup() {
		var _io;
		clearTimeout(timeoutId);
		(_io = io) == null || _io.disconnect();
		io = null;
	}
	function refresh(skip, threshold) {
		if (skip === void 0) skip = false;
		if (threshold === void 0) threshold = 1;
		cleanup();
		const elementRectForRootMargin = element.getBoundingClientRect();
		const { left, top, width, height } = elementRectForRootMargin;
		if (!skip) onMove();
		if (!width || !height) return;
		const insetTop = floor(top);
		const insetRight = floor(root$1.clientWidth - (left + width));
		const insetBottom = floor(root$1.clientHeight - (top + height));
		const insetLeft = floor(left);
		const options$1 = {
			rootMargin: -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px",
			threshold: max(0, min(1, threshold)) || 1
		};
		let isFirstUpdate = true;
		function handleObserve(entries) {
			const ratio = entries[0].intersectionRatio;
			if (ratio !== threshold) {
				if (!isFirstUpdate) return refresh();
				if (!ratio) timeoutId = setTimeout(() => {
					refresh(false, 1e-7);
				}, 1e3);
				else refresh(false, ratio);
			}
			if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) refresh();
			isFirstUpdate = false;
		}
		try {
			io = new IntersectionObserver(handleObserve, {
				...options$1,
				root: root$1.ownerDocument
			});
		} catch (_e) {
			io = new IntersectionObserver(handleObserve, options$1);
		}
		io.observe(element);
	}
	refresh(true);
	return cleanup;
}
function autoUpdate(reference, floating, update, options$1) {
	if (options$1 === void 0) options$1 = {};
	const { ancestorScroll = true, ancestorResize = true, elementResize = typeof ResizeObserver === "function", layoutShift = typeof IntersectionObserver === "function", animationFrame = false } = options$1;
	const referenceEl = unwrapElement(reference);
	const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
	ancestors.forEach((ancestor) => {
		ancestorScroll && ancestor.addEventListener("scroll", update, { passive: true });
		ancestorResize && ancestor.addEventListener("resize", update);
	});
	const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
	let reobserveFrame = -1;
	let resizeObserver = null;
	if (elementResize) {
		resizeObserver = new ResizeObserver((_ref) => {
			let [firstEntry] = _ref;
			if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
				resizeObserver.unobserve(floating);
				cancelAnimationFrame(reobserveFrame);
				reobserveFrame = requestAnimationFrame(() => {
					var _resizeObserver;
					(_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
				});
			}
			update();
		});
		if (referenceEl && !animationFrame) resizeObserver.observe(referenceEl);
		resizeObserver.observe(floating);
	}
	let frameId;
	let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
	if (animationFrame) frameLoop();
	function frameLoop() {
		const nextRefRect = getBoundingClientRect(reference);
		if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) update();
		prevRefRect = nextRefRect;
		frameId = requestAnimationFrame(frameLoop);
	}
	update();
	return () => {
		var _resizeObserver2;
		ancestors.forEach((ancestor) => {
			ancestorScroll && ancestor.removeEventListener("scroll", update);
			ancestorResize && ancestor.removeEventListener("resize", update);
		});
		cleanupIo?.();
		(_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
		resizeObserver = null;
		if (animationFrame) cancelAnimationFrame(frameId);
	};
}
var offset$1 = offset$2;
var shift$1 = shift$2;
var flip$1 = flip$2;
var size$1 = size$2;
var hide$1 = hide$2;
var arrow$1 = arrow$2;
var inline$1 = inline$2;
var limitShift$1 = limitShift$2;
var computePosition = (reference, floating, options$1) => {
	const cache = /* @__PURE__ */ new Map();
	const mergedOptions = {
		platform,
		...options$1
	};
	const platformWithCache = {
		...mergedOptions.platform,
		_c: cache
	};
	return computePosition$1(reference, floating, {
		...mergedOptions,
		platform: platformWithCache
	});
};
var import_react_dom$3 = /* @__PURE__ */ __toESM(require_react_dom(), 1);
var index$1 = typeof document !== "undefined" ? import_react.useLayoutEffect : function noop$5() {};
function deepEqual(a, b) {
	if (a === b) return true;
	if (typeof a !== typeof b) return false;
	if (typeof a === "function" && a.toString() === b.toString()) return true;
	let length;
	let i;
	let keys$1;
	if (a && b && typeof a === "object") {
		if (Array.isArray(a)) {
			length = a.length;
			if (length !== b.length) return false;
			for (i = length; i-- !== 0;) if (!deepEqual(a[i], b[i])) return false;
			return true;
		}
		keys$1 = Object.keys(a);
		length = keys$1.length;
		if (length !== Object.keys(b).length) return false;
		for (i = length; i-- !== 0;) if (!{}.hasOwnProperty.call(b, keys$1[i])) return false;
		for (i = length; i-- !== 0;) {
			const key = keys$1[i];
			if (key === "_owner" && a.$$typeof) continue;
			if (!deepEqual(a[key], b[key])) return false;
		}
		return true;
	}
	return a !== a && b !== b;
}
function getDPR(element) {
	if (typeof window === "undefined") return 1;
	return (element.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(element, value) {
	const dpr = getDPR(element);
	return Math.round(value * dpr) / dpr;
}
function useLatestRef$1(value) {
	const ref = import_react.useRef(value);
	index$1(() => {
		ref.current = value;
	});
	return ref;
}
function useFloating$1(options$1) {
	if (options$1 === void 0) options$1 = {};
	const { placement = "bottom", strategy = "absolute", middleware = [], platform: platform$1, elements: { reference: externalReference, floating: externalFloating } = {}, transform = true, whileElementsMounted, open } = options$1;
	const [data, setData] = import_react.useState({
		x: 0,
		y: 0,
		strategy,
		placement,
		middlewareData: {},
		isPositioned: false
	});
	const [latestMiddleware, setLatestMiddleware] = import_react.useState(middleware);
	if (!deepEqual(latestMiddleware, middleware)) setLatestMiddleware(middleware);
	const [_reference, _setReference] = import_react.useState(null);
	const [_floating, _setFloating] = import_react.useState(null);
	const setReference = import_react.useCallback((node) => {
		if (node !== referenceRef.current) {
			referenceRef.current = node;
			_setReference(node);
		}
	}, []);
	const setFloating = import_react.useCallback((node) => {
		if (node !== floatingRef.current) {
			floatingRef.current = node;
			_setFloating(node);
		}
	}, []);
	const referenceEl = externalReference || _reference;
	const floatingEl = externalFloating || _floating;
	const referenceRef = import_react.useRef(null);
	const floatingRef = import_react.useRef(null);
	const dataRef = import_react.useRef(data);
	const hasWhileElementsMounted = whileElementsMounted != null;
	const whileElementsMountedRef = useLatestRef$1(whileElementsMounted);
	const platformRef = useLatestRef$1(platform$1);
	const openRef = useLatestRef$1(open);
	const update = import_react.useCallback(() => {
		if (!referenceRef.current || !floatingRef.current) return;
		const config = {
			placement,
			strategy,
			middleware: latestMiddleware
		};
		if (platformRef.current) config.platform = platformRef.current;
		computePosition(referenceRef.current, floatingRef.current, config).then((data$1) => {
			const fullData = {
				...data$1,
				isPositioned: openRef.current !== false
			};
			if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
				dataRef.current = fullData;
				import_react_dom$3.flushSync(() => {
					setData(fullData);
				});
			}
		});
	}, [
		latestMiddleware,
		placement,
		strategy,
		platformRef,
		openRef
	]);
	index$1(() => {
		if (open === false && dataRef.current.isPositioned) {
			dataRef.current.isPositioned = false;
			setData((data$1) => ({
				...data$1,
				isPositioned: false
			}));
		}
	}, [open]);
	const isMountedRef = import_react.useRef(false);
	index$1(() => {
		isMountedRef.current = true;
		return () => {
			isMountedRef.current = false;
		};
	}, []);
	index$1(() => {
		if (referenceEl) referenceRef.current = referenceEl;
		if (floatingEl) floatingRef.current = floatingEl;
		if (referenceEl && floatingEl) {
			if (whileElementsMountedRef.current) return whileElementsMountedRef.current(referenceEl, floatingEl, update);
			update();
		}
	}, [
		referenceEl,
		floatingEl,
		update,
		whileElementsMountedRef,
		hasWhileElementsMounted
	]);
	const refs = import_react.useMemo(() => ({
		reference: referenceRef,
		floating: floatingRef,
		setReference,
		setFloating
	}), [setReference, setFloating]);
	const elements = import_react.useMemo(() => ({
		reference: referenceEl,
		floating: floatingEl
	}), [referenceEl, floatingEl]);
	const floatingStyles = import_react.useMemo(() => {
		const initialStyles = {
			position: strategy,
			left: 0,
			top: 0
		};
		if (!elements.floating) return initialStyles;
		const x = roundByDPR(elements.floating, data.x);
		const y = roundByDPR(elements.floating, data.y);
		if (transform) return {
			...initialStyles,
			transform: "translate(" + x + "px, " + y + "px)",
			...getDPR(elements.floating) >= 1.5 && { willChange: "transform" }
		};
		return {
			position: strategy,
			left: x,
			top: y
		};
	}, [
		strategy,
		transform,
		elements.floating,
		data.x,
		data.y
	]);
	return import_react.useMemo(() => ({
		...data,
		update,
		refs,
		elements,
		floatingStyles
	}), [
		data,
		update,
		refs,
		elements,
		floatingStyles
	]);
}
var arrow$1$1 = (options$1) => {
	function isRef(value) {
		return {}.hasOwnProperty.call(value, "current");
	}
	return {
		name: "arrow",
		options: options$1,
		fn(state) {
			const { element, padding } = typeof options$1 === "function" ? options$1(state) : options$1;
			if (element && isRef(element)) {
				if (element.current != null) return arrow$1({
					element: element.current,
					padding
				}).fn(state);
				return {};
			}
			if (element) return arrow$1({
				element,
				padding
			}).fn(state);
			return {};
		}
	};
};
var offset = (options$1, deps) => ({
	...offset$1(options$1),
	options: [options$1, deps]
});
var shift = (options$1, deps) => ({
	...shift$1(options$1),
	options: [options$1, deps]
});
var limitShift = (options$1, deps) => ({
	...limitShift$1(options$1),
	options: [options$1, deps]
});
var flip = (options$1, deps) => ({
	...flip$1(options$1),
	options: [options$1, deps]
});
var size = (options$1, deps) => ({
	...size$1(options$1),
	options: [options$1, deps]
});
var hide = (options$1, deps) => ({
	...hide$1(options$1),
	options: [options$1, deps]
});
var inline = (options$1, deps) => ({
	...inline$1(options$1),
	options: [options$1, deps]
});
var arrow = (options$1, deps) => ({
	...arrow$1$1(options$1),
	options: [options$1, deps]
});
require_react_dom();
function useMergeRefs(refs) {
	const cleanupRef = import_react.useRef(void 0);
	const refEffect = import_react.useCallback((instance) => {
		const cleanups = refs.map((ref) => {
			if (ref == null) return;
			if (typeof ref === "function") {
				const refCallback = ref;
				const refCleanup = refCallback(instance);
				return typeof refCleanup === "function" ? refCleanup : () => {
					refCallback(null);
				};
			}
			ref.current = instance;
			return () => {
				ref.current = null;
			};
		});
		return () => {
			cleanups.forEach((refCleanup) => refCleanup == null ? void 0 : refCleanup());
		};
	}, refs);
	return import_react.useMemo(() => {
		if (refs.every((ref) => ref == null)) return null;
		return (value) => {
			if (cleanupRef.current) {
				cleanupRef.current();
				cleanupRef.current = void 0;
			}
			if (value != null) cleanupRef.current = refEffect(value);
		};
	}, refs);
}
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
var ARROW_UP = "ArrowUp";
var ARROW_DOWN = "ArrowDown";
var horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];
var verticalKeys = [ARROW_UP, ARROW_DOWN];
[...horizontalKeys, ...verticalKeys];
var SafeReact = { ...import_react };
var serverHandoffComplete = false;
var count = 0;
var genId = () => "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++;
function useFloatingId() {
	const [id, setId] = import_react.useState(() => serverHandoffComplete ? genId() : void 0);
	index(() => {
		if (id == null) setId(genId());
	}, []);
	import_react.useEffect(() => {
		serverHandoffComplete = true;
	}, []);
	return id;
}
var useId$2 = SafeReact.useId || useFloatingId;
function createEventEmitter() {
	const map$1 = /* @__PURE__ */ new Map();
	return {
		emit(event, data) {
			var _map$get;
			(_map$get = map$1.get(event)) == null || _map$get.forEach((listener) => listener(data));
		},
		on(event, listener) {
			if (!map$1.has(event)) map$1.set(event, /* @__PURE__ */ new Set());
			map$1.get(event).add(listener);
		},
		off(event, listener) {
			var _map$get2;
			(_map$get2 = map$1.get(event)) == null || _map$get2.delete(listener);
		}
	};
}
var FloatingNodeContext = /* @__PURE__ */ import_react.createContext(null);
var FloatingTreeContext = /* @__PURE__ */ import_react.createContext(null);
var useFloatingParentNodeId = () => {
	var _React$useContext;
	return ((_React$useContext = import_react.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
var useFloatingTree = () => import_react.useContext(FloatingTreeContext);
function useFloatingRootContext(options$1) {
	const { open = false, onOpenChange: onOpenChangeProp, elements: elementsProp } = options$1;
	const floatingId = useId$2();
	const dataRef = import_react.useRef({});
	const [events] = import_react.useState(() => createEventEmitter());
	const nested = useFloatingParentNodeId() != null;
	const [positionReference, setPositionReference] = import_react.useState(elementsProp.reference);
	const onOpenChange = useEffectEvent((open$1, event, reason) => {
		dataRef.current.openEvent = open$1 ? event : void 0;
		events.emit("openchange", {
			open: open$1,
			event,
			reason,
			nested
		});
		onOpenChangeProp?.(open$1, event, reason);
	});
	const refs = import_react.useMemo(() => ({ setPositionReference }), []);
	const elements = import_react.useMemo(() => ({
		reference: positionReference || elementsProp.reference || null,
		floating: elementsProp.floating || null,
		domReference: elementsProp.reference
	}), [
		positionReference,
		elementsProp.reference,
		elementsProp.floating
	]);
	return import_react.useMemo(() => ({
		dataRef,
		open,
		onOpenChange,
		elements,
		events,
		floatingId,
		refs
	}), [
		open,
		onOpenChange,
		elements,
		events,
		floatingId,
		refs
	]);
}
function useFloating(options$1) {
	if (options$1 === void 0) options$1 = {};
	const { nodeId } = options$1;
	const internalRootContext = useFloatingRootContext({
		...options$1,
		elements: {
			reference: null,
			floating: null,
			...options$1.elements
		}
	});
	const rootContext = options$1.rootContext || internalRootContext;
	const computedElements = rootContext.elements;
	const [_domReference, setDomReference] = import_react.useState(null);
	const [positionReference, _setPositionReference] = import_react.useState(null);
	const domReference = (computedElements == null ? void 0 : computedElements.domReference) || _domReference;
	const domReferenceRef = import_react.useRef(null);
	const tree = useFloatingTree();
	index(() => {
		if (domReference) domReferenceRef.current = domReference;
	}, [domReference]);
	const position = useFloating$1({
		...options$1,
		elements: {
			...computedElements,
			...positionReference && { reference: positionReference }
		}
	});
	const setPositionReference = import_react.useCallback((node) => {
		const computedPositionReference = isElement$1(node) ? {
			getBoundingClientRect: () => node.getBoundingClientRect(),
			getClientRects: () => node.getClientRects(),
			contextElement: node
		} : node;
		_setPositionReference(computedPositionReference);
		position.refs.setReference(computedPositionReference);
	}, [position.refs]);
	const setReference = import_react.useCallback((node) => {
		if (isElement$1(node) || node === null) {
			domReferenceRef.current = node;
			setDomReference(node);
		}
		if (isElement$1(position.refs.reference.current) || position.refs.reference.current === null || node !== null && !isElement$1(node)) position.refs.setReference(node);
	}, [position.refs]);
	const refs = import_react.useMemo(() => ({
		...position.refs,
		setReference,
		setPositionReference,
		domReference: domReferenceRef
	}), [
		position.refs,
		setReference,
		setPositionReference
	]);
	const elements = import_react.useMemo(() => ({
		...position.elements,
		domReference
	}), [position.elements, domReference]);
	const context = import_react.useMemo(() => ({
		...position,
		...rootContext,
		refs,
		elements,
		nodeId
	}), [
		position,
		refs,
		elements,
		nodeId,
		rootContext
	]);
	index(() => {
		rootContext.dataRef.current.floatingContext = context;
		const node = tree == null ? void 0 : tree.nodesRef.current.find((node$1) => node$1.id === nodeId);
		if (node) node.context = context;
	});
	return import_react.useMemo(() => ({
		...position,
		context,
		refs,
		elements
	}), [
		position,
		refs,
		elements,
		context
	]);
}
var [ScrollAreaProvider, useScrollAreaContext] = createSafeContext("ScrollArea.Root component was not found in tree");
function useResizeObserver(element, onResize) {
	const handleResize = useCallbackRef(onResize);
	useIsomorphicEffect(() => {
		let rAF = 0;
		if (element) {
			const resizeObserver = new ResizeObserver(() => {
				cancelAnimationFrame(rAF);
				rAF = window.requestAnimationFrame(handleResize);
			});
			resizeObserver.observe(element);
			return () => {
				window.cancelAnimationFrame(rAF);
				resizeObserver.unobserve(element);
			};
		}
	}, [element, handleResize]);
}
var Corner = (0, import_react.forwardRef)((props, ref) => {
	const { style: style$1, ...others } = props;
	const ctx = useScrollAreaContext();
	const [width, setWidth] = (0, import_react.useState)(0);
	const [height, setHeight] = (0, import_react.useState)(0);
	const hasSize = Boolean(width && height);
	useResizeObserver(ctx.scrollbarX, () => {
		const h = ctx.scrollbarX?.offsetHeight || 0;
		ctx.onCornerHeightChange(h);
		setHeight(h);
	});
	useResizeObserver(ctx.scrollbarY, () => {
		const w = ctx.scrollbarY?.offsetWidth || 0;
		ctx.onCornerWidthChange(w);
		setWidth(w);
	});
	return hasSize ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		...others,
		ref,
		style: {
			...style$1,
			width,
			height
		}
	}) : null;
});
var ScrollAreaCorner = (0, import_react.forwardRef)((props, ref) => {
	const ctx = useScrollAreaContext();
	const hasBothScrollbarsVisible = Boolean(ctx.scrollbarX && ctx.scrollbarY);
	return ctx.type !== "scroll" && hasBothScrollbarsVisible ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Corner, {
		...props,
		ref
	}) : null;
});
var defaultProps$22 = {
	scrollHideDelay: 1e3,
	type: "hover"
};
var ScrollAreaRoot = (0, import_react.forwardRef)((_props, ref) => {
	const { type, scrollHideDelay, scrollbars, getStyles, ...others } = useProps("ScrollAreaRoot", defaultProps$22, _props);
	const [scrollArea, setScrollArea] = (0, import_react.useState)(null);
	const [viewport, setViewport] = (0, import_react.useState)(null);
	const [content, setContent] = (0, import_react.useState)(null);
	const [scrollbarX, setScrollbarX] = (0, import_react.useState)(null);
	const [scrollbarY, setScrollbarY] = (0, import_react.useState)(null);
	const [cornerWidth, setCornerWidth] = (0, import_react.useState)(0);
	const [cornerHeight, setCornerHeight] = (0, import_react.useState)(0);
	const [scrollbarXEnabled, setScrollbarXEnabled] = (0, import_react.useState)(false);
	const [scrollbarYEnabled, setScrollbarYEnabled] = (0, import_react.useState)(false);
	const rootRef = useMergedRef(ref, (node) => setScrollArea(node));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaProvider, {
		value: {
			type,
			scrollHideDelay,
			scrollArea,
			viewport,
			onViewportChange: setViewport,
			content,
			onContentChange: setContent,
			scrollbarX,
			onScrollbarXChange: setScrollbarX,
			scrollbarXEnabled,
			onScrollbarXEnabledChange: setScrollbarXEnabled,
			scrollbarY,
			onScrollbarYChange: setScrollbarY,
			scrollbarYEnabled,
			onScrollbarYEnabledChange: setScrollbarYEnabled,
			onCornerWidthChange: setCornerWidth,
			onCornerHeightChange: setCornerHeight,
			getStyles
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			...others,
			ref: rootRef,
			__vars: {
				"--sa-corner-width": scrollbars !== "xy" ? "0px" : `${cornerWidth}px`,
				"--sa-corner-height": scrollbars !== "xy" ? "0px" : `${cornerHeight}px`
			}
		})
	});
});
ScrollAreaRoot.displayName = "@mantine/core/ScrollAreaRoot";
function getThumbRatio(viewportSize, contentSize) {
	const ratio = viewportSize / contentSize;
	return Number.isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes) {
	const ratio = getThumbRatio(sizes.viewport, sizes.content);
	const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
	const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
	return Math.max(thumbSize, 18);
}
function linearScale(input, output) {
	return (value) => {
		if (input[0] === input[1] || output[0] === output[1]) return output[0];
		const ratio = (output[1] - output[0]) / (input[1] - input[0]);
		return output[0] + ratio * (value - input[0]);
	};
}
function clamp$2(value, [min$1, max$1]) {
	return Math.min(max$1, Math.max(min$1, value));
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
	const thumbSizePx = getThumbSize(sizes);
	const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
	const scrollbar = sizes.scrollbar.size - scrollbarPadding;
	const maxScrollPos = sizes.content - sizes.viewport;
	const maxThumbPos = scrollbar - thumbSizePx;
	const scrollWithoutMomentum = clamp$2(scrollPos, dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0]);
	return linearScale([0, maxScrollPos], [0, maxThumbPos])(scrollWithoutMomentum);
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
	const thumbSizePx = getThumbSize(sizes);
	const thumbCenter = thumbSizePx / 2;
	const offset$3 = pointerOffset || thumbCenter;
	const thumbOffsetFromEnd = thumbSizePx - offset$3;
	const minPointerPos = sizes.scrollbar.paddingStart + offset$3;
	const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
	const maxScrollPos = sizes.content - sizes.viewport;
	const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
	return linearScale([minPointerPos, maxPointerPos], scrollRange)(pointerPos);
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
	return scrollPos > 0 && scrollPos < maxScrollPos;
}
function toInt(value) {
	return value ? parseInt(value, 10) : 0;
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
	return (event) => {
		originalEventHandler?.(event);
		if (checkForDefaultPrevented === false || !event.defaultPrevented) ourEventHandler?.(event);
	};
}
var [ScrollbarProvider, useScrollbarContext] = createSafeContext("ScrollAreaScrollbar was not found in tree");
var Scrollbar = (0, import_react.forwardRef)((props, forwardedRef) => {
	const { sizes, hasThumb, onThumbChange, onThumbPointerUp, onThumbPointerDown, onThumbPositionChange, onDragScroll, onWheelScroll, onResize, ...scrollbarProps } = props;
	const context = useScrollAreaContext();
	const [scrollbar, setScrollbar] = (0, import_react.useState)(null);
	const composeRefs = useMergedRef(forwardedRef, (node) => setScrollbar(node));
	const rectRef = (0, import_react.useRef)(null);
	const prevWebkitUserSelectRef = (0, import_react.useRef)("");
	const { viewport } = context;
	const maxScrollPos = sizes.content - sizes.viewport;
	const handleWheelScroll = useCallbackRef(onWheelScroll);
	const handleThumbPositionChange = useCallbackRef(onThumbPositionChange);
	const handleResize = useDebouncedCallback(onResize, 10);
	const handleDragScroll = (event) => {
		if (rectRef.current) onDragScroll({
			x: event.clientX - rectRef.current.left,
			y: event.clientY - rectRef.current.top
		});
	};
	(0, import_react.useEffect)(() => {
		const handleWheel = (event) => {
			const element = event.target;
			if (scrollbar?.contains(element)) handleWheelScroll(event, maxScrollPos);
		};
		document.addEventListener("wheel", handleWheel, { passive: false });
		return () => document.removeEventListener("wheel", handleWheel, { passive: false });
	}, [
		viewport,
		scrollbar,
		maxScrollPos,
		handleWheelScroll
	]);
	(0, import_react.useEffect)(handleThumbPositionChange, [sizes, handleThumbPositionChange]);
	useResizeObserver(scrollbar, handleResize);
	useResizeObserver(context.content, handleResize);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollbarProvider, {
		value: {
			scrollbar,
			hasThumb,
			onThumbChange: useCallbackRef(onThumbChange),
			onThumbPointerUp: useCallbackRef(onThumbPointerUp),
			onThumbPositionChange: handleThumbPositionChange,
			onThumbPointerDown: useCallbackRef(onThumbPointerDown)
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			...scrollbarProps,
			ref: composeRefs,
			"data-mantine-scrollbar": true,
			style: {
				position: "absolute",
				...scrollbarProps.style
			},
			onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
				event.preventDefault();
				if (event.button === 0) {
					event.target.setPointerCapture(event.pointerId);
					rectRef.current = scrollbar.getBoundingClientRect();
					prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;
					document.body.style.webkitUserSelect = "none";
					handleDragScroll(event);
				}
			}),
			onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
			onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
				const element = event.target;
				if (element.hasPointerCapture(event.pointerId)) {
					event.preventDefault();
					element.releasePointerCapture(event.pointerId);
				}
			}),
			onLostPointerCapture: () => {
				document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;
				rectRef.current = null;
			}
		})
	});
});
var ScrollAreaScrollbarX = (0, import_react.forwardRef)((props, forwardedRef) => {
	const { sizes, onSizesChange, style: style$1, ...others } = props;
	const ctx = useScrollAreaContext();
	const [computedStyle, setComputedStyle] = (0, import_react.useState)();
	const ref = (0, import_react.useRef)(null);
	const composeRefs = useMergedRef(forwardedRef, ref, ctx.onScrollbarXChange);
	(0, import_react.useEffect)(() => {
		if (ref.current) setComputedStyle(getComputedStyle(ref.current));
	}, [ref]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Scrollbar, {
		"data-orientation": "horizontal",
		...others,
		ref: composeRefs,
		sizes,
		style: {
			...style$1,
			["--sa-thumb-width"]: `${getThumbSize(sizes)}px`
		},
		onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
		onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
		onWheelScroll: (event, maxScrollPos) => {
			if (ctx.viewport) {
				const scrollPos = ctx.viewport.scrollLeft + event.deltaX;
				props.onWheelScroll(scrollPos);
				if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) event.preventDefault();
			}
		},
		onResize: () => {
			if (ref.current && ctx.viewport && computedStyle) onSizesChange({
				content: ctx.viewport.scrollWidth,
				viewport: ctx.viewport.offsetWidth,
				scrollbar: {
					size: ref.current.clientWidth,
					paddingStart: toInt(computedStyle.paddingLeft),
					paddingEnd: toInt(computedStyle.paddingRight)
				}
			});
		}
	});
});
ScrollAreaScrollbarX.displayName = "@mantine/core/ScrollAreaScrollbarX";
var ScrollAreaScrollbarY = (0, import_react.forwardRef)((props, forwardedRef) => {
	const { sizes, onSizesChange, style: style$1, ...others } = props;
	const context = useScrollAreaContext();
	const [computedStyle, setComputedStyle] = (0, import_react.useState)();
	const ref = (0, import_react.useRef)(null);
	const composeRefs = useMergedRef(forwardedRef, ref, context.onScrollbarYChange);
	(0, import_react.useEffect)(() => {
		if (ref.current) setComputedStyle(window.getComputedStyle(ref.current));
	}, []);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Scrollbar, {
		...others,
		"data-orientation": "vertical",
		ref: composeRefs,
		sizes,
		style: {
			["--sa-thumb-height"]: `${getThumbSize(sizes)}px`,
			...style$1
		},
		onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
		onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
		onWheelScroll: (event, maxScrollPos) => {
			if (context.viewport) {
				const scrollPos = context.viewport.scrollTop + event.deltaY;
				props.onWheelScroll(scrollPos);
				if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) event.preventDefault();
			}
		},
		onResize: () => {
			if (ref.current && context.viewport && computedStyle) onSizesChange({
				content: context.viewport.scrollHeight,
				viewport: context.viewport.offsetHeight,
				scrollbar: {
					size: ref.current.clientHeight,
					paddingStart: toInt(computedStyle.paddingTop),
					paddingEnd: toInt(computedStyle.paddingBottom)
				}
			});
		}
	});
});
ScrollAreaScrollbarY.displayName = "@mantine/core/ScrollAreaScrollbarY";
var ScrollAreaScrollbarVisible = (0, import_react.forwardRef)((props, forwardedRef) => {
	const { orientation = "vertical", ...scrollbarProps } = props;
	const { dir } = useDirection();
	const context = useScrollAreaContext();
	const thumbRef = (0, import_react.useRef)(null);
	const pointerOffsetRef = (0, import_react.useRef)(0);
	const [sizes, setSizes] = (0, import_react.useState)({
		content: 0,
		viewport: 0,
		scrollbar: {
			size: 0,
			paddingStart: 0,
			paddingEnd: 0
		}
	});
	const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);
	const commonProps = {
		...scrollbarProps,
		sizes,
		onSizesChange: setSizes,
		hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),
		onThumbChange: (thumb) => {
			thumbRef.current = thumb;
		},
		onThumbPointerUp: () => {
			pointerOffsetRef.current = 0;
		},
		onThumbPointerDown: (pointerPos) => {
			pointerOffsetRef.current = pointerPos;
		}
	};
	const getScrollPosition = (pointerPos, direction) => getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, direction);
	if (orientation === "horizontal") return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarX, {
		...commonProps,
		ref: forwardedRef,
		onThumbPositionChange: () => {
			if (context.viewport && thumbRef.current) {
				const scrollPos = context.viewport.scrollLeft;
				const offset$3 = getThumbOffsetFromScroll(scrollPos, sizes, dir);
				thumbRef.current.style.transform = `translate3d(${offset$3}px, 0, 0)`;
			}
		},
		onWheelScroll: (scrollPos) => {
			if (context.viewport) context.viewport.scrollLeft = scrollPos;
		},
		onDragScroll: (pointerPos) => {
			if (context.viewport) context.viewport.scrollLeft = getScrollPosition(pointerPos, dir);
		}
	});
	if (orientation === "vertical") return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarY, {
		...commonProps,
		ref: forwardedRef,
		onThumbPositionChange: () => {
			if (context.viewport && thumbRef.current) {
				const scrollPos = context.viewport.scrollTop;
				const offset$3 = getThumbOffsetFromScroll(scrollPos, sizes);
				if (sizes.scrollbar.size === 0) thumbRef.current.style.setProperty("--thumb-opacity", "0");
				else thumbRef.current.style.setProperty("--thumb-opacity", "1");
				thumbRef.current.style.transform = `translate3d(0, ${offset$3}px, 0)`;
			}
		},
		onWheelScroll: (scrollPos) => {
			if (context.viewport) context.viewport.scrollTop = scrollPos;
		},
		onDragScroll: (pointerPos) => {
			if (context.viewport) context.viewport.scrollTop = getScrollPosition(pointerPos);
		}
	});
	return null;
});
ScrollAreaScrollbarVisible.displayName = "@mantine/core/ScrollAreaScrollbarVisible";
var ScrollAreaScrollbarAuto = (0, import_react.forwardRef)((props, ref) => {
	const context = useScrollAreaContext();
	const { forceMount, ...scrollbarProps } = props;
	const [visible$1, setVisible] = (0, import_react.useState)(false);
	const isHorizontal = props.orientation === "horizontal";
	const handleResize = useDebouncedCallback(() => {
		if (context.viewport) {
			const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;
			const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
			setVisible(isHorizontal ? isOverflowX : isOverflowY);
		}
	}, 10);
	useResizeObserver(context.viewport, handleResize);
	useResizeObserver(context.content, handleResize);
	if (forceMount || visible$1) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarVisible, {
		"data-state": visible$1 ? "visible" : "hidden",
		...scrollbarProps,
		ref
	});
	return null;
});
ScrollAreaScrollbarAuto.displayName = "@mantine/core/ScrollAreaScrollbarAuto";
var ScrollAreaScrollbarHover = (0, import_react.forwardRef)((props, ref) => {
	const { forceMount, ...scrollbarProps } = props;
	const context = useScrollAreaContext();
	const [visible$1, setVisible] = (0, import_react.useState)(false);
	(0, import_react.useEffect)(() => {
		const { scrollArea } = context;
		let hideTimer = 0;
		if (scrollArea) {
			const handlePointerEnter = () => {
				window.clearTimeout(hideTimer);
				setVisible(true);
			};
			const handlePointerLeave = () => {
				hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);
			};
			scrollArea.addEventListener("pointerenter", handlePointerEnter);
			scrollArea.addEventListener("pointerleave", handlePointerLeave);
			return () => {
				window.clearTimeout(hideTimer);
				scrollArea.removeEventListener("pointerenter", handlePointerEnter);
				scrollArea.removeEventListener("pointerleave", handlePointerLeave);
			};
		}
	}, [context.scrollArea, context.scrollHideDelay]);
	if (forceMount || visible$1) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarAuto, {
		"data-state": visible$1 ? "visible" : "hidden",
		...scrollbarProps,
		ref
	});
	return null;
});
ScrollAreaScrollbarHover.displayName = "@mantine/core/ScrollAreaScrollbarHover";
var ScrollAreaScrollbarScroll = (0, import_react.forwardRef)((props, red) => {
	const { forceMount, ...scrollbarProps } = props;
	const context = useScrollAreaContext();
	const isHorizontal = props.orientation === "horizontal";
	const [state, setState] = (0, import_react.useState)("hidden");
	const debounceScrollEnd = useDebouncedCallback(() => setState("idle"), 100);
	(0, import_react.useEffect)(() => {
		if (state === "idle") {
			const hideTimer = window.setTimeout(() => setState("hidden"), context.scrollHideDelay);
			return () => window.clearTimeout(hideTimer);
		}
	}, [state, context.scrollHideDelay]);
	(0, import_react.useEffect)(() => {
		const { viewport } = context;
		const scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
		if (viewport) {
			let prevScrollPos = viewport[scrollDirection];
			const handleScroll = () => {
				const scrollPos = viewport[scrollDirection];
				if (prevScrollPos !== scrollPos) {
					setState("scrolling");
					debounceScrollEnd();
				}
				prevScrollPos = scrollPos;
			};
			viewport.addEventListener("scroll", handleScroll);
			return () => viewport.removeEventListener("scroll", handleScroll);
		}
	}, [
		context.viewport,
		isHorizontal,
		debounceScrollEnd
	]);
	if (forceMount || state !== "hidden") return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarVisible, {
		"data-state": state === "hidden" ? "hidden" : "visible",
		...scrollbarProps,
		ref: red,
		onPointerEnter: composeEventHandlers(props.onPointerEnter, () => setState("interacting")),
		onPointerLeave: composeEventHandlers(props.onPointerLeave, () => setState("idle"))
	});
	return null;
});
var ScrollAreaScrollbar = (0, import_react.forwardRef)((props, forwardedRef) => {
	const { forceMount, ...scrollbarProps } = props;
	const context = useScrollAreaContext();
	const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;
	const isHorizontal = props.orientation === "horizontal";
	(0, import_react.useEffect)(() => {
		isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);
		return () => {
			isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);
		};
	}, [
		isHorizontal,
		onScrollbarXEnabledChange,
		onScrollbarYEnabledChange
	]);
	return context.type === "hover" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarHover, {
		...scrollbarProps,
		ref: forwardedRef,
		forceMount
	}) : context.type === "scroll" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarScroll, {
		...scrollbarProps,
		ref: forwardedRef,
		forceMount
	}) : context.type === "auto" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarAuto, {
		...scrollbarProps,
		ref: forwardedRef,
		forceMount
	}) : context.type === "always" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarVisible, {
		...scrollbarProps,
		ref: forwardedRef
	}) : null;
});
ScrollAreaScrollbar.displayName = "@mantine/core/ScrollAreaScrollbar";
function addUnlinkedScrollListener(node, handler = () => {}) {
	let prevPosition = {
		left: node.scrollLeft,
		top: node.scrollTop
	};
	let rAF = 0;
	(function loop() {
		const position = {
			left: node.scrollLeft,
			top: node.scrollTop
		};
		const isHorizontalScroll = prevPosition.left !== position.left;
		const isVerticalScroll = prevPosition.top !== position.top;
		if (isHorizontalScroll || isVerticalScroll) handler();
		prevPosition = position;
		rAF = window.requestAnimationFrame(loop);
	})();
	return () => window.cancelAnimationFrame(rAF);
}
var Thumb = (0, import_react.forwardRef)((props, forwardedRef) => {
	const { style: style$1, ...others } = props;
	const scrollAreaContext = useScrollAreaContext();
	const scrollbarContext = useScrollbarContext();
	const { onThumbPositionChange } = scrollbarContext;
	const composedRef = useMergedRef(forwardedRef, (node) => scrollbarContext.onThumbChange(node));
	const removeUnlinkedScrollListenerRef = (0, import_react.useRef)(void 0);
	const debounceScrollEnd = useDebouncedCallback(() => {
		if (removeUnlinkedScrollListenerRef.current) {
			removeUnlinkedScrollListenerRef.current();
			removeUnlinkedScrollListenerRef.current = void 0;
		}
	}, 100);
	(0, import_react.useEffect)(() => {
		const { viewport } = scrollAreaContext;
		if (viewport) {
			const handleScroll = () => {
				debounceScrollEnd();
				if (!removeUnlinkedScrollListenerRef.current) {
					removeUnlinkedScrollListenerRef.current = addUnlinkedScrollListener(viewport, onThumbPositionChange);
					onThumbPositionChange();
				}
			};
			onThumbPositionChange();
			viewport.addEventListener("scroll", handleScroll);
			return () => viewport.removeEventListener("scroll", handleScroll);
		}
	}, [
		scrollAreaContext.viewport,
		debounceScrollEnd,
		onThumbPositionChange
	]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		"data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
		...others,
		ref: composedRef,
		style: {
			width: "var(--sa-thumb-width)",
			height: "var(--sa-thumb-height)",
			...style$1
		},
		onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {
			const thumbRect = event.target.getBoundingClientRect();
			const x = event.clientX - thumbRect.left;
			const y = event.clientY - thumbRect.top;
			scrollbarContext.onThumbPointerDown({
				x,
				y
			});
		}),
		onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)
	});
});
Thumb.displayName = "@mantine/core/ScrollAreaThumb";
var ScrollAreaThumb = (0, import_react.forwardRef)((props, forwardedRef) => {
	const { forceMount, ...thumbProps } = props;
	const scrollbarContext = useScrollbarContext();
	if (forceMount || scrollbarContext.hasThumb) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Thumb, {
		ref: forwardedRef,
		...thumbProps
	});
	return null;
});
ScrollAreaThumb.displayName = "@mantine/core/ScrollAreaThumb";
var ScrollAreaViewport = (0, import_react.forwardRef)(({ children, style: style$1, ...others }, ref) => {
	const ctx = useScrollAreaContext();
	const rootRef = useMergedRef(ref, ctx.onViewportChange);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...others,
		ref: rootRef,
		style: {
			overflowX: ctx.scrollbarXEnabled ? "scroll" : "hidden",
			overflowY: ctx.scrollbarYEnabled ? "scroll" : "hidden",
			...style$1
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			...ctx.getStyles("content"),
			ref: ctx.onContentChange,
			children
		})
	});
});
ScrollAreaViewport.displayName = "@mantine/core/ScrollAreaViewport";
var classes$13 = {
	"root": "m_d57069b5",
	"content": "m_b1336c6",
	"viewport": "m_c0783ff9",
	"viewportInner": "m_f8f631dd",
	"scrollbar": "m_c44ba933",
	"thumb": "m_d8b5e363",
	"corner": "m_21657268"
};
var defaultProps$21 = {
	scrollHideDelay: 1e3,
	type: "hover",
	scrollbars: "xy"
};
var varsResolver$16 = createVarsResolver((_, { scrollbarSize, overscrollBehavior }) => ({ root: {
	"--scrollarea-scrollbar-size": rem(scrollbarSize),
	"--scrollarea-over-scroll-behavior": overscrollBehavior
} }));
var ScrollArea = factory((_props, ref) => {
	const props = useProps("ScrollArea", defaultProps$21, _props);
	const { classNames, className, style: style$1, styles, unstyled, scrollbarSize, vars, type, scrollHideDelay, viewportProps, viewportRef, onScrollPositionChange, children, offsetScrollbars, scrollbars, onBottomReached, onTopReached, overscrollBehavior, attributes, ...others } = props;
	const [scrollbarHovered, setScrollbarHovered] = (0, import_react.useState)(false);
	const [verticalThumbVisible, setVerticalThumbVisible] = (0, import_react.useState)(false);
	const [horizontalThumbVisible, setHorizontalThumbVisible] = (0, import_react.useState)(false);
	const getStyles = useStyles({
		name: "ScrollArea",
		props,
		classes: classes$13,
		className,
		style: style$1,
		classNames,
		styles,
		unstyled,
		attributes,
		vars,
		varsResolver: varsResolver$16
	});
	const localViewportRef = (0, import_react.useRef)(null);
	const combinedViewportRef = useMergeRefs([viewportRef, localViewportRef]);
	(0, import_react.useEffect)(() => {
		if (!localViewportRef.current) return;
		if (offsetScrollbars !== "present") return;
		const element = localViewportRef.current;
		const observer = new ResizeObserver(() => {
			const { scrollHeight, clientHeight, scrollWidth, clientWidth } = element;
			setVerticalThumbVisible(scrollHeight > clientHeight);
			setHorizontalThumbVisible(scrollWidth > clientWidth);
		});
		observer.observe(element);
		return () => observer.disconnect();
	}, [localViewportRef, offsetScrollbars]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(ScrollAreaRoot, {
		getStyles,
		type: type === "never" ? "always" : type,
		scrollHideDelay,
		ref,
		scrollbars,
		...getStyles("root"),
		...others,
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaViewport, {
				...viewportProps,
				...getStyles("viewport", { style: viewportProps?.style }),
				ref: combinedViewportRef,
				"data-offset-scrollbars": offsetScrollbars === true ? "xy" : offsetScrollbars || void 0,
				"data-scrollbars": scrollbars || void 0,
				"data-horizontal-hidden": offsetScrollbars === "present" && !horizontalThumbVisible ? "true" : void 0,
				"data-vertical-hidden": offsetScrollbars === "present" && !verticalThumbVisible ? "true" : void 0,
				onScroll: (e) => {
					viewportProps?.onScroll?.(e);
					onScrollPositionChange?.({
						x: e.currentTarget.scrollLeft,
						y: e.currentTarget.scrollTop
					});
					const { scrollTop, scrollHeight, clientHeight } = e.currentTarget;
					if (scrollTop - (scrollHeight - clientHeight) >= -.6) onBottomReached?.();
					if (scrollTop === 0) onTopReached?.();
				},
				children
			}),
			(scrollbars === "xy" || scrollbars === "x") && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbar, {
				...getStyles("scrollbar"),
				orientation: "horizontal",
				"data-hidden": type === "never" || offsetScrollbars === "present" && !horizontalThumbVisible ? true : void 0,
				forceMount: true,
				onMouseEnter: () => setScrollbarHovered(true),
				onMouseLeave: () => setScrollbarHovered(false),
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaThumb, { ...getStyles("thumb") })
			}),
			(scrollbars === "xy" || scrollbars === "y") && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaScrollbar, {
				...getStyles("scrollbar"),
				orientation: "vertical",
				"data-hidden": type === "never" || offsetScrollbars === "present" && !verticalThumbVisible ? true : void 0,
				forceMount: true,
				onMouseEnter: () => setScrollbarHovered(true),
				onMouseLeave: () => setScrollbarHovered(false),
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaThumb, { ...getStyles("thumb") })
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollAreaCorner, {
				...getStyles("corner"),
				"data-hovered": scrollbarHovered || void 0,
				"data-hidden": type === "never" || void 0
			})
		]
	});
});
ScrollArea.displayName = "@mantine/core/ScrollArea";
var ScrollAreaAutosize = factory((props, ref) => {
	const { children, classNames, styles, scrollbarSize, scrollHideDelay, type, dir, offsetScrollbars, viewportRef, onScrollPositionChange, unstyled, variant, viewportProps, scrollbars, style: style$1, vars, onBottomReached, onTopReached, onOverflowChange, ...others } = useProps("ScrollAreaAutosize", defaultProps$21, props);
	const viewportObserverRef = (0, import_react.useRef)(null);
	const combinedViewportRef = useMergeRefs([viewportRef, viewportObserverRef]);
	const [overflowing, setOverflowing] = (0, import_react.useState)(false);
	const didMount = (0, import_react.useRef)(false);
	(0, import_react.useEffect)(() => {
		if (!onOverflowChange) return;
		const el = viewportObserverRef.current;
		if (!el) return;
		const update = () => {
			const isOverflowing = el.scrollHeight > el.clientHeight;
			if (isOverflowing !== overflowing) {
				if (didMount.current) onOverflowChange?.(isOverflowing);
				else {
					didMount.current = true;
					if (isOverflowing) onOverflowChange?.(true);
				}
				setOverflowing(isOverflowing);
			}
		};
		update();
		const ro = new ResizeObserver(update);
		ro.observe(el);
		return () => ro.disconnect();
	}, [onOverflowChange, overflowing]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...others,
		ref,
		style: [{
			display: "flex",
			overflow: "hidden"
		}, style$1],
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			style: {
				display: "flex",
				flexDirection: "column",
				flex: 1,
				overflow: "hidden",
				...scrollbars === "y" && { minWidth: 0 },
				...scrollbars === "x" && { minHeight: 0 },
				...scrollbars === "xy" && {
					minWidth: 0,
					minHeight: 0
				},
				...scrollbars === false && {
					minWidth: 0,
					minHeight: 0
				}
			},
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollArea, {
				classNames,
				styles,
				scrollHideDelay,
				scrollbarSize,
				type,
				dir,
				offsetScrollbars,
				viewportRef: combinedViewportRef,
				onScrollPositionChange,
				unstyled,
				variant,
				viewportProps,
				vars,
				scrollbars,
				onBottomReached,
				onTopReached,
				"data-autosize": "true",
				children
			})
		})
	});
});
ScrollArea.classes = classes$13;
ScrollAreaAutosize.displayName = "@mantine/core/ScrollAreaAutosize";
ScrollAreaAutosize.classes = classes$13;
ScrollArea.Autosize = ScrollAreaAutosize;
var classes$12 = { "root": "m_87cf2631" };
var defaultProps$20 = { __staticSelector: "UnstyledButton" };
var UnstyledButton = polymorphicFactory((_props, ref) => {
	const props = useProps("UnstyledButton", defaultProps$20, _props);
	const { className, component = "button", __staticSelector, unstyled, classNames, styles, style: style$1, attributes, ...others } = props;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...useStyles({
			name: __staticSelector,
			props,
			classes: classes$12,
			className,
			style: style$1,
			classNames,
			styles,
			unstyled,
			attributes
		})("root", { focusable: true }),
		component,
		ref,
		type: component === "button" ? "button" : void 0,
		...others
	});
});
UnstyledButton.classes = classes$12;
UnstyledButton.displayName = "@mantine/core/UnstyledButton";
var classes$11 = { "root": "m_515a97f8" };
var VisuallyHidden = factory((_props, ref) => {
	const props = useProps("VisuallyHidden", null, _props);
	const { classNames, className, style: style$1, styles, unstyled, vars, attributes, ...others } = props;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "span",
		ref,
		...useStyles({
			name: "VisuallyHidden",
			classes: classes$11,
			props,
			className,
			style: style$1,
			classNames,
			styles,
			unstyled,
			attributes
		})("root"),
		...others
	});
});
VisuallyHidden.classes = classes$11;
VisuallyHidden.displayName = "@mantine/core/VisuallyHidden";
function horizontalSide(placement, arrowY, arrowOffset, arrowPosition) {
	if (placement === "center" || arrowPosition === "center") return { top: arrowY };
	if (placement === "end") return { bottom: arrowOffset };
	if (placement === "start") return { top: arrowOffset };
	return {};
}
function verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir) {
	if (placement === "center" || arrowPosition === "center") return { left: arrowX };
	if (placement === "end") return { [dir === "ltr" ? "right" : "left"]: arrowOffset };
	if (placement === "start") return { [dir === "ltr" ? "left" : "right"]: arrowOffset };
	return {};
}
var radiusByFloatingSide = {
	bottom: "borderTopLeftRadius",
	left: "borderTopRightRadius",
	right: "borderBottomLeftRadius",
	top: "borderBottomRightRadius"
};
function getArrowPositionStyles({ position, arrowSize, arrowOffset, arrowRadius, arrowPosition, arrowX, arrowY, dir }) {
	const [side, placement = "center"] = position.split("-");
	const baseStyles = {
		width: arrowSize,
		height: arrowSize,
		transform: "rotate(45deg)",
		position: "absolute",
		[radiusByFloatingSide[side]]: arrowRadius
	};
	const arrowPlacement = -arrowSize / 2;
	if (side === "left") return {
		...baseStyles,
		...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),
		right: arrowPlacement,
		borderLeftColor: "transparent",
		borderBottomColor: "transparent",
		clipPath: "polygon(100% 0, 0 0, 100% 100%)"
	};
	if (side === "right") return {
		...baseStyles,
		...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),
		left: arrowPlacement,
		borderRightColor: "transparent",
		borderTopColor: "transparent",
		clipPath: "polygon(0 100%, 0 0, 100% 100%)"
	};
	if (side === "top") return {
		...baseStyles,
		...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),
		bottom: arrowPlacement,
		borderTopColor: "transparent",
		borderLeftColor: "transparent",
		clipPath: "polygon(0 100%, 100% 100%, 100% 0)"
	};
	if (side === "bottom") return {
		...baseStyles,
		...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),
		top: arrowPlacement,
		borderBottomColor: "transparent",
		borderRightColor: "transparent",
		clipPath: "polygon(0 100%, 0 0, 100% 0)"
	};
	return {};
}
var FloatingArrow = (0, import_react.forwardRef)(({ position, arrowSize, arrowOffset, arrowRadius, arrowPosition, visible: visible$1, arrowX, arrowY, style: style$1, ...others }, ref) => {
	const { dir } = useDirection();
	if (!visible$1) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		...others,
		ref,
		style: {
			...style$1,
			...getArrowPositionStyles({
				position,
				arrowSize,
				arrowOffset,
				arrowRadius,
				arrowPosition,
				dir,
				arrowX,
				arrowY
			})
		}
	});
});
FloatingArrow.displayName = "@mantine/core/FloatingArrow";
function getFloatingPosition(dir, position) {
	if (dir === "rtl" && (position.includes("right") || position.includes("left"))) {
		const [side, placement] = position.split("-");
		const flippedPosition = side === "right" ? "left" : "right";
		return placement === void 0 ? flippedPosition : `${flippedPosition}-${placement}`;
	}
	return position;
}
var classes$10 = { "root": "m_9814e45f" };
var defaultProps$19 = { zIndex: getDefaultZIndex("modal") };
var varsResolver$15 = createVarsResolver((_, { gradient, color, backgroundOpacity, blur, radius, zIndex }) => ({ root: {
	"--overlay-bg": gradient || (color !== void 0 || backgroundOpacity !== void 0) && rgba(color || "#000", backgroundOpacity ?? .6) || void 0,
	"--overlay-filter": blur ? `blur(${rem(blur)})` : void 0,
	"--overlay-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--overlay-z-index": zIndex?.toString()
} }));
var Overlay = polymorphicFactory((_props, ref) => {
	const props = useProps("Overlay", defaultProps$19, _props);
	const { classNames, className, style: style$1, styles, unstyled, vars, fixed, center, children, radius, zIndex, gradient, blur, color, backgroundOpacity, mod, attributes, ...others } = props;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...useStyles({
			name: "Overlay",
			props,
			classes: classes$10,
			className,
			style: style$1,
			classNames,
			styles,
			unstyled,
			attributes,
			vars,
			varsResolver: varsResolver$15
		})("root"),
		mod: [{
			center,
			fixed
		}, mod],
		...others,
		children
	});
});
Overlay.classes = classes$10;
Overlay.displayName = "@mantine/core/Overlay";
var import_react_dom$1 = require_react_dom();
function createPortalNode(props) {
	const node = document.createElement("div");
	node.setAttribute("data-portal", "true");
	typeof props.className === "string" && node.classList.add(...props.className.split(" ").filter(Boolean));
	typeof props.style === "object" && Object.assign(node.style, props.style);
	typeof props.id === "string" && node.setAttribute("id", props.id);
	return node;
}
function getTargetNode({ target, reuseTargetNode, ...others }) {
	if (target) {
		if (typeof target === "string") return document.querySelector(target) || createPortalNode(others);
		return target;
	}
	if (reuseTargetNode) {
		const existingNode = document.querySelector("[data-mantine-shared-portal-node]");
		if (existingNode) return existingNode;
		const node = createPortalNode(others);
		node.setAttribute("data-mantine-shared-portal-node", "true");
		document.body.appendChild(node);
		return node;
	}
	return createPortalNode(others);
}
var defaultProps$18 = { reuseTargetNode: true };
var Portal = factory((props, ref) => {
	const { children, target, reuseTargetNode, ...others } = useProps("Portal", defaultProps$18, props);
	const [mounted, setMounted] = (0, import_react.useState)(false);
	const nodeRef = (0, import_react.useRef)(null);
	useIsomorphicEffect(() => {
		setMounted(true);
		nodeRef.current = getTargetNode({
			target,
			reuseTargetNode,
			...others
		});
		assignRef(ref, nodeRef.current);
		if (!target && !reuseTargetNode && nodeRef.current) document.body.appendChild(nodeRef.current);
		return () => {
			if (!target && !reuseTargetNode && nodeRef.current) document.body.removeChild(nodeRef.current);
		};
	}, [target]);
	if (!mounted || !nodeRef.current) return null;
	return (0, import_react_dom$1.createPortal)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children }), nodeRef.current);
});
Portal.displayName = "@mantine/core/Portal";
var OptionalPortal = factory(({ withinPortal = true, children, ...others }, ref) => {
	if (useMantineEnv() === "test" || !withinPortal) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Portal, {
		ref,
		...others,
		children
	});
});
OptionalPortal.displayName = "@mantine/core/OptionalPortal";
var popIn = (from) => ({
	in: {
		opacity: 1,
		transform: "scale(1)"
	},
	out: {
		opacity: 0,
		transform: `scale(.9) translateY(${from === "bottom" ? 10 : -10}px)`
	},
	transitionProperty: "transform, opacity"
});
var transitions = {
	fade: {
		in: { opacity: 1 },
		out: { opacity: 0 },
		transitionProperty: "opacity"
	},
	"fade-up": {
		in: {
			opacity: 1,
			transform: "translateY(0)"
		},
		out: {
			opacity: 0,
			transform: "translateY(30px)"
		},
		transitionProperty: "opacity, transform"
	},
	"fade-down": {
		in: {
			opacity: 1,
			transform: "translateY(0)"
		},
		out: {
			opacity: 0,
			transform: "translateY(-30px)"
		},
		transitionProperty: "opacity, transform"
	},
	"fade-left": {
		in: {
			opacity: 1,
			transform: "translateX(0)"
		},
		out: {
			opacity: 0,
			transform: "translateX(30px)"
		},
		transitionProperty: "opacity, transform"
	},
	"fade-right": {
		in: {
			opacity: 1,
			transform: "translateX(0)"
		},
		out: {
			opacity: 0,
			transform: "translateX(-30px)"
		},
		transitionProperty: "opacity, transform"
	},
	scale: {
		in: {
			opacity: 1,
			transform: "scale(1)"
		},
		out: {
			opacity: 0,
			transform: "scale(0)"
		},
		common: { transformOrigin: "top" },
		transitionProperty: "transform, opacity"
	},
	"scale-y": {
		in: {
			opacity: 1,
			transform: "scaleY(1)"
		},
		out: {
			opacity: 0,
			transform: "scaleY(0)"
		},
		common: { transformOrigin: "top" },
		transitionProperty: "transform, opacity"
	},
	"scale-x": {
		in: {
			opacity: 1,
			transform: "scaleX(1)"
		},
		out: {
			opacity: 0,
			transform: "scaleX(0)"
		},
		common: { transformOrigin: "left" },
		transitionProperty: "transform, opacity"
	},
	"skew-up": {
		in: {
			opacity: 1,
			transform: "translateY(0) skew(0deg, 0deg)"
		},
		out: {
			opacity: 0,
			transform: "translateY(-20px) skew(-10deg, -5deg)"
		},
		common: { transformOrigin: "top" },
		transitionProperty: "transform, opacity"
	},
	"skew-down": {
		in: {
			opacity: 1,
			transform: "translateY(0) skew(0deg, 0deg)"
		},
		out: {
			opacity: 0,
			transform: "translateY(20px) skew(-10deg, -5deg)"
		},
		common: { transformOrigin: "bottom" },
		transitionProperty: "transform, opacity"
	},
	"rotate-left": {
		in: {
			opacity: 1,
			transform: "translateY(0) rotate(0deg)"
		},
		out: {
			opacity: 0,
			transform: "translateY(20px) rotate(-5deg)"
		},
		common: { transformOrigin: "bottom" },
		transitionProperty: "transform, opacity"
	},
	"rotate-right": {
		in: {
			opacity: 1,
			transform: "translateY(0) rotate(0deg)"
		},
		out: {
			opacity: 0,
			transform: "translateY(20px) rotate(5deg)"
		},
		common: { transformOrigin: "top" },
		transitionProperty: "transform, opacity"
	},
	"slide-down": {
		in: {
			opacity: 1,
			transform: "translateY(0)"
		},
		out: {
			opacity: 0,
			transform: "translateY(-100%)"
		},
		common: { transformOrigin: "top" },
		transitionProperty: "transform, opacity"
	},
	"slide-up": {
		in: {
			opacity: 1,
			transform: "translateY(0)"
		},
		out: {
			opacity: 0,
			transform: "translateY(100%)"
		},
		common: { transformOrigin: "bottom" },
		transitionProperty: "transform, opacity"
	},
	"slide-left": {
		in: {
			opacity: 1,
			transform: "translateX(0)"
		},
		out: {
			opacity: 0,
			transform: "translateX(100%)"
		},
		common: { transformOrigin: "left" },
		transitionProperty: "transform, opacity"
	},
	"slide-right": {
		in: {
			opacity: 1,
			transform: "translateX(0)"
		},
		out: {
			opacity: 0,
			transform: "translateX(-100%)"
		},
		common: { transformOrigin: "right" },
		transitionProperty: "transform, opacity"
	},
	pop: {
		...popIn("bottom"),
		common: { transformOrigin: "center center" }
	},
	"pop-bottom-left": {
		...popIn("bottom"),
		common: { transformOrigin: "bottom left" }
	},
	"pop-bottom-right": {
		...popIn("bottom"),
		common: { transformOrigin: "bottom right" }
	},
	"pop-top-left": {
		...popIn("top"),
		common: { transformOrigin: "top left" }
	},
	"pop-top-right": {
		...popIn("top"),
		common: { transformOrigin: "top right" }
	}
};
var transitionStatuses = {
	entering: "in",
	entered: "in",
	exiting: "out",
	exited: "out",
	"pre-exiting": "out",
	"pre-entering": "out"
};
function getTransitionStyles({ transition, state, duration, timingFunction }) {
	const shared = {
		WebkitBackfaceVisibility: "hidden",
		transitionDuration: `${duration}ms`,
		transitionTimingFunction: timingFunction
	};
	if (typeof transition === "string") {
		if (!(transition in transitions)) return {};
		return {
			transitionProperty: transitions[transition].transitionProperty,
			...shared,
			...transitions[transition].common,
			...transitions[transition][transitionStatuses[state]]
		};
	}
	return {
		transitionProperty: transition.transitionProperty,
		...shared,
		...transition.common,
		...transition[transitionStatuses[state]]
	};
}
var import_react_dom = /* @__PURE__ */ __toESM(require_react_dom(), 1);
function useTransition({ duration, exitDuration, timingFunction, mounted, onEnter, onExit, onEntered, onExited, enterDelay, exitDelay }) {
	const theme$1 = useMantineTheme();
	const shouldReduceMotion = useReducedMotion();
	const reduceMotion = theme$1.respectReducedMotion ? shouldReduceMotion : false;
	const [transitionDuration, setTransitionDuration] = (0, import_react.useState)(reduceMotion ? 0 : duration);
	const [transitionStatus, setStatus] = (0, import_react.useState)(mounted ? "entered" : "exited");
	const transitionTimeoutRef = (0, import_react.useRef)(-1);
	const delayTimeoutRef = (0, import_react.useRef)(-1);
	const rafRef = (0, import_react.useRef)(-1);
	function clearAllTimeouts() {
		window.clearTimeout(transitionTimeoutRef.current);
		window.clearTimeout(delayTimeoutRef.current);
		cancelAnimationFrame(rafRef.current);
	}
	const handleStateChange = (shouldMount) => {
		clearAllTimeouts();
		const preHandler = shouldMount ? onEnter : onExit;
		const handler = shouldMount ? onEntered : onExited;
		const newTransitionDuration = reduceMotion ? 0 : shouldMount ? duration : exitDuration;
		setTransitionDuration(newTransitionDuration);
		if (newTransitionDuration === 0) {
			typeof preHandler === "function" && preHandler();
			typeof handler === "function" && handler();
			setStatus(shouldMount ? "entered" : "exited");
		} else rafRef.current = requestAnimationFrame(() => {
			import_react_dom.flushSync(() => {
				setStatus(shouldMount ? "pre-entering" : "pre-exiting");
			});
			rafRef.current = requestAnimationFrame(() => {
				typeof preHandler === "function" && preHandler();
				setStatus(shouldMount ? "entering" : "exiting");
				transitionTimeoutRef.current = window.setTimeout(() => {
					typeof handler === "function" && handler();
					setStatus(shouldMount ? "entered" : "exited");
				}, newTransitionDuration);
			});
		});
	};
	const handleTransitionWithDelay = (shouldMount) => {
		clearAllTimeouts();
		if (typeof (shouldMount ? enterDelay : exitDelay) !== "number") {
			handleStateChange(shouldMount);
			return;
		}
		delayTimeoutRef.current = window.setTimeout(() => {
			handleStateChange(shouldMount);
		}, shouldMount ? enterDelay : exitDelay);
	};
	useDidUpdate(() => {
		handleTransitionWithDelay(mounted);
	}, [mounted]);
	(0, import_react.useEffect)(() => () => {
		clearAllTimeouts();
	}, []);
	return {
		transitionDuration,
		transitionStatus,
		transitionTimingFunction: timingFunction || "ease"
	};
}
function Transition({ keepMounted, transition = "fade", duration = 250, exitDuration = duration, mounted, children, timingFunction = "ease", onExit, onEntered, onEnter, onExited, enterDelay, exitDelay }) {
	const env = useMantineEnv();
	const { transitionDuration, transitionStatus, transitionTimingFunction } = useTransition({
		mounted,
		exitDuration,
		duration,
		timingFunction,
		onExit,
		onEntered,
		onEnter,
		onExited,
		enterDelay,
		exitDelay
	});
	if (transitionDuration === 0 || env === "test") return mounted ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: children({}) }) : keepMounted ? children({ display: "none" }) : null;
	return transitionStatus === "exited" ? keepMounted ? children({ display: "none" }) : null : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: children(getTransitionStyles({
		transition,
		duration: transitionDuration,
		state: transitionStatus,
		timingFunction: transitionTimingFunction
	})) });
}
Transition.displayName = "@mantine/core/Transition";
var [PopoverContextProvider, usePopoverContext] = createSafeContext("Popover component was not found in the tree");
function FocusTrap({ children, active = true, refProp = "ref", innerRef }) {
	const ref = useMergedRef(useFocusTrap(active), innerRef);
	const child = getSingleElementChild(children);
	if (!child) return children;
	return (0, import_react.cloneElement)(child, { [refProp]: ref });
}
function FocusTrapInitialFocus(props) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(VisuallyHidden, {
		tabIndex: -1,
		"data-autofocus": true,
		...props
	});
}
FocusTrap.displayName = "@mantine/core/FocusTrap";
FocusTrapInitialFocus.displayName = "@mantine/core/FocusTrapInitialFocus";
FocusTrap.InitialFocus = FocusTrapInitialFocus;
var classes$9 = {
	"dropdown": "m_38a85659",
	"arrow": "m_a31dc6c1",
	"overlay": "m_3d7bc908"
};
var PopoverDropdown = factory((_props, ref) => {
	const props = useProps("PopoverDropdown", null, _props);
	const { className, style: style$1, vars, children, onKeyDownCapture, variant, classNames, styles, ...others } = props;
	const ctx = usePopoverContext();
	const returnFocus = useFocusReturn({
		opened: ctx.opened,
		shouldReturnFocus: ctx.returnFocus
	});
	const accessibleProps = ctx.withRoles ? {
		"aria-labelledby": ctx.getTargetId(),
		id: ctx.getDropdownId(),
		role: "dialog",
		tabIndex: -1
	} : {};
	const mergedRef = useMergedRef(ref, ctx.floating);
	if (ctx.disabled) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OptionalPortal, {
		...ctx.portalProps,
		withinPortal: ctx.withinPortal,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
			mounted: ctx.opened,
			...ctx.transitionProps,
			transition: ctx.transitionProps?.transition || "fade",
			duration: ctx.transitionProps?.duration ?? 150,
			keepMounted: ctx.keepMounted,
			exitDuration: typeof ctx.transitionProps?.exitDuration === "number" ? ctx.transitionProps.exitDuration : ctx.transitionProps?.duration,
			children: (transitionStyles) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FocusTrap, {
				active: ctx.trapFocus && ctx.opened,
				innerRef: mergedRef,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
					...accessibleProps,
					...others,
					variant,
					onKeyDownCapture: closeOnEscape(() => {
						ctx.onClose?.();
						ctx.onDismiss?.();
					}, {
						active: ctx.closeOnEscape,
						onTrigger: returnFocus,
						onKeyDown: onKeyDownCapture
					}),
					"data-position": ctx.placement,
					"data-fixed": ctx.floatingStrategy === "fixed" || void 0,
					...ctx.getStyles("dropdown", {
						className,
						props,
						classNames,
						styles,
						style: [
							{
								...transitionStyles,
								zIndex: ctx.zIndex,
								top: ctx.y ?? 0,
								left: ctx.x ?? 0,
								width: ctx.width === "target" ? void 0 : rem(ctx.width),
								...ctx.referenceHidden ? { display: "none" } : null
							},
							ctx.resolvedStyles.dropdown,
							styles?.dropdown,
							style$1
						]
					}),
					children: [children, /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FloatingArrow, {
						ref: ctx.arrowRef,
						arrowX: ctx.arrowX,
						arrowY: ctx.arrowY,
						visible: ctx.withArrow,
						position: ctx.placement,
						arrowSize: ctx.arrowSize,
						arrowRadius: ctx.arrowRadius,
						arrowOffset: ctx.arrowOffset,
						arrowPosition: ctx.arrowPosition,
						...ctx.getStyles("arrow", {
							props,
							classNames,
							styles
						})
					})]
				})
			})
		})
	});
});
PopoverDropdown.classes = classes$9;
PopoverDropdown.displayName = "@mantine/core/PopoverDropdown";
var defaultProps$17 = {
	refProp: "ref",
	popupType: "dialog"
};
var PopoverTarget = factory((props, ref) => {
	const { children, refProp, popupType, ...others } = useProps("PopoverTarget", defaultProps$17, props);
	const child = getSingleElementChild(children);
	if (!child) throw new Error("Popover.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
	const forwardedProps = others;
	const ctx = usePopoverContext();
	const targetRef = useMergedRef(ctx.reference, getRefProp(child), ref);
	const accessibleProps = ctx.withRoles ? {
		"aria-haspopup": popupType,
		"aria-expanded": ctx.opened,
		"aria-controls": ctx.getDropdownId(),
		id: ctx.getTargetId()
	} : {};
	const childProps = child.props;
	return (0, import_react.cloneElement)(child, {
		...forwardedProps,
		...accessibleProps,
		...ctx.targetProps,
		className: clsx_default(ctx.targetProps.className, forwardedProps.className, childProps.className),
		[refProp]: targetRef,
		...!ctx.controlled ? { onClick: () => {
			ctx.onToggle();
			childProps.onClick?.();
		} } : null
	});
});
PopoverTarget.displayName = "@mantine/core/PopoverTarget";
function getDefaultMiddlewares(middlewares) {
	if (middlewares === void 0) return {
		shift: true,
		flip: true
	};
	const result = { ...middlewares };
	if (middlewares.shift === void 0) result.shift = true;
	if (middlewares.flip === void 0) result.flip = true;
	return result;
}
function getPopoverMiddlewares(options$1, getFloating, env) {
	const middlewaresOptions = getDefaultMiddlewares(options$1.middlewares);
	const middlewares = [offset(options$1.offset), hide()];
	if (options$1.dropdownVisible && env !== "test" && options$1.preventPositionChangeWhenVisible) middlewaresOptions.flip = false;
	if (middlewaresOptions.shift) middlewares.push(shift(typeof middlewaresOptions.shift === "boolean" ? {
		limiter: limitShift(),
		padding: 5
	} : {
		limiter: limitShift(),
		padding: 5,
		...middlewaresOptions.shift
	}));
	if (middlewaresOptions.flip) middlewares.push(typeof middlewaresOptions.flip === "boolean" ? flip() : flip(middlewaresOptions.flip));
	if (middlewaresOptions.inline) middlewares.push(typeof middlewaresOptions.inline === "boolean" ? inline() : inline(middlewaresOptions.inline));
	middlewares.push(arrow({
		element: options$1.arrowRef,
		padding: options$1.arrowOffset
	}));
	if (middlewaresOptions.size || options$1.width === "target") middlewares.push(size({
		...typeof middlewaresOptions.size === "boolean" ? {} : middlewaresOptions.size,
		apply({ rects, availableWidth, availableHeight, ...rest }) {
			const styles = getFloating().refs.floating.current?.style ?? {};
			if (middlewaresOptions.size) if (typeof middlewaresOptions.size === "object" && !!middlewaresOptions.size.apply) middlewaresOptions.size.apply({
				rects,
				availableWidth,
				availableHeight,
				...rest
			});
			else Object.assign(styles, {
				maxWidth: `${availableWidth}px`,
				maxHeight: `${availableHeight}px`
			});
			if (options$1.width === "target") Object.assign(styles, { width: `${rects.reference.width}px` });
		}
	}));
	return middlewares;
}
function usePopover(options$1) {
	const env = useMantineEnv();
	const [_opened, setOpened] = useUncontrolled({
		value: options$1.opened,
		defaultValue: options$1.defaultOpened,
		finalValue: false,
		onChange: options$1.onChange
	});
	const previouslyOpened = (0, import_react.useRef)(_opened);
	const onClose = () => {
		if (_opened && !options$1.disabled) setOpened(false);
	};
	const onToggle = () => {
		if (!options$1.disabled) setOpened(!_opened);
	};
	const floating = useFloating({
		strategy: options$1.strategy,
		placement: options$1.preventPositionChangeWhenVisible ? options$1.positionRef.current : options$1.position,
		middleware: getPopoverMiddlewares(options$1, () => floating, env),
		whileElementsMounted: !options$1.keepMounted ? autoUpdate : void 0
	});
	(0, import_react.useEffect)(() => {
		if (!floating.refs.reference.current || !floating.refs.floating.current) return;
		if (_opened) return autoUpdate(floating.refs.reference.current, floating.refs.floating.current, floating.update);
	}, [_opened, floating.update]);
	useDidUpdate(() => {
		options$1.onPositionChange?.(floating.placement);
		options$1.positionRef.current = floating.placement;
	}, [floating.placement, options$1.preventPositionChangeWhenVisible]);
	useDidUpdate(() => {
		if (_opened !== previouslyOpened.current) if (!_opened) options$1.onClose?.();
		else options$1.onOpen?.();
		previouslyOpened.current = _opened;
	}, [
		_opened,
		options$1.onClose,
		options$1.onOpen
	]);
	useIsomorphicEffect(() => {
		let timeout = -1;
		if (_opened) timeout = window.setTimeout(() => options$1.setDropdownVisible(true), 4);
		return () => {
			window.clearTimeout(timeout);
		};
	}, [_opened, options$1.position]);
	return {
		floating,
		controlled: typeof options$1.opened === "boolean",
		opened: _opened,
		onClose,
		onToggle
	};
}
var defaultProps$16 = {
	position: "bottom",
	offset: 8,
	positionDependencies: [],
	transitionProps: {
		transition: "fade",
		duration: 150
	},
	middlewares: {
		flip: true,
		shift: true,
		inline: false
	},
	arrowSize: 7,
	arrowOffset: 5,
	arrowRadius: 0,
	arrowPosition: "side",
	closeOnClickOutside: true,
	withinPortal: true,
	closeOnEscape: true,
	trapFocus: false,
	withRoles: true,
	returnFocus: false,
	withOverlay: false,
	hideDetached: true,
	clickOutsideEvents: ["mousedown", "touchstart"],
	zIndex: getDefaultZIndex("popover"),
	__staticSelector: "Popover",
	width: "max-content"
};
var varsResolver$14 = createVarsResolver((_, { radius, shadow }) => ({ dropdown: {
	"--popover-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--popover-shadow": getShadow(shadow)
} }));
function Popover(_props) {
	const props = useProps("Popover", defaultProps$16, _props);
	const { children, position, offset: offset$3, onPositionChange, positionDependencies, opened, transitionProps, onExitTransitionEnd, onEnterTransitionEnd, width, middlewares, withArrow, arrowSize, arrowOffset, arrowRadius, arrowPosition, unstyled, classNames, styles, closeOnClickOutside, withinPortal, portalProps, closeOnEscape: closeOnEscape$1, clickOutsideEvents, trapFocus, onClose, onDismiss, onOpen, onChange, zIndex, radius, shadow, id, defaultOpened, __staticSelector, withRoles, disabled, returnFocus, variant, keepMounted, vars, floatingStrategy, withOverlay, overlayProps, hideDetached, attributes, preventPositionChangeWhenVisible, ...others } = props;
	const getStyles = useStyles({
		name: __staticSelector,
		props,
		classes: classes$9,
		classNames,
		styles,
		unstyled,
		attributes,
		rootSelector: "dropdown",
		vars,
		varsResolver: varsResolver$14
	});
	const { resolvedStyles } = useResolvedStylesApi({
		classNames,
		styles,
		props
	});
	const [dropdownVisible, setDropdownVisible] = (0, import_react.useState)(opened ?? defaultOpened ?? false);
	const positionRef = (0, import_react.useRef)(position);
	const arrowRef = (0, import_react.useRef)(null);
	const [targetNode, setTargetNode] = (0, import_react.useState)(null);
	const [dropdownNode, setDropdownNode] = (0, import_react.useState)(null);
	const { dir } = useDirection();
	const env = useMantineEnv();
	const uid = useId(id);
	const popover = usePopover({
		middlewares,
		width,
		position: getFloatingPosition(dir, position),
		offset: typeof offset$3 === "number" ? offset$3 + (withArrow ? arrowSize / 2 : 0) : offset$3,
		arrowRef,
		arrowOffset,
		onPositionChange,
		positionDependencies,
		opened,
		defaultOpened,
		onChange,
		onOpen,
		onClose,
		onDismiss,
		strategy: floatingStrategy,
		dropdownVisible,
		setDropdownVisible,
		positionRef,
		disabled,
		preventPositionChangeWhenVisible,
		keepMounted
	});
	useClickOutside(() => {
		if (closeOnClickOutside) {
			popover.onClose();
			onDismiss?.();
		}
	}, clickOutsideEvents, [targetNode, dropdownNode]);
	const reference = (0, import_react.useCallback)((node) => {
		setTargetNode(node);
		popover.floating.refs.setReference(node);
	}, [popover.floating.refs.setReference]);
	const floating = (0, import_react.useCallback)((node) => {
		setDropdownNode(node);
		popover.floating.refs.setFloating(node);
	}, [popover.floating.refs.setFloating]);
	const onExited = (0, import_react.useCallback)(() => {
		transitionProps?.onExited?.();
		onExitTransitionEnd?.();
		setDropdownVisible(false);
		if (!preventPositionChangeWhenVisible) positionRef.current = position;
	}, [
		transitionProps?.onExited,
		onExitTransitionEnd,
		preventPositionChangeWhenVisible,
		position
	]);
	const onEntered = (0, import_react.useCallback)(() => {
		transitionProps?.onEntered?.();
		onEnterTransitionEnd?.();
	}, [transitionProps?.onEntered, onEnterTransitionEnd]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(PopoverContextProvider, {
		value: {
			returnFocus,
			disabled,
			controlled: popover.controlled,
			reference,
			floating,
			x: popover.floating.x,
			y: popover.floating.y,
			arrowX: popover.floating?.middlewareData?.arrow?.x,
			arrowY: popover.floating?.middlewareData?.arrow?.y,
			opened: popover.opened,
			arrowRef,
			transitionProps: {
				...transitionProps,
				onExited,
				onEntered
			},
			width,
			withArrow,
			arrowSize,
			arrowOffset,
			arrowRadius,
			arrowPosition,
			placement: popover.floating.placement,
			trapFocus,
			withinPortal,
			portalProps,
			zIndex,
			radius,
			shadow,
			closeOnEscape: closeOnEscape$1,
			onDismiss,
			onClose: popover.onClose,
			onToggle: popover.onToggle,
			getTargetId: () => `${uid}-target`,
			getDropdownId: () => `${uid}-dropdown`,
			withRoles,
			targetProps: others,
			__staticSelector,
			classNames,
			styles,
			unstyled,
			variant,
			keepMounted,
			getStyles,
			resolvedStyles,
			floatingStrategy,
			referenceHidden: hideDetached && env !== "test" ? popover.floating.middlewareData.hide?.referenceHidden : false
		},
		children: [children, withOverlay && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
			transition: "fade",
			mounted: popover.opened,
			duration: transitionProps?.duration || 250,
			exitDuration: transitionProps?.exitDuration || 250,
			children: (transitionStyles) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OptionalPortal, {
				withinPortal,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Overlay, {
					...overlayProps,
					...getStyles("overlay", {
						className: overlayProps?.className,
						style: [transitionStyles, overlayProps?.style]
					})
				})
			})
		})]
	});
}
Popover.Target = PopoverTarget;
Popover.Dropdown = PopoverDropdown;
Popover.displayName = "@mantine/core/Popover";
Popover.extend = (input) => input;
var classes$8 = {
	"root": "m_5ae2e3c",
	"barsLoader": "m_7a2bd4cd",
	"bar": "m_870bb79",
	"bars-loader-animation": "m_5d2b3b9d",
	"dotsLoader": "m_4e3f22d7",
	"dot": "m_870c4af",
	"loader-dots-animation": "m_aac34a1",
	"ovalLoader": "m_b34414df",
	"oval-loader-animation": "m_f8e89c4b"
};
var Bars = (0, import_react.forwardRef)(({ className, ...others }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
	component: "span",
	className: clsx_default(classes$8.barsLoader, className),
	...others,
	ref,
	children: [
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: classes$8.bar }),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: classes$8.bar }),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: classes$8.bar })
	]
}));
Bars.displayName = "@mantine/core/Bars";
var Dots = (0, import_react.forwardRef)(({ className, ...others }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
	component: "span",
	className: clsx_default(classes$8.dotsLoader, className),
	...others,
	ref,
	children: [
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: classes$8.dot }),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: classes$8.dot }),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: classes$8.dot })
	]
}));
Dots.displayName = "@mantine/core/Dots";
var Oval = (0, import_react.forwardRef)(({ className, ...others }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
	component: "span",
	className: clsx_default(classes$8.ovalLoader, className),
	...others,
	ref
}));
Oval.displayName = "@mantine/core/Oval";
var defaultLoaders = {
	bars: Bars,
	oval: Oval,
	dots: Dots
};
var defaultProps$15 = {
	loaders: defaultLoaders,
	type: "oval"
};
var varsResolver$13 = createVarsResolver((theme$1, { size: size$3, color }) => ({ root: {
	"--loader-size": getSize(size$3, "loader-size"),
	"--loader-color": color ? getThemeColor(color, theme$1) : void 0
} }));
var Loader = factory((_props, ref) => {
	const props = useProps("Loader", defaultProps$15, _props);
	const { size: size$3, color, type, vars, className, style: style$1, classNames, styles, unstyled, loaders, variant, children, attributes, ...others } = props;
	const getStyles = useStyles({
		name: "Loader",
		props,
		classes: classes$8,
		className,
		style: style$1,
		classNames,
		styles,
		unstyled,
		attributes,
		vars,
		varsResolver: varsResolver$13
	});
	if (children) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles("root"),
		ref,
		...others,
		children
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles("root"),
		ref,
		component: loaders[type],
		variant,
		size: size$3,
		...others
	});
});
Loader.defaultLoaders = defaultLoaders;
Loader.classes = classes$8;
Loader.displayName = "@mantine/core/Loader";
var CloseIcon = (0, import_react.forwardRef)(({ size: size$3 = "var(--cb-icon-size, 70%)", style: style$1, ...others }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
	viewBox: "0 0 15 15",
	fill: "none",
	xmlns: "http://www.w3.org/2000/svg",
	style: {
		...style$1,
		width: size$3,
		height: size$3
	},
	ref,
	...others,
	children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
		d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
		fill: "currentColor",
		fillRule: "evenodd",
		clipRule: "evenodd"
	})
}));
CloseIcon.displayName = "@mantine/core/CloseIcon";
var classes$7 = {
	"root": "m_86a44da5",
	"root--subtle": "m_220c80f2"
};
var defaultProps$14 = { variant: "subtle" };
var varsResolver$12 = createVarsResolver((_, { size: size$3, radius, iconSize }) => ({ root: {
	"--cb-size": getSize(size$3, "cb-size"),
	"--cb-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--cb-icon-size": rem(iconSize)
} }));
var CloseButton = polymorphicFactory((_props, ref) => {
	const props = useProps("CloseButton", defaultProps$14, _props);
	const { iconSize, children, vars, radius, className, classNames, style: style$1, styles, unstyled, "data-disabled": dataDisabled, disabled, variant, icon, mod, attributes, __staticSelector, ...others } = props;
	const getStyles = useStyles({
		name: __staticSelector || "CloseButton",
		props,
		className,
		style: style$1,
		classes: classes$7,
		classNames,
		styles,
		unstyled,
		attributes,
		vars,
		varsResolver: varsResolver$12
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(UnstyledButton, {
		ref,
		...others,
		unstyled,
		variant,
		disabled,
		mod: [{ disabled: disabled || dataDisabled }, mod],
		...getStyles("root", {
			variant,
			active: !disabled && !dataDisabled
		}),
		children: [icon || /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CloseIcon, {}), children]
	});
});
CloseButton.classes = classes$7;
CloseButton.displayName = "@mantine/core/CloseButton";
var [InputContext, useInputContext] = createOptionalContext({ size: "sm" });
var InputClearButton = factory((_props, ref) => {
	const props = useProps("InputClearButton", null, _props);
	const { size: size$3, variant, vars, classNames, styles, ...others } = props;
	const ctx = useInputContext();
	const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
		classNames,
		styles,
		props
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CloseButton, {
		variant: variant || "transparent",
		ref,
		size: size$3 || ctx?.size || "sm",
		classNames: resolvedClassNames,
		styles: resolvedStyles,
		__staticSelector: "InputClearButton",
		style: {
			pointerEvents: "all",
			background: "var(--input-bg)",
			...others.style
		},
		...others
	});
});
InputClearButton.displayName = "@mantine/core/InputClearButton";
var clearSectionOffset = {
	xs: 7,
	sm: 8,
	md: 10,
	lg: 12,
	xl: 15
};
function InputClearSection({ __clearable, __clearSection, rightSection, __defaultRightSection, size: size$3 = "sm" }) {
	const clearSection = __clearable && __clearSection;
	if (clearSection && (rightSection || __defaultRightSection)) return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		"data-combined-clear-section": true,
		style: {
			display: "flex",
			gap: 2,
			alignItems: "center",
			paddingInlineEnd: clearSectionOffset[size$3]
		},
		children: [clearSection, rightSection || __defaultRightSection]
	});
	return rightSection === null ? null : rightSection || clearSection || __defaultRightSection;
}
var [InputWrapperProvider, useInputWrapperContext] = createOptionalContext({
	offsetBottom: false,
	offsetTop: false,
	describedBy: void 0,
	getStyles: null,
	inputId: void 0,
	labelId: void 0
});
var classes$6 = {
	"wrapper": "m_6c018570",
	"input": "m_8fb7ebe7",
	"section": "m_82577fc2",
	"placeholder": "m_88bacfd0",
	"root": "m_46b77525",
	"label": "m_8fdc1311",
	"required": "m_78a94662",
	"error": "m_8f816625",
	"description": "m_fe47ce59"
};
var varsResolver$11 = createVarsResolver((_, { size: size$3 }) => ({ description: { "--input-description-size": size$3 === void 0 ? void 0 : `calc(${getFontSize(size$3)} - ${rem(2)})` } }));
var InputDescription = factory((_props, ref) => {
	const props = useProps("InputDescription", null, _props);
	const { classNames, className, style: style$1, styles, unstyled, vars, size: size$3, __staticSelector, __inheritStyles = true, attributes, variant, ...others } = useProps("InputDescription", null, props);
	const ctx = useInputWrapperContext();
	const _getStyles = useStyles({
		name: ["InputWrapper", __staticSelector],
		props,
		classes: classes$6,
		className,
		style: style$1,
		classNames,
		styles,
		unstyled,
		attributes,
		rootSelector: "description",
		vars,
		varsResolver: varsResolver$11
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "p",
		ref,
		variant,
		size: size$3,
		...(__inheritStyles && ctx?.getStyles || _getStyles)("description", ctx?.getStyles ? {
			className,
			style: style$1
		} : void 0),
		...others
	});
});
InputDescription.classes = classes$6;
InputDescription.displayName = "@mantine/core/InputDescription";
var varsResolver$10 = createVarsResolver((_, { size: size$3 }) => ({ error: { "--input-error-size": size$3 === void 0 ? void 0 : `calc(${getFontSize(size$3)} - ${rem(2)})` } }));
var InputError = factory((_props, ref) => {
	const props = useProps("InputError", null, _props);
	const { classNames, className, style: style$1, styles, unstyled, vars, size: size$3, attributes, __staticSelector, __inheritStyles = true, variant, ...others } = props;
	const _getStyles = useStyles({
		name: ["InputWrapper", __staticSelector],
		props,
		classes: classes$6,
		className,
		style: style$1,
		classNames,
		styles,
		unstyled,
		attributes,
		rootSelector: "error",
		vars,
		varsResolver: varsResolver$10
	});
	const ctx = useInputWrapperContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "p",
		ref,
		variant,
		size: size$3,
		...(__inheritStyles && ctx?.getStyles || _getStyles)("error", ctx?.getStyles ? {
			className,
			style: style$1
		} : void 0),
		...others
	});
});
InputError.classes = classes$6;
InputError.displayName = "@mantine/core/InputError";
var defaultProps$13 = { labelElement: "label" };
var varsResolver$9 = createVarsResolver((_, { size: size$3 }) => ({ label: {
	"--input-label-size": getFontSize(size$3),
	"--input-asterisk-color": void 0
} }));
var InputLabel = factory((_props, ref) => {
	const props = useProps("InputLabel", defaultProps$13, _props);
	const { classNames, className, style: style$1, styles, unstyled, vars, labelElement, size: size$3, required, htmlFor, onMouseDown, children, __staticSelector, variant, mod, attributes, ...others } = useProps("InputLabel", defaultProps$13, props);
	const _getStyles = useStyles({
		name: ["InputWrapper", __staticSelector],
		props,
		classes: classes$6,
		className,
		style: style$1,
		classNames,
		styles,
		unstyled,
		attributes,
		rootSelector: "label",
		vars,
		varsResolver: varsResolver$9
	});
	const ctx = useInputWrapperContext();
	const getStyles = ctx?.getStyles || _getStyles;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		...getStyles("label", ctx?.getStyles ? {
			className,
			style: style$1
		} : void 0),
		component: labelElement,
		variant,
		size: size$3,
		ref,
		htmlFor: labelElement === "label" ? htmlFor : void 0,
		mod: [{ required }, mod],
		onMouseDown: (event) => {
			onMouseDown?.(event);
			if (!event.defaultPrevented && event.detail > 1) event.preventDefault();
		},
		...others,
		children: [children, required && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
			...getStyles("required"),
			"aria-hidden": true,
			children: " *"
		})]
	});
});
InputLabel.classes = classes$6;
InputLabel.displayName = "@mantine/core/InputLabel";
var InputPlaceholder = factory((_props, ref) => {
	const props = useProps("InputPlaceholder", null, _props);
	const { classNames, className, style: style$1, styles, unstyled, vars, __staticSelector, variant, error, mod, attributes, ...others } = props;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...useStyles({
			name: ["InputPlaceholder", __staticSelector],
			props,
			classes: classes$6,
			className,
			style: style$1,
			classNames,
			styles,
			unstyled,
			attributes,
			rootSelector: "placeholder"
		})("placeholder"),
		mod: [{ error: !!error }, mod],
		component: "span",
		variant,
		ref,
		...others
	});
});
InputPlaceholder.classes = classes$6;
InputPlaceholder.displayName = "@mantine/core/InputPlaceholder";
function getInputOffsets(inputWrapperOrder, { hasDescription, hasError }) {
	const inputIndex = inputWrapperOrder.findIndex((part) => part === "input");
	const aboveInput = inputWrapperOrder.slice(0, inputIndex);
	const belowInput = inputWrapperOrder.slice(inputIndex + 1);
	const offsetTop = hasDescription && aboveInput.includes("description") || hasError && aboveInput.includes("error");
	return {
		offsetBottom: hasDescription && belowInput.includes("description") || hasError && belowInput.includes("error"),
		offsetTop
	};
}
var defaultProps$12 = {
	labelElement: "label",
	inputContainer: (children) => children,
	inputWrapperOrder: [
		"label",
		"description",
		"input",
		"error"
	]
};
var varsResolver$8 = createVarsResolver((_, { size: size$3 }) => ({
	label: {
		"--input-label-size": getFontSize(size$3),
		"--input-asterisk-color": void 0
	},
	error: { "--input-error-size": size$3 === void 0 ? void 0 : `calc(${getFontSize(size$3)} - ${rem(2)})` },
	description: { "--input-description-size": size$3 === void 0 ? void 0 : `calc(${getFontSize(size$3)} - ${rem(2)})` }
}));
var InputWrapper = factory((_props, ref) => {
	const props = useProps("InputWrapper", defaultProps$12, _props);
	const { classNames, className, style: style$1, styles, unstyled, vars, size: size$3, variant, __staticSelector, inputContainer, inputWrapperOrder, label, error, description, labelProps, descriptionProps, errorProps, labelElement, children, withAsterisk, id, required, __stylesApiProps, mod, attributes, ...others } = props;
	const getStyles = useStyles({
		name: ["InputWrapper", __staticSelector],
		props: __stylesApiProps || props,
		classes: classes$6,
		className,
		style: style$1,
		classNames,
		styles,
		unstyled,
		attributes,
		vars,
		varsResolver: varsResolver$8
	});
	const sharedProps = {
		size: size$3,
		variant,
		__staticSelector
	};
	const idBase = useId(id);
	const isRequired = typeof withAsterisk === "boolean" ? withAsterisk : required;
	const errorId = errorProps?.id || `${idBase}-error`;
	const descriptionId = descriptionProps?.id || `${idBase}-description`;
	const inputId = idBase;
	const hasError = !!error && typeof error !== "boolean";
	const hasDescription = !!description;
	const _describedBy = `${hasError ? errorId : ""} ${hasDescription ? descriptionId : ""}`;
	const describedBy = _describedBy.trim().length > 0 ? _describedBy.trim() : void 0;
	const labelId = labelProps?.id || `${idBase}-label`;
	const _label = label && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputLabel, {
		labelElement,
		id: labelId,
		htmlFor: inputId,
		required: isRequired,
		...sharedProps,
		...labelProps,
		children: label
	}, "label");
	const _description = hasDescription && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputDescription, {
		...descriptionProps,
		...sharedProps,
		size: descriptionProps?.size || sharedProps.size,
		id: descriptionProps?.id || descriptionId,
		children: description
	}, "description");
	const _input = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: inputContainer(children) }, "input");
	const _error = hasError && /* @__PURE__ */ (0, import_react.createElement)(InputError, {
		...errorProps,
		...sharedProps,
		size: errorProps?.size || sharedProps.size,
		key: "error",
		id: errorProps?.id || errorId
	}, error);
	const content = inputWrapperOrder.map((part) => {
		switch (part) {
			case "label": return _label;
			case "input": return _input;
			case "description": return _description;
			case "error": return _error;
			default: return null;
		}
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputWrapperProvider, {
		value: {
			getStyles,
			describedBy,
			inputId,
			labelId,
			...getInputOffsets(inputWrapperOrder, {
				hasDescription,
				hasError
			})
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
			ref,
			variant,
			size: size$3,
			mod: [{ error: !!error }, mod],
			...getStyles("root"),
			...others,
			children: content
		})
	});
});
InputWrapper.classes = classes$6;
InputWrapper.displayName = "@mantine/core/InputWrapper";
var defaultProps$11 = {
	variant: "default",
	leftSectionPointerEvents: "none",
	rightSectionPointerEvents: "none",
	withAria: true,
	withErrorStyles: true,
	size: "sm"
};
var varsResolver$7 = createVarsResolver((_, props, ctx) => ({ wrapper: {
	"--input-margin-top": ctx.offsetTop ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
	"--input-margin-bottom": ctx.offsetBottom ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
	"--input-height": getSize(props.size, "input-height"),
	"--input-fz": getFontSize(props.size),
	"--input-radius": props.radius === void 0 ? void 0 : getRadius(props.radius),
	"--input-left-section-width": props.leftSectionWidth !== void 0 ? rem(props.leftSectionWidth) : void 0,
	"--input-right-section-width": props.rightSectionWidth !== void 0 ? rem(props.rightSectionWidth) : void 0,
	"--input-padding-y": props.multiline ? getSize(props.size, "input-padding-y") : void 0,
	"--input-left-section-pointer-events": props.leftSectionPointerEvents,
	"--input-right-section-pointer-events": props.rightSectionPointerEvents
} }));
var Input = polymorphicFactory((_props, ref) => {
	const props = useProps("Input", defaultProps$11, _props);
	const { classNames, className, style: style$1, styles, unstyled, required, __staticSelector, __stylesApiProps, size: size$3, wrapperProps, error, disabled, leftSection, leftSectionProps, leftSectionWidth, rightSection, rightSectionProps, rightSectionWidth, rightSectionPointerEvents, leftSectionPointerEvents, variant, vars, pointer, multiline, radius, id, withAria, withErrorStyles, mod, inputSize, attributes, __clearSection, __clearable, __defaultRightSection, ...others } = props;
	const { styleProps, rest } = extractStyleProps(others);
	const ctx = useInputWrapperContext();
	const stylesCtx = {
		offsetBottom: ctx?.offsetBottom,
		offsetTop: ctx?.offsetTop
	};
	const getStyles = useStyles({
		name: ["Input", __staticSelector],
		props: __stylesApiProps || props,
		classes: classes$6,
		className,
		style: style$1,
		classNames,
		styles,
		unstyled,
		attributes,
		stylesCtx,
		rootSelector: "wrapper",
		vars,
		varsResolver: varsResolver$7
	});
	const ariaAttributes = withAria ? {
		required,
		disabled,
		"aria-invalid": !!error,
		"aria-describedby": ctx?.describedBy,
		id: ctx?.inputId || id
	} : {};
	const _rightSection = InputClearSection({
		__clearable,
		__clearSection,
		rightSection,
		__defaultRightSection,
		size: size$3
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputContext, {
		value: { size: size$3 || "sm" },
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
			...getStyles("wrapper"),
			...styleProps,
			...wrapperProps,
			mod: [{
				error: !!error && withErrorStyles,
				pointer,
				disabled,
				multiline,
				"data-with-right-section": !!_rightSection,
				"data-with-left-section": !!leftSection
			}, mod],
			variant,
			size: size$3,
			children: [
				leftSection && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					...leftSectionProps,
					"data-position": "left",
					...getStyles("section", {
						className: leftSectionProps?.className,
						style: leftSectionProps?.style
					}),
					children: leftSection
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
					component: "input",
					...rest,
					...ariaAttributes,
					ref,
					required,
					mod: {
						disabled,
						error: !!error && withErrorStyles
					},
					variant,
					__size: inputSize,
					...getStyles("input")
				}),
				_rightSection && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					...rightSectionProps,
					"data-position": "right",
					...getStyles("section", {
						className: rightSectionProps?.className,
						style: rightSectionProps?.style
					}),
					children: _rightSection
				})
			]
		})
	});
});
Input.classes = classes$6;
Input.Wrapper = InputWrapper;
Input.Label = InputLabel;
Input.Error = InputError;
Input.Description = InputDescription;
Input.Placeholder = InputPlaceholder;
Input.ClearButton = InputClearButton;
Input.displayName = "@mantine/core/Input";
function useInputProps(component, defaultProps$23, _props) {
	const props = useProps(component, defaultProps$23, _props);
	const { label, description, error, required, classNames, styles, className, unstyled, __staticSelector, __stylesApiProps, errorProps, labelProps, descriptionProps, wrapperProps: _wrapperProps, id, size: size$3, style: style$1, inputContainer, inputWrapperOrder, withAsterisk, variant, vars, mod, attributes, ...others } = props;
	const { styleProps, rest } = extractStyleProps(others);
	const wrapperProps = {
		label,
		description,
		error,
		required,
		classNames,
		className,
		__staticSelector,
		__stylesApiProps: __stylesApiProps || props,
		errorProps,
		labelProps,
		descriptionProps,
		unstyled,
		styles,
		size: size$3,
		style: style$1,
		inputContainer,
		inputWrapperOrder,
		withAsterisk,
		variant,
		id,
		mod,
		attributes,
		..._wrapperProps
	};
	return {
		...rest,
		classNames,
		styles,
		unstyled,
		wrapperProps: {
			...wrapperProps,
			...styleProps
		},
		inputProps: {
			required,
			classNames,
			styles,
			unstyled,
			size: size$3,
			__staticSelector,
			__stylesApiProps: __stylesApiProps || props,
			error,
			variant,
			id,
			attributes
		}
	};
}
var defaultProps$10 = {
	__staticSelector: "InputBase",
	withAria: true,
	size: "sm"
};
var InputBase = polymorphicFactory((props, ref) => {
	const { inputProps, wrapperProps, ...others } = useInputProps("InputBase", defaultProps$10, props);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input.Wrapper, {
		...wrapperProps,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input, {
			...inputProps,
			...others,
			ref
		})
	});
});
InputBase.classes = {
	...Input.classes,
	...Input.Wrapper.classes
};
InputBase.displayName = "@mantine/core/InputBase";
var FLEX_STYLE_PROPS_DATA = {
	gap: {
		type: "spacing",
		property: "gap"
	},
	rowGap: {
		type: "spacing",
		property: "rowGap"
	},
	columnGap: {
		type: "spacing",
		property: "columnGap"
	},
	align: {
		type: "identity",
		property: "alignItems"
	},
	justify: {
		type: "identity",
		property: "justifyContent"
	},
	wrap: {
		type: "identity",
		property: "flexWrap"
	},
	direction: {
		type: "identity",
		property: "flexDirection"
	}
};
var classes$5 = { "root": "m_8bffd616" };
var Flex = polymorphicFactory((_props, ref) => {
	const props = useProps("Flex", null, _props);
	const { classNames, className, style: style$1, styles, unstyled, vars, gap, rowGap, columnGap, align, justify, wrap, direction, attributes, ...others } = props;
	const getStyles = useStyles({
		name: "Flex",
		classes: classes$5,
		props,
		className,
		style: style$1,
		classNames,
		styles,
		unstyled,
		attributes,
		vars
	});
	const theme$1 = useMantineTheme();
	const responsiveClassName = useRandomClassName();
	const parsedStyleProps = parseStyleProps({
		styleProps: {
			gap,
			rowGap,
			columnGap,
			align,
			justify,
			wrap,
			direction
		},
		theme: theme$1,
		data: FLEX_STYLE_PROPS_DATA
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [parsedStyleProps.hasResponsiveStyles && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InlineStyles, {
		selector: `.${responsiveClassName}`,
		styles: parsedStyleProps.styles,
		media: parsedStyleProps.media
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...getStyles("root", {
			className: responsiveClassName,
			style: filterProps(parsedStyleProps.inlineStyles)
		}),
		...others
	})] });
});
Flex.classes = classes$5;
Flex.displayName = "@mantine/core/Flex";
function parseItem(item) {
	if (typeof item === "string") return {
		value: item,
		label: item
	};
	if ("value" in item && !("label" in item)) return {
		value: item.value,
		label: item.value,
		disabled: item.disabled
	};
	if (typeof item === "number") return {
		value: item.toString(),
		label: item.toString()
	};
	if ("group" in item) return {
		group: item.group,
		items: item.items.map((i) => parseItem(i))
	};
	return item;
}
function getParsedComboboxData(data) {
	if (!data) return [];
	return data.map((item) => parseItem(item));
}
function getOptionsLockup(options$1) {
	return options$1.reduce((acc, item) => {
		if ("group" in item) return {
			...acc,
			...getOptionsLockup(item.items)
		};
		acc[item.value] = item;
		return acc;
	}, {});
}
var classes$3 = {
	"dropdown": "m_88b62a41",
	"search": "m_985517d8",
	"options": "m_b2821a6e",
	"option": "m_92253aa5",
	"empty": "m_2530cd1d",
	"header": "m_858f94bd",
	"footer": "m_82b967cb",
	"group": "m_254f3e4f",
	"groupLabel": "m_2bb2e9e5",
	"chevron": "m_2943220b",
	"optionsDropdownOption": "m_390b5f4",
	"optionsDropdownCheckIcon": "m_8ee53fc2",
	"optionsDropdownCheckPlaceholder": "m_a530ee0a"
};
var defaultProps$9 = { error: null };
var varsResolver$6 = createVarsResolver((theme$1, { size: size$3, color }) => ({ chevron: {
	"--combobox-chevron-size": getSize(size$3, "combobox-chevron-size"),
	"--combobox-chevron-color": color ? getThemeColor(color, theme$1) : void 0
} }));
var ComboboxChevron = factory((_props, ref) => {
	const props = useProps("ComboboxChevron", defaultProps$9, _props);
	const { size: size$3, error, style: style$1, className, classNames, styles, unstyled, vars, mod, ...others } = props;
	const getStyles = useStyles({
		name: "ComboboxChevron",
		classes: classes$3,
		props,
		style: style$1,
		className,
		classNames,
		styles,
		unstyled,
		vars,
		varsResolver: varsResolver$6,
		rootSelector: "chevron"
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		component: "svg",
		...others,
		...getStyles("chevron"),
		size: size$3,
		viewBox: "0 0 15 15",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		mod: [
			"combobox-chevron",
			{ error },
			mod
		],
		ref,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
			d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z",
			fill: "currentColor",
			fillRule: "evenodd",
			clipRule: "evenodd"
		})
	});
});
ComboboxChevron.classes = classes$3;
ComboboxChevron.displayName = "@mantine/core/ComboboxChevron";
var [ComboboxProvider, useComboboxContext] = createSafeContext("Combobox component was not found in tree");
var ComboboxClearButton = (0, import_react.forwardRef)(({ size: size$3, onMouseDown, onClick, onClear, ...others }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input.ClearButton, {
	ref,
	tabIndex: -1,
	"aria-hidden": true,
	...others,
	onMouseDown: (event) => {
		event.preventDefault();
		onMouseDown?.(event);
	},
	onClick: (event) => {
		onClear();
		onClick?.(event);
	}
}));
ComboboxClearButton.displayName = "@mantine/core/ComboboxClearButton";
var ComboboxDropdown = factory((props, ref) => {
	const { classNames, styles, className, style: style$1, hidden: hidden$1, ...others } = useProps("ComboboxDropdown", null, props);
	const ctx = useComboboxContext();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover.Dropdown, {
		...others,
		ref,
		role: "presentation",
		"data-hidden": hidden$1 || void 0,
		...ctx.getStyles("dropdown", {
			className,
			style: style$1,
			classNames,
			styles
		})
	});
});
ComboboxDropdown.classes = classes$3;
ComboboxDropdown.displayName = "@mantine/core/ComboboxDropdown";
var defaultProps$8 = { refProp: "ref" };
var ComboboxDropdownTarget = factory((props, ref) => {
	const { children, refProp } = useProps("ComboboxDropdownTarget", defaultProps$8, props);
	useComboboxContext();
	if (!isElement(children)) throw new Error("Combobox.DropdownTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover.Target, {
		ref,
		refProp,
		children
	});
});
ComboboxDropdownTarget.displayName = "@mantine/core/ComboboxDropdownTarget";
var ComboboxEmpty = factory((props, ref) => {
	const { classNames, className, style: style$1, styles, vars, ...others } = useProps("ComboboxEmpty", null, props);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...useComboboxContext().getStyles("empty", {
			className,
			classNames,
			styles,
			style: style$1
		}),
		...others
	});
});
ComboboxEmpty.classes = classes$3;
ComboboxEmpty.displayName = "@mantine/core/ComboboxEmpty";
function useComboboxTargetProps({ onKeyDown, withKeyboardNavigation, withAriaAttributes, withExpandedAttribute, targetType, autoComplete }) {
	const ctx = useComboboxContext();
	const [selectedOptionId, setSelectedOptionId] = (0, import_react.useState)(null);
	const handleKeyDown = (event) => {
		onKeyDown?.(event);
		if (ctx.readOnly) return;
		if (withKeyboardNavigation) {
			if (event.nativeEvent.isComposing) return;
			if (event.nativeEvent.code === "ArrowDown") {
				event.preventDefault();
				if (!ctx.store.dropdownOpened) {
					ctx.store.openDropdown("keyboard");
					setSelectedOptionId(ctx.store.selectActiveOption());
					ctx.store.updateSelectedOptionIndex("selected", { scrollIntoView: true });
				} else setSelectedOptionId(ctx.store.selectNextOption());
			}
			if (event.nativeEvent.code === "ArrowUp") {
				event.preventDefault();
				if (!ctx.store.dropdownOpened) {
					ctx.store.openDropdown("keyboard");
					setSelectedOptionId(ctx.store.selectActiveOption());
					ctx.store.updateSelectedOptionIndex("selected", { scrollIntoView: true });
				} else setSelectedOptionId(ctx.store.selectPreviousOption());
			}
			if (event.nativeEvent.code === "Enter" || event.nativeEvent.code === "NumpadEnter") {
				if (event.nativeEvent.keyCode === 229) return;
				const selectedOptionIndex = ctx.store.getSelectedOptionIndex();
				if (ctx.store.dropdownOpened && selectedOptionIndex !== -1) {
					event.preventDefault();
					ctx.store.clickSelectedOption();
				} else if (targetType === "button") {
					event.preventDefault();
					ctx.store.openDropdown("keyboard");
				}
			}
			if (event.key === "Escape") ctx.store.closeDropdown("keyboard");
			if (event.nativeEvent.code === "Space") {
				if (targetType === "button") {
					event.preventDefault();
					ctx.store.toggleDropdown("keyboard");
				}
			}
		}
	};
	return {
		...withAriaAttributes ? {
			"aria-haspopup": "listbox",
			"aria-expanded": withExpandedAttribute ? !!(ctx.store.listId && ctx.store.dropdownOpened) : void 0,
			"aria-controls": ctx.store.dropdownOpened && ctx.store.listId ? ctx.store.listId : void 0,
			"aria-activedescendant": ctx.store.dropdownOpened ? selectedOptionId || void 0 : void 0,
			autoComplete,
			"data-expanded": ctx.store.dropdownOpened || void 0,
			"data-mantine-stop-propagation": ctx.store.dropdownOpened || void 0
		} : {},
		onKeyDown: handleKeyDown
	};
}
var defaultProps$7 = {
	refProp: "ref",
	targetType: "input",
	withKeyboardNavigation: true,
	withAriaAttributes: true,
	withExpandedAttribute: false,
	autoComplete: "off"
};
var ComboboxEventsTarget = factory((props, ref) => {
	const { children, refProp, withKeyboardNavigation, withAriaAttributes, withExpandedAttribute, targetType, autoComplete, ...others } = useProps("ComboboxEventsTarget", defaultProps$7, props);
	const child = getSingleElementChild(children);
	if (!child) throw new Error("Combobox.EventsTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
	const ctx = useComboboxContext();
	return (0, import_react.cloneElement)(child, {
		...useComboboxTargetProps({
			targetType,
			withAriaAttributes,
			withKeyboardNavigation,
			withExpandedAttribute,
			onKeyDown: child.props.onKeyDown,
			autoComplete
		}),
		...others,
		[refProp]: useMergedRef(ref, ctx.store.targetRef, getRefProp(child))
	});
});
ComboboxEventsTarget.displayName = "@mantine/core/ComboboxEventsTarget";
var ComboboxFooter = factory((props, ref) => {
	const { classNames, className, style: style$1, styles, vars, ...others } = useProps("ComboboxFooter", null, props);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...useComboboxContext().getStyles("footer", {
			className,
			classNames,
			style: style$1,
			styles
		}),
		...others,
		onMouseDown: (event) => {
			event.preventDefault();
		}
	});
});
ComboboxFooter.classes = classes$3;
ComboboxFooter.displayName = "@mantine/core/ComboboxFooter";
var ComboboxGroup = factory((props, ref) => {
	const { classNames, className, style: style$1, styles, vars, children, label, id, ...others } = useProps("ComboboxGroup", null, props);
	const ctx = useComboboxContext();
	const _id = useId(id);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
		ref,
		role: "group",
		"aria-labelledby": label ? _id : void 0,
		...ctx.getStyles("group", {
			className,
			classNames,
			style: style$1,
			styles
		}),
		...others,
		children: [label && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			id: _id,
			...ctx.getStyles("groupLabel", {
				classNames,
				styles
			}),
			children: label
		}), children]
	});
});
ComboboxGroup.classes = classes$3;
ComboboxGroup.displayName = "@mantine/core/ComboboxGroup";
var ComboboxHeader = factory((props, ref) => {
	const { classNames, className, style: style$1, styles, vars, ...others } = useProps("ComboboxHeader", null, props);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...useComboboxContext().getStyles("header", {
			className,
			classNames,
			style: style$1,
			styles
		}),
		...others,
		onMouseDown: (event) => {
			event.preventDefault();
		}
	});
});
ComboboxHeader.classes = classes$3;
ComboboxHeader.displayName = "@mantine/core/ComboboxHeader";
function ComboboxHiddenInput({ value, valuesDivider = ",", ...others }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
		type: "hidden",
		value: Array.isArray(value) ? value.join(valuesDivider) : value || "",
		...others
	});
}
ComboboxHiddenInput.displayName = "@mantine/core/ComboboxHiddenInput";
var ComboboxOption = factory((_props, ref) => {
	const props = useProps("ComboboxOption", null, _props);
	const { classNames, className, style: style$1, styles, vars, onClick, id, active, onMouseDown, onMouseOver, disabled, selected, mod, ...others } = props;
	const ctx = useComboboxContext();
	const uuid = (0, import_react.useId)();
	const _id = id || uuid;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...ctx.getStyles("option", {
			className,
			classNames,
			styles,
			style: style$1
		}),
		...others,
		ref,
		id: _id,
		mod: [
			"combobox-option",
			{
				"combobox-active": active,
				"combobox-disabled": disabled,
				"combobox-selected": selected
			},
			mod
		],
		role: "option",
		onClick: (event) => {
			if (!disabled) {
				ctx.onOptionSubmit?.(props.value, props);
				onClick?.(event);
			} else event.preventDefault();
		},
		onMouseDown: (event) => {
			event.preventDefault();
			onMouseDown?.(event);
		},
		onMouseOver: (event) => {
			if (ctx.resetSelectionOnOptionHover) ctx.store.resetSelectedOption();
			onMouseOver?.(event);
		}
	});
});
ComboboxOption.classes = classes$3;
ComboboxOption.displayName = "@mantine/core/ComboboxOption";
var ComboboxOptions = factory((_props, ref) => {
	const { classNames, className, style: style$1, styles, id, onMouseDown, labelledBy, ...others } = useProps("ComboboxOptions", null, _props);
	const ctx = useComboboxContext();
	const _id = useId(id);
	(0, import_react.useEffect)(() => {
		ctx.store.setListId(_id);
	}, [_id]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		ref,
		...ctx.getStyles("options", {
			className,
			style: style$1,
			classNames,
			styles
		}),
		...others,
		id: _id,
		role: "listbox",
		"aria-labelledby": labelledBy,
		onMouseDown: (event) => {
			event.preventDefault();
			onMouseDown?.(event);
		}
	});
});
ComboboxOptions.classes = classes$3;
ComboboxOptions.displayName = "@mantine/core/ComboboxOptions";
var defaultProps$6 = {
	withAriaAttributes: true,
	withKeyboardNavigation: true
};
var ComboboxSearch = factory((_props, ref) => {
	const { classNames, styles, unstyled, vars, withAriaAttributes, onKeyDown, withKeyboardNavigation, size: size$3, ...others } = useProps("ComboboxSearch", defaultProps$6, _props);
	const ctx = useComboboxContext();
	const _styles = ctx.getStyles("search");
	const targetProps = useComboboxTargetProps({
		targetType: "input",
		withAriaAttributes,
		withKeyboardNavigation,
		withExpandedAttribute: false,
		onKeyDown,
		autoComplete: "off"
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input, {
		ref: useMergedRef(ref, ctx.store.searchRef),
		classNames: [{ input: _styles.className }, classNames],
		styles: [{ input: _styles.style }, styles],
		size: size$3 || ctx.size,
		...targetProps,
		...others,
		__staticSelector: "Combobox"
	});
});
ComboboxSearch.classes = classes$3;
ComboboxSearch.displayName = "@mantine/core/ComboboxSearch";
var defaultProps$5 = {
	refProp: "ref",
	targetType: "input",
	withKeyboardNavigation: true,
	withAriaAttributes: true,
	withExpandedAttribute: false,
	autoComplete: "off"
};
var ComboboxTarget = factory((props, ref) => {
	const { children, refProp, withKeyboardNavigation, withAriaAttributes, withExpandedAttribute, targetType, autoComplete, ...others } = useProps("ComboboxTarget", defaultProps$5, props);
	const child = getSingleElementChild(children);
	if (!child) throw new Error("Combobox.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported");
	const ctx = useComboboxContext();
	const clonedElement = (0, import_react.cloneElement)(child, {
		...useComboboxTargetProps({
			targetType,
			withAriaAttributes,
			withKeyboardNavigation,
			withExpandedAttribute,
			onKeyDown: child.props.onKeyDown,
			autoComplete
		}),
		...others
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover.Target, {
		ref: useMergedRef(ref, ctx.store.targetRef),
		children: clonedElement
	});
});
ComboboxTarget.displayName = "@mantine/core/ComboboxTarget";
function getPreviousIndex(currentIndex, elements, loop) {
	for (let i = currentIndex - 1; i >= 0; i -= 1) if (!elements[i].hasAttribute("data-combobox-disabled")) return i;
	if (loop) {
		for (let i = elements.length - 1; i > -1; i -= 1) if (!elements[i].hasAttribute("data-combobox-disabled")) return i;
	}
	return currentIndex;
}
function getNextIndex(currentIndex, elements, loop) {
	for (let i = currentIndex + 1; i < elements.length; i += 1) if (!elements[i].hasAttribute("data-combobox-disabled")) return i;
	if (loop) {
		for (let i = 0; i < elements.length; i += 1) if (!elements[i].hasAttribute("data-combobox-disabled")) return i;
	}
	return currentIndex;
}
function getFirstIndex(elements) {
	for (let i = 0; i < elements.length; i += 1) if (!elements[i].hasAttribute("data-combobox-disabled")) return i;
	return -1;
}
function useCombobox({ defaultOpened, opened, onOpenedChange, onDropdownClose, onDropdownOpen, loop = true, scrollBehavior = "instant" } = {}) {
	const [dropdownOpened, setDropdownOpened] = useUncontrolled({
		value: opened,
		defaultValue: defaultOpened,
		finalValue: false,
		onChange: onOpenedChange
	});
	const listId = (0, import_react.useRef)(null);
	const selectedOptionIndex = (0, import_react.useRef)(-1);
	const searchRef = (0, import_react.useRef)(null);
	const targetRef = (0, import_react.useRef)(null);
	const focusSearchTimeout = (0, import_react.useRef)(-1);
	const focusTargetTimeout = (0, import_react.useRef)(-1);
	const selectedIndexUpdateTimeout = (0, import_react.useRef)(-1);
	const openDropdown = (0, import_react.useCallback)((eventSource = "unknown") => {
		if (!dropdownOpened) {
			setDropdownOpened(true);
			onDropdownOpen?.(eventSource);
		}
	}, [
		setDropdownOpened,
		onDropdownOpen,
		dropdownOpened
	]);
	const closeDropdown = (0, import_react.useCallback)((eventSource = "unknown") => {
		if (dropdownOpened) {
			setDropdownOpened(false);
			onDropdownClose?.(eventSource);
		}
	}, [
		setDropdownOpened,
		onDropdownClose,
		dropdownOpened
	]);
	const toggleDropdown = (0, import_react.useCallback)((eventSource = "unknown") => {
		if (dropdownOpened) closeDropdown(eventSource);
		else openDropdown(eventSource);
	}, [
		closeDropdown,
		openDropdown,
		dropdownOpened
	]);
	const clearSelectedItem = (0, import_react.useCallback)(() => {
		const root$1 = getRootElement(targetRef.current);
		const selected = findElementBySelector(`#${listId.current} [data-combobox-selected]`, root$1);
		selected?.removeAttribute("data-combobox-selected");
		selected?.removeAttribute("aria-selected");
	}, []);
	const selectOption = (0, import_react.useCallback)((index$3) => {
		const root$1 = getRootElement(targetRef.current);
		const list = findElementBySelector(`#${listId.current}`, root$1);
		const items = list ? findElementsBySelector("[data-combobox-option]", list) : null;
		if (!items) return null;
		const nextIndex = index$3 >= items.length ? 0 : index$3 < 0 ? items.length - 1 : index$3;
		selectedOptionIndex.current = nextIndex;
		if (items?.[nextIndex] && !items[nextIndex].hasAttribute("data-combobox-disabled")) {
			clearSelectedItem();
			items[nextIndex].setAttribute("data-combobox-selected", "true");
			items[nextIndex].setAttribute("aria-selected", "true");
			items[nextIndex].scrollIntoView({
				block: "nearest",
				behavior: scrollBehavior
			});
			return items[nextIndex].id;
		}
		return null;
	}, [scrollBehavior, clearSelectedItem]);
	const selectActiveOption = (0, import_react.useCallback)(() => {
		const root$1 = getRootElement(targetRef.current);
		const activeOption = findElementBySelector(`#${listId.current} [data-combobox-active]`, root$1);
		if (activeOption) return selectOption(findElementsBySelector(`#${listId.current} [data-combobox-option]`, root$1).findIndex((option) => option === activeOption));
		return selectOption(0);
	}, [selectOption]);
	const selectNextOption = (0, import_react.useCallback)(() => {
		const root$1 = getRootElement(targetRef.current);
		const items = findElementsBySelector(`#${listId.current} [data-combobox-option]`, root$1);
		return selectOption(getNextIndex(selectedOptionIndex.current, items, loop));
	}, [selectOption, loop]);
	const selectPreviousOption = (0, import_react.useCallback)(() => {
		const root$1 = getRootElement(targetRef.current);
		const items = findElementsBySelector(`#${listId.current} [data-combobox-option]`, root$1);
		return selectOption(getPreviousIndex(selectedOptionIndex.current, items, loop));
	}, [selectOption, loop]);
	const selectFirstOption = (0, import_react.useCallback)(() => {
		const root$1 = getRootElement(targetRef.current);
		return selectOption(getFirstIndex(findElementsBySelector(`#${listId.current} [data-combobox-option]`, root$1)));
	}, [selectOption]);
	const updateSelectedOptionIndex = (0, import_react.useCallback)((target = "selected", options$1) => {
		selectedIndexUpdateTimeout.current = window.setTimeout(() => {
			const root$1 = getRootElement(targetRef.current);
			const items = findElementsBySelector(`#${listId.current} [data-combobox-option]`, root$1);
			const index$3 = items.findIndex((option) => option.hasAttribute(`data-combobox-${target}`));
			selectedOptionIndex.current = index$3;
			if (options$1?.scrollIntoView) items[index$3]?.scrollIntoView({
				block: "nearest",
				behavior: scrollBehavior
			});
		}, 0);
	}, []);
	const resetSelectedOption = (0, import_react.useCallback)(() => {
		selectedOptionIndex.current = -1;
		clearSelectedItem();
	}, [clearSelectedItem]);
	const clickSelectedOption = (0, import_react.useCallback)(() => {
		const root$1 = getRootElement(targetRef.current);
		(findElementsBySelector(`#${listId.current} [data-combobox-option]`, root$1)?.[selectedOptionIndex.current])?.click();
	}, []);
	const setListId = (0, import_react.useCallback)((id) => {
		listId.current = id;
	}, []);
	const focusSearchInput = (0, import_react.useCallback)(() => {
		focusSearchTimeout.current = window.setTimeout(() => searchRef.current?.focus(), 0);
	}, []);
	const focusTarget = (0, import_react.useCallback)(() => {
		focusTargetTimeout.current = window.setTimeout(() => targetRef.current?.focus(), 0);
	}, []);
	const getSelectedOptionIndex = (0, import_react.useCallback)(() => selectedOptionIndex.current, []);
	(0, import_react.useEffect)(() => () => {
		window.clearTimeout(focusSearchTimeout.current);
		window.clearTimeout(focusTargetTimeout.current);
		window.clearTimeout(selectedIndexUpdateTimeout.current);
	}, []);
	return {
		dropdownOpened,
		openDropdown,
		closeDropdown,
		toggleDropdown,
		selectedOptionIndex: selectedOptionIndex.current,
		getSelectedOptionIndex,
		selectOption,
		selectFirstOption,
		selectActiveOption,
		selectNextOption,
		selectPreviousOption,
		resetSelectedOption,
		updateSelectedOptionIndex,
		listId: listId.current,
		setListId,
		clickSelectedOption,
		searchRef,
		focusSearchInput,
		targetRef,
		focusTarget
	};
}
var defaultProps$4 = {
	keepMounted: true,
	withinPortal: true,
	resetSelectionOnOptionHover: false,
	width: "target",
	transitionProps: {
		transition: "fade",
		duration: 0
	},
	size: "sm"
};
var varsResolver$5 = createVarsResolver((_, { size: size$3, dropdownPadding }) => ({
	options: {
		"--combobox-option-fz": getFontSize(size$3),
		"--combobox-option-padding": getSize(size$3, "combobox-option-padding")
	},
	dropdown: {
		"--combobox-padding": dropdownPadding === void 0 ? void 0 : rem(dropdownPadding),
		"--combobox-option-fz": getFontSize(size$3),
		"--combobox-option-padding": getSize(size$3, "combobox-option-padding")
	}
}));
function Combobox(_props) {
	const props = useProps("Combobox", defaultProps$4, _props);
	const { classNames, styles, unstyled, children, store: controlledStore, vars, onOptionSubmit, onClose, size: size$3, dropdownPadding, resetSelectionOnOptionHover, __staticSelector, readOnly, attributes, ...others } = props;
	const uncontrolledStore = useCombobox();
	const store = controlledStore || uncontrolledStore;
	const getStyles = useStyles({
		name: __staticSelector || "Combobox",
		classes: classes$3,
		props,
		classNames,
		styles,
		unstyled,
		attributes,
		vars,
		varsResolver: varsResolver$5
	});
	const onDropdownClose = () => {
		onClose?.();
		store.closeDropdown();
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ComboboxProvider, {
		value: {
			getStyles,
			store,
			onOptionSubmit,
			size: size$3,
			resetSelectionOnOptionHover,
			readOnly
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Popover, {
			opened: store.dropdownOpened,
			preventPositionChangeWhenVisible: true,
			...others,
			onChange: (_opened) => !_opened && onDropdownClose(),
			withRoles: false,
			unstyled,
			children
		})
	});
}
var extendCombobox = (c) => c;
Combobox.extend = extendCombobox;
Combobox.classes = classes$3;
Combobox.displayName = "@mantine/core/Combobox";
Combobox.Target = ComboboxTarget;
Combobox.Dropdown = ComboboxDropdown;
Combobox.Options = ComboboxOptions;
Combobox.Option = ComboboxOption;
Combobox.Search = ComboboxSearch;
Combobox.Empty = ComboboxEmpty;
Combobox.Chevron = ComboboxChevron;
Combobox.Footer = ComboboxFooter;
Combobox.Header = ComboboxHeader;
Combobox.EventsTarget = ComboboxEventsTarget;
Combobox.DropdownTarget = ComboboxDropdownTarget;
Combobox.Group = ComboboxGroup;
Combobox.ClearButton = ComboboxClearButton;
Combobox.HiddenInput = ComboboxHiddenInput;
var classes$4 = {
	"root": "m_5f75b09e",
	"body": "m_5f6e695e",
	"labelWrapper": "m_d3ea56bb",
	"label": "m_8ee546b8",
	"description": "m_328f68c0",
	"error": "m_8e8a99cc"
};
var InlineInputClasses = classes$4;
var InlineInput = (0, import_react.forwardRef)(({ __staticSelector, __stylesApiProps, className, classNames, styles, unstyled, children, label, description, id, disabled, error, size: size$3, labelPosition = "left", bodyElement = "div", labelElement = "label", variant, style: style$1, vars, mod, attributes, ...others }, ref) => {
	const getStyles = useStyles({
		name: __staticSelector,
		props: __stylesApiProps,
		className,
		style: style$1,
		classes: classes$4,
		classNames,
		styles,
		unstyled,
		attributes
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...getStyles("root"),
		ref,
		__vars: {
			"--label-fz": getFontSize(size$3),
			"--label-lh": getSize(size$3, "label-lh")
		},
		mod: [{ "label-position": labelPosition }, mod],
		variant,
		size: size$3,
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
			component: bodyElement,
			htmlFor: bodyElement === "label" ? id : void 0,
			...getStyles("body"),
			children: [children, /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				...getStyles("labelWrapper"),
				"data-disabled": disabled || void 0,
				children: [
					label && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
						component: labelElement,
						htmlFor: labelElement === "label" ? id : void 0,
						...getStyles("label"),
						"data-disabled": disabled || void 0,
						children: label
					}),
					description && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input.Description, {
						size: size$3,
						__inheritStyles: false,
						...getStyles("description"),
						children: description
					}),
					error && typeof error !== "boolean" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input.Error, {
						size: size$3,
						__inheritStyles: false,
						...getStyles("error"),
						children: error
					})
				]
			})]
		})
	});
});
InlineInput.displayName = "@mantine/core/InlineInput";
function InputsGroupFieldset({ children, role }) {
	const ctx = useInputWrapperContext();
	if (!ctx) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		role,
		"aria-labelledby": ctx.labelId,
		"aria-describedby": ctx.describedBy,
		children
	});
}
function CheckIcon({ size: size$3, style: style$1, ...others }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
		viewBox: "0 0 10 7",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		style: size$3 !== void 0 ? {
			width: rem(size$3),
			height: rem(size$3),
			...style$1
		} : style$1,
		"aria-hidden": true,
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
			d: "M4 4.586L1.707 2.293A1 1 0 1 0 .293 3.707l3 3a.997.997 0 0 0 1.414 0l5-5A1 1 0 1 0 8.293.293L4 4.586z",
			fill: "currentColor",
			fillRule: "evenodd",
			clipRule: "evenodd"
		})
	});
}
function isOptionsGroup(item) {
	return "group" in item;
}
function defaultOptionsFilter({ options: options$1, search, limit }) {
	const parsedSearch = search.trim().toLowerCase();
	const result = [];
	for (let i = 0; i < options$1.length; i += 1) {
		const item = options$1[i];
		if (result.length === limit) return result;
		if (isOptionsGroup(item)) result.push({
			group: item.group,
			items: defaultOptionsFilter({
				options: item.items,
				search,
				limit: limit - result.length
			})
		});
		if (!isOptionsGroup(item)) {
			if (item.label.toLowerCase().includes(parsedSearch)) result.push(item);
		}
	}
	return result;
}
function isEmptyComboboxData(data) {
	if (data.length === 0) return true;
	for (const item of data) {
		if (!("group" in item)) return false;
		if (item.items.length > 0) return false;
	}
	return true;
}
function validateOptions(options$1, valuesSet = /* @__PURE__ */ new Set()) {
	if (!Array.isArray(options$1)) return;
	for (const option of options$1) if (isOptionsGroup(option)) validateOptions(option.items, valuesSet);
	else {
		if (typeof option.value === "undefined") throw new Error("[@mantine/core] Each option must have value property");
		if (typeof option.value !== "string") throw new Error(`[@mantine/core] Option value must be a string, other data formats are not supported, got ${typeof option.value}`);
		if (valuesSet.has(option.value)) throw new Error(`[@mantine/core] Duplicate options are not supported. Option with value "${option.value}" was provided more than once`);
		valuesSet.add(option.value);
	}
}
function isValueChecked(value, optionValue) {
	return Array.isArray(value) ? value.includes(optionValue) : value === optionValue;
}
function Option({ data, withCheckIcon, withAlignedLabels, value, checkIconPosition, unstyled, renderOption }) {
	if (!isOptionsGroup(data)) {
		const checked = isValueChecked(value, data.value);
		const check = withCheckIcon && (checked ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CheckIcon, { className: classes$3.optionsDropdownCheckIcon }) : withAlignedLabels ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: classes$3.optionsDropdownCheckPlaceholder }) : null);
		const defaultContent = /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
			checkIconPosition === "left" && check,
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: data.label }),
			checkIconPosition === "right" && check
		] });
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.Option, {
			value: data.value,
			disabled: data.disabled,
			className: clsx_default({ [classes$3.optionsDropdownOption]: !unstyled }),
			"data-reverse": checkIconPosition === "right" || void 0,
			"data-checked": checked || void 0,
			"aria-selected": checked,
			active: checked,
			children: typeof renderOption === "function" ? renderOption({
				option: data,
				checked
			}) : defaultContent
		});
	}
	const options$1 = data.items.map((item) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Option, {
		data: item,
		value,
		unstyled,
		withCheckIcon,
		withAlignedLabels,
		checkIconPosition,
		renderOption
	}, item.value));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.Group, {
		label: data.group,
		children: options$1
	});
}
function OptionsDropdown({ data, hidden: hidden$1, hiddenWhenEmpty, filter, search, limit, maxDropdownHeight, withScrollArea = true, filterOptions = true, withCheckIcon = false, withAlignedLabels = false, value, checkIconPosition, nothingFoundMessage, unstyled, labelId, renderOption, scrollAreaProps, "aria-label": ariaLabel }) {
	validateOptions(data);
	const filteredData = typeof search === "string" ? (filter || defaultOptionsFilter)({
		options: data,
		search: filterOptions ? search : "",
		limit: limit ?? Infinity
	}) : data;
	const isEmpty$1 = isEmptyComboboxData(filteredData);
	const options$1 = filteredData.map((item) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Option, {
		data: item,
		withCheckIcon,
		withAlignedLabels,
		value,
		checkIconPosition,
		unstyled,
		renderOption
	}, isOptionsGroup(item) ? item.group : item.value));
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.Dropdown, {
		hidden: hidden$1 || hiddenWhenEmpty && isEmpty$1,
		"data-composed": true,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Combobox.Options, {
			labelledBy: labelId,
			"aria-label": ariaLabel,
			children: [withScrollArea ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollArea.Autosize, {
				mah: maxDropdownHeight ?? 220,
				type: "scroll",
				scrollbarSize: "var(--combobox-padding)",
				offsetScrollbars: "y",
				...scrollAreaProps,
				children: options$1
			}) : options$1, isEmpty$1 && nothingFoundMessage && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.Empty, { children: nothingFoundMessage })]
		})
	});
}
var classes$2 = {
	"root": "m_77c9d27d",
	"inner": "m_80f1301b",
	"label": "m_811560b9",
	"section": "m_a74036a",
	"loader": "m_a25b86ee",
	"group": "m_80d6d844",
	"groupSection": "m_70be2a01"
};
var defaultProps$3 = { orientation: "horizontal" };
var varsResolver$4 = createVarsResolver((_, { borderWidth }) => ({ group: { "--button-border-width": rem(borderWidth) } }));
var ButtonGroup = factory((_props, ref) => {
	const props = useProps("ButtonGroup", defaultProps$3, _props);
	const { className, style: style$1, classNames, styles, unstyled, orientation, vars, borderWidth, variant, mod, attributes, ...others } = useProps("ButtonGroup", defaultProps$3, _props);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...useStyles({
			name: "ButtonGroup",
			props,
			classes: classes$2,
			className,
			style: style$1,
			classNames,
			styles,
			unstyled,
			attributes,
			vars,
			varsResolver: varsResolver$4,
			rootSelector: "group"
		})("group"),
		ref,
		variant,
		mod: [{ "data-orientation": orientation }, mod],
		role: "group",
		...others
	});
});
ButtonGroup.classes = classes$2;
ButtonGroup.displayName = "@mantine/core/ButtonGroup";
var varsResolver$3 = createVarsResolver((theme$1, { radius, color, gradient, variant, autoContrast, size: size$3 }) => {
	const colors = theme$1.variantColorResolver({
		color: color || theme$1.primaryColor,
		theme: theme$1,
		gradient,
		variant: variant || "filled",
		autoContrast
	});
	return { groupSection: {
		"--section-height": getSize(size$3, "section-height"),
		"--section-padding-x": getSize(size$3, "section-padding-x"),
		"--section-fz": size$3?.includes("compact") ? getFontSize(size$3.replace("compact-", "")) : getFontSize(size$3),
		"--section-radius": radius === void 0 ? void 0 : getRadius(radius),
		"--section-bg": color || variant ? colors.background : void 0,
		"--section-color": colors.color,
		"--section-bd": color || variant ? colors.border : void 0
	} };
});
var ButtonGroupSection = factory((_props, ref) => {
	const props = useProps("ButtonGroupSection", null, _props);
	const { className, style: style$1, classNames, styles, unstyled, vars, variant, gradient, radius, autoContrast, attributes, ...others } = props;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
		...useStyles({
			name: "ButtonGroupSection",
			props,
			classes: classes$2,
			className,
			style: style$1,
			classNames,
			styles,
			unstyled,
			attributes,
			vars,
			varsResolver: varsResolver$3,
			rootSelector: "groupSection"
		})("groupSection"),
		ref,
		variant,
		...others
	});
});
ButtonGroupSection.classes = classes$2;
ButtonGroupSection.displayName = "@mantine/core/ButtonGroupSection";
var loaderTransition = {
	in: {
		opacity: 1,
		transform: `translate(-50%, calc(-50% + ${rem(1)}))`
	},
	out: {
		opacity: 0,
		transform: "translate(-50%, -200%)"
	},
	common: { transformOrigin: "center" },
	transitionProperty: "transform, opacity"
};
var varsResolver$2 = createVarsResolver((theme$1, { radius, color, gradient, variant, size: size$3, justify, autoContrast }) => {
	const colors = theme$1.variantColorResolver({
		color: color || theme$1.primaryColor,
		theme: theme$1,
		gradient,
		variant: variant || "filled",
		autoContrast
	});
	return { root: {
		"--button-justify": justify,
		"--button-height": getSize(size$3, "button-height"),
		"--button-padding-x": getSize(size$3, "button-padding-x"),
		"--button-fz": size$3?.includes("compact") ? getFontSize(size$3.replace("compact-", "")) : getFontSize(size$3),
		"--button-radius": radius === void 0 ? void 0 : getRadius(radius),
		"--button-bg": color || variant ? colors.background : void 0,
		"--button-hover": color || variant ? colors.hover : void 0,
		"--button-color": colors.color,
		"--button-bd": color || variant ? colors.border : void 0,
		"--button-hover-color": color || variant ? colors.hoverColor : void 0
	} };
});
var Button = polymorphicFactory((_props, ref) => {
	const props = useProps("Button", null, _props);
	const { style: style$1, vars, className, color, disabled, children, leftSection, rightSection, fullWidth, variant, radius, loading, loaderProps, gradient, classNames, styles, unstyled, "data-disabled": dataDisabled, autoContrast, mod, attributes, ...others } = props;
	const getStyles = useStyles({
		name: "Button",
		props,
		classes: classes$2,
		className,
		style: style$1,
		classNames,
		styles,
		unstyled,
		attributes,
		vars,
		varsResolver: varsResolver$2
	});
	const hasLeftSection = !!leftSection;
	const hasRightSection = !!rightSection;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(UnstyledButton, {
		ref,
		...getStyles("root", { active: !disabled && !loading && !dataDisabled }),
		unstyled,
		variant,
		disabled: disabled || loading,
		mod: [{
			disabled: disabled || dataDisabled,
			loading,
			block: fullWidth,
			"with-left-section": hasLeftSection,
			"with-right-section": hasRightSection
		}, mod],
		...others,
		children: [typeof loading === "boolean" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transition, {
			mounted: loading,
			transition: loaderTransition,
			duration: 150,
			children: (transitionStyles) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
				component: "span",
				...getStyles("loader", { style: transitionStyles }),
				"aria-hidden": true,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Loader, {
					color: "var(--button-color)",
					size: "calc(var(--button-height) / 1.8)",
					...loaderProps
				})
			})
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
			...getStyles("inner"),
			children: [
				leftSection && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
					component: "span",
					...getStyles("section"),
					mod: { position: "left" },
					children: leftSection
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
					component: "span",
					mod: { loading },
					...getStyles("label"),
					children
				}),
				rightSection && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
					component: "span",
					...getStyles("section"),
					mod: { position: "right" },
					children: rightSection
				})
			]
		})]
	});
});
Button.classes = classes$2;
Button.displayName = "@mantine/core/Button";
Button.Group = ButtonGroup;
Button.GroupSection = ButtonGroupSection;
function __rest(s, e) {
	var t = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
	}
	return t;
}
var SourceType;
(function(SourceType$1) {
	SourceType$1["event"] = "event";
	SourceType$1["props"] = "prop";
})(SourceType || (SourceType = {}));
function noop$1() {}
function memoizeOnce(cb) {
	var lastArgs;
	var lastValue = void 0;
	return function() {
		var args = [], len = arguments.length;
		while (len--) args[len] = arguments[len];
		if (lastArgs && args.length === lastArgs.length && args.every(function(value, index$3) {
			return value === lastArgs[index$3];
		})) return lastValue;
		lastArgs = args;
		lastValue = cb.apply(void 0, args);
		return lastValue;
	};
}
function charIsNumber(char) {
	return !!(char || "").match(/\d/);
}
function isNil(val) {
	return val === null || val === void 0;
}
function isNanValue(val) {
	return typeof val === "number" && isNaN(val);
}
function isNotValidValue(val) {
	return isNil(val) || isNanValue(val) || typeof val === "number" && !isFinite(val);
}
function escapeRegExp(str) {
	return str.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
}
function getThousandsGroupRegex(thousandsGroupStyle) {
	switch (thousandsGroupStyle) {
		case "lakh": return /(\d+?)(?=(\d\d)+(\d)(?!\d))(\.\d+)?/g;
		case "wan": return /(\d)(?=(\d{4})+(?!\d))/g;
		case "thousand":
		default: return /(\d)(?=(\d{3})+(?!\d))/g;
	}
}
function applyThousandSeparator(str, thousandSeparator, thousandsGroupStyle) {
	var thousandsGroupRegex = getThousandsGroupRegex(thousandsGroupStyle);
	var index$3 = str.search(/[1-9]/);
	index$3 = index$3 === -1 ? str.length : index$3;
	return str.substring(0, index$3) + str.substring(index$3, str.length).replace(thousandsGroupRegex, "$1" + thousandSeparator);
}
function usePersistentCallback(cb) {
	var callbackRef = (0, import_react.useRef)(cb);
	callbackRef.current = cb;
	return (0, import_react.useRef)(function() {
		var args = [], len = arguments.length;
		while (len--) args[len] = arguments[len];
		return callbackRef.current.apply(callbackRef, args);
	}).current;
}
function splitDecimal(numStr, allowNegative) {
	if (allowNegative === void 0) allowNegative = true;
	var hasNegation = numStr[0] === "-";
	var addNegation = hasNegation && allowNegative;
	numStr = numStr.replace("-", "");
	var parts = numStr.split(".");
	return {
		beforeDecimal: parts[0],
		afterDecimal: parts[1] || "",
		hasNegation,
		addNegation
	};
}
function fixLeadingZero(numStr) {
	if (!numStr) return numStr;
	var isNegative = numStr[0] === "-";
	if (isNegative) numStr = numStr.substring(1, numStr.length);
	var parts = numStr.split(".");
	var beforeDecimal = parts[0].replace(/^0+/, "") || "0";
	var afterDecimal = parts[1] || "";
	return (isNegative ? "-" : "") + beforeDecimal + (afterDecimal ? "." + afterDecimal : "");
}
function limitToScale(numStr, scale, fixedDecimalScale) {
	var str = "";
	var filler = fixedDecimalScale ? "0" : "";
	for (var i = 0; i <= scale - 1; i++) str += numStr[i] || filler;
	return str;
}
function repeat(str, count$1) {
	return Array(count$1 + 1).join(str);
}
function toNumericString(num) {
	var _num = num + "";
	var sign = _num[0] === "-" ? "-" : "";
	if (sign) _num = _num.substring(1);
	var ref = _num.split(/[eE]/g);
	var coefficient = ref[0];
	var exponent = ref[1];
	exponent = Number(exponent);
	if (!exponent) return sign + coefficient;
	coefficient = coefficient.replace(".", "");
	var decimalIndex = 1 + exponent;
	var coffiecientLn = coefficient.length;
	if (decimalIndex < 0) coefficient = "0." + repeat("0", Math.abs(decimalIndex)) + coefficient;
	else if (decimalIndex >= coffiecientLn) coefficient = coefficient + repeat("0", decimalIndex - coffiecientLn);
	else coefficient = (coefficient.substring(0, decimalIndex) || "0") + "." + coefficient.substring(decimalIndex);
	return sign + coefficient;
}
function roundToPrecision(numStr, scale, fixedDecimalScale) {
	if (["", "-"].indexOf(numStr) !== -1) return numStr;
	var shouldHaveDecimalSeparator = (numStr.indexOf(".") !== -1 || fixedDecimalScale) && scale;
	var ref = splitDecimal(numStr);
	var beforeDecimal = ref.beforeDecimal;
	var afterDecimal = ref.afterDecimal;
	var hasNegation = ref.hasNegation;
	var floatValue = parseFloat("0." + (afterDecimal || "0"));
	var roundedDecimalParts = (afterDecimal.length <= scale ? "0." + afterDecimal : floatValue.toFixed(scale)).split(".");
	var intPart = beforeDecimal;
	if (beforeDecimal && Number(roundedDecimalParts[0])) intPart = beforeDecimal.split("").reverse().reduce(function(roundedStr, current, idx) {
		if (roundedStr.length > idx) return (Number(roundedStr[0]) + Number(current)).toString() + roundedStr.substring(1, roundedStr.length);
		return current + roundedStr;
	}, roundedDecimalParts[0]);
	var decimalPart = limitToScale(roundedDecimalParts[1] || "", scale, fixedDecimalScale);
	var negation = hasNegation ? "-" : "";
	var decimalSeparator = shouldHaveDecimalSeparator ? "." : "";
	return "" + negation + intPart + decimalSeparator + decimalPart;
}
function setCaretPosition(el, caretPos) {
	el.value = el.value;
	if (el !== null) {
		if (el.createTextRange) {
			var range = el.createTextRange();
			range.move("character", caretPos);
			range.select();
			return true;
		}
		if (el.selectionStart || el.selectionStart === 0) {
			el.focus();
			el.setSelectionRange(caretPos, caretPos);
			return true;
		}
		el.focus();
		return false;
	}
}
var findChangeRange = memoizeOnce(function(prevValue, newValue) {
	var i = 0, j = 0;
	var prevLength = prevValue.length;
	var newLength = newValue.length;
	while (prevValue[i] === newValue[i] && i < prevLength) i++;
	while (prevValue[prevLength - 1 - j] === newValue[newLength - 1 - j] && newLength - j > i && prevLength - j > i) j++;
	return {
		from: {
			start: i,
			end: prevLength - j
		},
		to: {
			start: i,
			end: newLength - j
		}
	};
});
var findChangedRangeFromCaretPositions = function(lastCaretPositions, currentCaretPosition) {
	var startPosition = Math.min(lastCaretPositions.selectionStart, currentCaretPosition);
	return {
		from: {
			start: startPosition,
			end: lastCaretPositions.selectionEnd
		},
		to: {
			start: startPosition,
			end: currentCaretPosition
		}
	};
};
function clamp$1(num, min$1, max$1) {
	return Math.min(Math.max(num, min$1), max$1);
}
function geInputCaretPosition(el) {
	return Math.max(el.selectionStart, el.selectionEnd);
}
function addInputMode() {
	return typeof navigator !== "undefined" && !(navigator.platform && /iPhone|iPod/.test(navigator.platform));
}
function getDefaultChangeMeta(value) {
	return {
		from: {
			start: 0,
			end: 0
		},
		to: {
			start: 0,
			end: value.length
		},
		lastValue: ""
	};
}
function defaultIsCharacterSame(ref) {
	var currentValue = ref.currentValue;
	var formattedValue = ref.formattedValue;
	var currentValueIndex = ref.currentValueIndex;
	var formattedValueIndex = ref.formattedValueIndex;
	return currentValue[currentValueIndex] === formattedValue[formattedValueIndex];
}
function getCaretPosition(newFormattedValue, lastFormattedValue, curValue, curCaretPos, boundary, isValidInputCharacter, isCharacterSame) {
	if (isCharacterSame === void 0) isCharacterSame = defaultIsCharacterSame;
	var firstAllowedPosition = boundary.findIndex(function(b) {
		return b;
	});
	var prefixFormat = newFormattedValue.slice(0, firstAllowedPosition);
	if (!lastFormattedValue && !curValue.startsWith(prefixFormat)) {
		lastFormattedValue = prefixFormat;
		curValue = prefixFormat + curValue;
		curCaretPos = curCaretPos + prefixFormat.length;
	}
	var curValLn = curValue.length;
	var formattedValueLn = newFormattedValue.length;
	var addedIndexMap = {};
	var indexMap = new Array(curValLn);
	for (var i = 0; i < curValLn; i++) {
		indexMap[i] = -1;
		for (var j = 0, jLn = formattedValueLn; j < jLn; j++) if (isCharacterSame({
			currentValue: curValue,
			lastValue: lastFormattedValue,
			formattedValue: newFormattedValue,
			currentValueIndex: i,
			formattedValueIndex: j
		}) && addedIndexMap[j] !== true) {
			indexMap[i] = j;
			addedIndexMap[j] = true;
			break;
		}
	}
	var pos = curCaretPos;
	while (pos < curValLn && (indexMap[pos] === -1 || !isValidInputCharacter(curValue[pos]))) pos++;
	var endIndex = pos === curValLn || indexMap[pos] === -1 ? formattedValueLn : indexMap[pos];
	pos = curCaretPos - 1;
	while (pos > 0 && indexMap[pos] === -1) pos--;
	var startIndex = pos === -1 || indexMap[pos] === -1 ? 0 : indexMap[pos] + 1;
	if (startIndex > endIndex) return endIndex;
	return curCaretPos - startIndex < endIndex - curCaretPos ? startIndex : endIndex;
}
function getCaretPosInBoundary(value, caretPos, boundary, direction) {
	var valLn = value.length;
	caretPos = clamp$1(caretPos, 0, valLn);
	if (direction === "left") {
		while (caretPos >= 0 && !boundary[caretPos]) caretPos--;
		if (caretPos === -1) caretPos = boundary.indexOf(true);
	} else {
		while (caretPos <= valLn && !boundary[caretPos]) caretPos++;
		if (caretPos > valLn) caretPos = boundary.lastIndexOf(true);
	}
	if (caretPos === -1) caretPos = valLn;
	return caretPos;
}
function caretUnknownFormatBoundary(formattedValue) {
	var boundaryAry = Array.from({ length: formattedValue.length + 1 }).map(function() {
		return true;
	});
	for (var i = 0, ln = boundaryAry.length; i < ln; i++) boundaryAry[i] = Boolean(charIsNumber(formattedValue[i]) || charIsNumber(formattedValue[i - 1]));
	return boundaryAry;
}
function useInternalValues(value, defaultValue, valueIsNumericString, format$1, removeFormatting$1, onValueChange) {
	if (onValueChange === void 0) onValueChange = noop$1;
	var getValues = usePersistentCallback(function(value$1, valueIsNumericString$1) {
		var formattedValue, numAsString;
		if (isNotValidValue(value$1)) {
			numAsString = "";
			formattedValue = "";
		} else if (typeof value$1 === "number" || valueIsNumericString$1) {
			numAsString = typeof value$1 === "number" ? toNumericString(value$1) : value$1;
			formattedValue = format$1(numAsString);
		} else {
			numAsString = removeFormatting$1(value$1, void 0);
			formattedValue = format$1(numAsString);
		}
		return {
			formattedValue,
			numAsString
		};
	});
	var ref = (0, import_react.useState)(function() {
		return getValues(isNil(value) ? defaultValue : value, valueIsNumericString);
	});
	var values$1 = ref[0];
	var setValues = ref[1];
	var _onValueChange = function(newValues$1, sourceInfo) {
		if (newValues$1.formattedValue !== values$1.formattedValue) setValues({
			formattedValue: newValues$1.formattedValue,
			numAsString: newValues$1.value
		});
		onValueChange(newValues$1, sourceInfo);
	};
	var _value = value;
	var _valueIsNumericString = valueIsNumericString;
	if (isNil(value)) {
		_value = values$1.numAsString;
		_valueIsNumericString = true;
	}
	var newValues = getValues(_value, _valueIsNumericString);
	(0, import_react.useMemo)(function() {
		setValues(newValues);
	}, [newValues.formattedValue]);
	return [values$1, _onValueChange];
}
function defaultRemoveFormatting(value) {
	return value.replace(/[^0-9]/g, "");
}
function defaultFormat(value) {
	return value;
}
function NumberFormatBase(props) {
	var type = props.type;
	if (type === void 0) type = "text";
	var displayType = props.displayType;
	if (displayType === void 0) displayType = "input";
	var customInput = props.customInput;
	var renderText = props.renderText;
	var getInputRef = props.getInputRef;
	var format$1 = props.format;
	if (format$1 === void 0) format$1 = defaultFormat;
	var removeFormatting$1 = props.removeFormatting;
	if (removeFormatting$1 === void 0) removeFormatting$1 = defaultRemoveFormatting;
	var defaultValue = props.defaultValue;
	var valueIsNumericString = props.valueIsNumericString;
	var onValueChange = props.onValueChange;
	var isAllowed = props.isAllowed;
	var onChange = props.onChange;
	if (onChange === void 0) onChange = noop$1;
	var onKeyDown = props.onKeyDown;
	if (onKeyDown === void 0) onKeyDown = noop$1;
	var onMouseUp = props.onMouseUp;
	if (onMouseUp === void 0) onMouseUp = noop$1;
	var onFocus = props.onFocus;
	if (onFocus === void 0) onFocus = noop$1;
	var onBlur = props.onBlur;
	if (onBlur === void 0) onBlur = noop$1;
	var propValue = props.value;
	var getCaretBoundary$1 = props.getCaretBoundary;
	if (getCaretBoundary$1 === void 0) getCaretBoundary$1 = caretUnknownFormatBoundary;
	var isValidInputCharacter = props.isValidInputCharacter;
	if (isValidInputCharacter === void 0) isValidInputCharacter = charIsNumber;
	var isCharacterSame = props.isCharacterSame;
	var otherProps = __rest(props, [
		"type",
		"displayType",
		"customInput",
		"renderText",
		"getInputRef",
		"format",
		"removeFormatting",
		"defaultValue",
		"valueIsNumericString",
		"onValueChange",
		"isAllowed",
		"onChange",
		"onKeyDown",
		"onMouseUp",
		"onFocus",
		"onBlur",
		"value",
		"getCaretBoundary",
		"isValidInputCharacter",
		"isCharacterSame"
	]);
	var ref = useInternalValues(propValue, defaultValue, Boolean(valueIsNumericString), format$1, removeFormatting$1, onValueChange);
	var ref_0 = ref[0];
	var formattedValue = ref_0.formattedValue;
	var numAsString = ref_0.numAsString;
	var onFormattedValueChange = ref[1];
	var caretPositionBeforeChange = (0, import_react.useRef)();
	var lastUpdatedValue = (0, import_react.useRef)({
		formattedValue,
		numAsString
	});
	var _onValueChange = function(values$1, source) {
		lastUpdatedValue.current = {
			formattedValue: values$1.formattedValue,
			numAsString: values$1.value
		};
		onFormattedValueChange(values$1, source);
	};
	var ref$1 = (0, import_react.useState)(false);
	var mounted = ref$1[0];
	var setMounted = ref$1[1];
	var focusedElm = (0, import_react.useRef)(null);
	var timeout = (0, import_react.useRef)({
		setCaretTimeout: null,
		focusTimeout: null
	});
	(0, import_react.useEffect)(function() {
		setMounted(true);
		return function() {
			clearTimeout(timeout.current.setCaretTimeout);
			clearTimeout(timeout.current.focusTimeout);
		};
	}, []);
	var _format = format$1;
	var getValueObject = function(formattedValue$1, numAsString$1) {
		var floatValue = parseFloat(numAsString$1);
		return {
			formattedValue: formattedValue$1,
			value: numAsString$1,
			floatValue: isNaN(floatValue) ? void 0 : floatValue
		};
	};
	var setPatchedCaretPosition = function(el, caretPos, currentValue) {
		if (el.selectionStart === 0 && el.selectionEnd === el.value.length) return;
		setCaretPosition(el, caretPos);
		timeout.current.setCaretTimeout = setTimeout(function() {
			if (el.value === currentValue && el.selectionStart !== caretPos) setCaretPosition(el, caretPos);
		}, 0);
	};
	var correctCaretPosition = function(value, caretPos, direction) {
		return getCaretPosInBoundary(value, caretPos, getCaretBoundary$1(value), direction);
	};
	var getNewCaretPosition = function(inputValue, newFormattedValue, caretPos) {
		var caretBoundary = getCaretBoundary$1(newFormattedValue);
		var updatedCaretPos = getCaretPosition(newFormattedValue, formattedValue, inputValue, caretPos, caretBoundary, isValidInputCharacter, isCharacterSame);
		updatedCaretPos = getCaretPosInBoundary(newFormattedValue, updatedCaretPos, caretBoundary);
		return updatedCaretPos;
	};
	var updateValueAndCaretPosition = function(params) {
		var newFormattedValue = params.formattedValue;
		if (newFormattedValue === void 0) newFormattedValue = "";
		var input = params.input;
		var source = params.source;
		var event = params.event;
		var numAsString$1 = params.numAsString;
		var caretPos;
		if (input) {
			var inputValue = params.inputValue || input.value;
			var currentCaretPosition$1 = geInputCaretPosition(input);
			input.value = newFormattedValue;
			caretPos = getNewCaretPosition(inputValue, newFormattedValue, currentCaretPosition$1);
			if (caretPos !== void 0) setPatchedCaretPosition(input, caretPos, newFormattedValue);
		}
		if (newFormattedValue !== formattedValue) _onValueChange(getValueObject(newFormattedValue, numAsString$1), {
			event,
			source
		});
	};
	(0, import_react.useEffect)(function() {
		var ref$2 = lastUpdatedValue.current;
		var lastFormattedValue = ref$2.formattedValue;
		var lastNumAsString = ref$2.numAsString;
		if (formattedValue !== lastFormattedValue || numAsString !== lastNumAsString) _onValueChange(getValueObject(formattedValue, numAsString), {
			event: void 0,
			source: SourceType.props
		});
	}, [formattedValue, numAsString]);
	var currentCaretPosition = focusedElm.current ? geInputCaretPosition(focusedElm.current) : void 0;
	(typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect)(function() {
		var input = focusedElm.current;
		if (formattedValue !== lastUpdatedValue.current.formattedValue && input) {
			var caretPos = getNewCaretPosition(lastUpdatedValue.current.formattedValue, formattedValue, currentCaretPosition);
			input.value = formattedValue;
			setPatchedCaretPosition(input, caretPos, formattedValue);
		}
	}, [formattedValue]);
	var formatInputValue = function(inputValue, event, source) {
		var input = event.target;
		var changeRange = caretPositionBeforeChange.current ? findChangedRangeFromCaretPositions(caretPositionBeforeChange.current, input.selectionEnd) : findChangeRange(formattedValue, inputValue);
		var changeMeta = Object.assign(Object.assign({}, changeRange), { lastValue: formattedValue });
		var _numAsString = removeFormatting$1(inputValue, changeMeta);
		var _formattedValue = _format(_numAsString);
		_numAsString = removeFormatting$1(_formattedValue, void 0);
		if (isAllowed && !isAllowed(getValueObject(_formattedValue, _numAsString))) {
			var input$1 = event.target;
			var caretPos = getNewCaretPosition(inputValue, formattedValue, geInputCaretPosition(input$1));
			input$1.value = formattedValue;
			setPatchedCaretPosition(input$1, caretPos, formattedValue);
			return false;
		}
		updateValueAndCaretPosition({
			formattedValue: _formattedValue,
			numAsString: _numAsString,
			inputValue,
			event,
			source,
			input: event.target
		});
		return true;
	};
	var setCaretPositionInfoBeforeChange = function(el, endOffset) {
		if (endOffset === void 0) endOffset = 0;
		caretPositionBeforeChange.current = {
			selectionStart: el.selectionStart,
			selectionEnd: el.selectionEnd + endOffset
		};
	};
	var _onChange = function(e) {
		var inputValue = e.target.value;
		if (formatInputValue(inputValue, e, SourceType.event)) onChange(e);
		caretPositionBeforeChange.current = void 0;
	};
	var _onKeyDown = function(e) {
		var el = e.target;
		var key = e.key;
		var selectionStart = el.selectionStart;
		var selectionEnd = el.selectionEnd;
		var value = el.value;
		if (value === void 0) value = "";
		var expectedCaretPosition;
		if (key === "ArrowLeft" || key === "Backspace") expectedCaretPosition = Math.max(selectionStart - 1, 0);
		else if (key === "ArrowRight") expectedCaretPosition = Math.min(selectionStart + 1, value.length);
		else if (key === "Delete") expectedCaretPosition = selectionStart;
		var endOffset = 0;
		if (key === "Delete" && selectionStart === selectionEnd) endOffset = 1;
		var isArrowKey = key === "ArrowLeft" || key === "ArrowRight";
		if (expectedCaretPosition === void 0 || selectionStart !== selectionEnd && !isArrowKey) {
			onKeyDown(e);
			setCaretPositionInfoBeforeChange(el, endOffset);
			return;
		}
		var newCaretPosition = expectedCaretPosition;
		if (isArrowKey) {
			newCaretPosition = correctCaretPosition(value, expectedCaretPosition, key === "ArrowLeft" ? "left" : "right");
			if (newCaretPosition !== expectedCaretPosition) e.preventDefault();
		} else if (key === "Delete" && !isValidInputCharacter(value[expectedCaretPosition])) newCaretPosition = correctCaretPosition(value, expectedCaretPosition, "right");
		else if (key === "Backspace" && !isValidInputCharacter(value[expectedCaretPosition])) newCaretPosition = correctCaretPosition(value, expectedCaretPosition, "left");
		if (newCaretPosition !== expectedCaretPosition) setPatchedCaretPosition(el, newCaretPosition, value);
		onKeyDown(e);
		setCaretPositionInfoBeforeChange(el, endOffset);
	};
	var _onMouseUp = function(e) {
		var el = e.target;
		var correctCaretPositionIfRequired = function() {
			var selectionStart = el.selectionStart;
			var selectionEnd = el.selectionEnd;
			var value = el.value;
			if (value === void 0) value = "";
			if (selectionStart === selectionEnd) {
				var caretPosition = correctCaretPosition(value, selectionStart);
				if (caretPosition !== selectionStart) setPatchedCaretPosition(el, caretPosition, value);
			}
		};
		correctCaretPositionIfRequired();
		requestAnimationFrame(function() {
			correctCaretPositionIfRequired();
		});
		onMouseUp(e);
		setCaretPositionInfoBeforeChange(el);
	};
	var _onFocus = function(e) {
		if (e.persist) e.persist();
		var el = e.target;
		var currentTarget = e.currentTarget;
		focusedElm.current = el;
		timeout.current.focusTimeout = setTimeout(function() {
			var selectionStart = el.selectionStart;
			var selectionEnd = el.selectionEnd;
			var value = el.value;
			if (value === void 0) value = "";
			var caretPosition = correctCaretPosition(value, selectionStart);
			if (caretPosition !== selectionStart && !(selectionStart === 0 && selectionEnd === value.length)) setPatchedCaretPosition(el, caretPosition, value);
			onFocus(Object.assign(Object.assign({}, e), { currentTarget }));
		}, 0);
	};
	var _onBlur = function(e) {
		focusedElm.current = null;
		clearTimeout(timeout.current.focusTimeout);
		clearTimeout(timeout.current.setCaretTimeout);
		onBlur(e);
	};
	var inputMode = mounted && addInputMode() ? "numeric" : void 0;
	var inputProps = Object.assign({ inputMode }, otherProps, {
		type,
		value: formattedValue,
		onChange: _onChange,
		onKeyDown: _onKeyDown,
		onMouseUp: _onMouseUp,
		onFocus: _onFocus,
		onBlur: _onBlur
	});
	if (displayType === "text") return renderText ? import_react.createElement(import_react.Fragment, null, renderText(formattedValue, otherProps) || null) : import_react.createElement("span", Object.assign({}, otherProps, { ref: getInputRef }), formattedValue);
	else if (customInput) {
		var CustomInput = customInput;
		return import_react.createElement(CustomInput, Object.assign({}, inputProps, { ref: getInputRef }));
	}
	return import_react.createElement("input", Object.assign({}, inputProps, { ref: getInputRef }));
}
function format(numStr, props) {
	var decimalScale = props.decimalScale;
	var fixedDecimalScale = props.fixedDecimalScale;
	var prefix$1 = props.prefix;
	if (prefix$1 === void 0) prefix$1 = "";
	var suffix$1 = props.suffix;
	if (suffix$1 === void 0) suffix$1 = "";
	var allowNegative = props.allowNegative;
	var thousandsGroupStyle = props.thousandsGroupStyle;
	if (thousandsGroupStyle === void 0) thousandsGroupStyle = "thousand";
	if (numStr === "" || numStr === "-") return numStr;
	var ref = getSeparators(props);
	var thousandSeparator = ref.thousandSeparator;
	var decimalSeparator = ref.decimalSeparator;
	var hasDecimalSeparator = decimalScale !== 0 && numStr.indexOf(".") !== -1 || decimalScale && fixedDecimalScale;
	var ref$1 = splitDecimal(numStr, allowNegative);
	var beforeDecimal = ref$1.beforeDecimal;
	var afterDecimal = ref$1.afterDecimal;
	var addNegation = ref$1.addNegation;
	if (decimalScale !== void 0) afterDecimal = limitToScale(afterDecimal, decimalScale, !!fixedDecimalScale);
	if (thousandSeparator) beforeDecimal = applyThousandSeparator(beforeDecimal, thousandSeparator, thousandsGroupStyle);
	if (prefix$1) beforeDecimal = prefix$1 + beforeDecimal;
	if (suffix$1) afterDecimal = afterDecimal + suffix$1;
	if (addNegation) beforeDecimal = "-" + beforeDecimal;
	numStr = beforeDecimal + (hasDecimalSeparator && decimalSeparator || "") + afterDecimal;
	return numStr;
}
function getSeparators(props) {
	var decimalSeparator = props.decimalSeparator;
	if (decimalSeparator === void 0) decimalSeparator = ".";
	var thousandSeparator = props.thousandSeparator;
	var allowedDecimalSeparators = props.allowedDecimalSeparators;
	if (thousandSeparator === true) thousandSeparator = ",";
	if (!allowedDecimalSeparators) allowedDecimalSeparators = [decimalSeparator, "."];
	return {
		decimalSeparator,
		thousandSeparator,
		allowedDecimalSeparators
	};
}
function handleNegation(value, allowNegative) {
	if (value === void 0) value = "";
	var negationRegex = /* @__PURE__ */ new RegExp("(-)");
	var doubleNegationRegex = /* @__PURE__ */ new RegExp("(-)(.)*(-)");
	var hasNegation = negationRegex.test(value);
	var removeNegation = doubleNegationRegex.test(value);
	value = value.replace(/-/g, "");
	if (hasNegation && !removeNegation && allowNegative) value = "-" + value;
	return value;
}
function getNumberRegex(decimalSeparator, global) {
	return new RegExp("(^-)|[0-9]|" + escapeRegExp(decimalSeparator), global ? "g" : void 0);
}
function isNumericString(val, prefix$1, suffix$1) {
	if (val === "") return true;
	return !(prefix$1 === null || prefix$1 === void 0 ? void 0 : prefix$1.match(/\d/)) && !(suffix$1 === null || suffix$1 === void 0 ? void 0 : suffix$1.match(/\d/)) && typeof val === "string" && !isNaN(Number(val));
}
function removeFormatting(value, changeMeta, props) {
	var assign$2;
	if (changeMeta === void 0) changeMeta = getDefaultChangeMeta(value);
	var allowNegative = props.allowNegative;
	var prefix$1 = props.prefix;
	if (prefix$1 === void 0) prefix$1 = "";
	var suffix$1 = props.suffix;
	if (suffix$1 === void 0) suffix$1 = "";
	var decimalScale = props.decimalScale;
	var from = changeMeta.from;
	var to = changeMeta.to;
	var start = to.start;
	var end = to.end;
	var ref = getSeparators(props);
	var allowedDecimalSeparators = ref.allowedDecimalSeparators;
	var decimalSeparator = ref.decimalSeparator;
	var isBeforeDecimalSeparator = value[end] === decimalSeparator;
	if (charIsNumber(value) && (value === prefix$1 || value === suffix$1) && changeMeta.lastValue === "") return value;
	if (end - start === 1 && allowedDecimalSeparators.indexOf(value[start]) !== -1) {
		var separator = decimalScale === 0 ? "" : decimalSeparator;
		value = value.substring(0, start) + separator + value.substring(start + 1, value.length);
	}
	var stripNegation = function(value$1, start$1, end$1) {
		var hasNegation$1 = false;
		var hasDoubleNegation = false;
		if (prefix$1.startsWith("-")) hasNegation$1 = false;
		else if (value$1.startsWith("--")) {
			hasNegation$1 = false;
			hasDoubleNegation = true;
		} else if (suffix$1.startsWith("-") && value$1.length === suffix$1.length) hasNegation$1 = false;
		else if (value$1[0] === "-") hasNegation$1 = true;
		var charsToRemove = hasNegation$1 ? 1 : 0;
		if (hasDoubleNegation) charsToRemove = 2;
		if (charsToRemove) {
			value$1 = value$1.substring(charsToRemove);
			start$1 -= charsToRemove;
			end$1 -= charsToRemove;
		}
		return {
			value: value$1,
			start: start$1,
			end: end$1,
			hasNegation: hasNegation$1
		};
	};
	var toMetadata = stripNegation(value, start, end);
	var hasNegation = toMetadata.hasNegation;
	assign$2 = toMetadata, value = assign$2.value, start = assign$2.start, end = assign$2.end;
	var ref$1 = stripNegation(changeMeta.lastValue, from.start, from.end);
	var fromStart = ref$1.start;
	var fromEnd = ref$1.end;
	var lastValue = ref$1.value;
	var updatedSuffixPart = value.substring(start, end);
	if (value.length && lastValue.length && (fromStart > lastValue.length - suffix$1.length || fromEnd < prefix$1.length) && !(updatedSuffixPart && suffix$1.startsWith(updatedSuffixPart))) value = lastValue;
	var startIndex = 0;
	if (value.startsWith(prefix$1)) startIndex += prefix$1.length;
	else if (start < prefix$1.length) startIndex = start;
	value = value.substring(startIndex);
	end -= startIndex;
	var endIndex = value.length;
	var suffixStartIndex = value.length - suffix$1.length;
	if (value.endsWith(suffix$1)) endIndex = suffixStartIndex;
	else if (end > suffixStartIndex) endIndex = end;
	else if (end > value.length - suffix$1.length) endIndex = end;
	value = value.substring(0, endIndex);
	value = handleNegation(hasNegation ? "-" + value : value, allowNegative);
	value = (value.match(getNumberRegex(decimalSeparator, true)) || []).join("");
	var firstIndex = value.indexOf(decimalSeparator);
	value = value.replace(new RegExp(escapeRegExp(decimalSeparator), "g"), function(match, index$3) {
		return index$3 === firstIndex ? "." : "";
	});
	var ref$2 = splitDecimal(value, allowNegative);
	var beforeDecimal = ref$2.beforeDecimal;
	var afterDecimal = ref$2.afterDecimal;
	var addNegation = ref$2.addNegation;
	if (to.end - to.start < from.end - from.start && beforeDecimal === "" && isBeforeDecimalSeparator && !parseFloat(afterDecimal)) value = addNegation ? "-" : "";
	return value;
}
function getCaretBoundary(formattedValue, props) {
	var prefix$1 = props.prefix;
	if (prefix$1 === void 0) prefix$1 = "";
	var suffix$1 = props.suffix;
	if (suffix$1 === void 0) suffix$1 = "";
	var boundaryAry = Array.from({ length: formattedValue.length + 1 }).map(function() {
		return true;
	});
	var hasNegation = formattedValue[0] === "-";
	boundaryAry.fill(false, 0, prefix$1.length + (hasNegation ? 1 : 0));
	var valLn = formattedValue.length;
	boundaryAry.fill(false, valLn - suffix$1.length + 1, valLn + 1);
	return boundaryAry;
}
function validateAndUpdateProps(props) {
	var ref = getSeparators(props);
	var thousandSeparator = ref.thousandSeparator;
	var decimalSeparator = ref.decimalSeparator;
	var prefix$1 = props.prefix;
	if (prefix$1 === void 0) prefix$1 = "";
	var allowNegative = props.allowNegative;
	if (allowNegative === void 0) allowNegative = true;
	if (thousandSeparator === decimalSeparator) throw new Error("\n        Decimal separator can't be same as thousand separator.\n        thousandSeparator: " + thousandSeparator + " (thousandSeparator = {true} is same as thousandSeparator = \",\")\n        decimalSeparator: " + decimalSeparator + " (default value for decimalSeparator is .)\n     ");
	if (prefix$1.startsWith("-") && allowNegative) {
		console.error("\n      Prefix can't start with '-' when allowNegative is true.\n      prefix: " + prefix$1 + "\n      allowNegative: " + allowNegative + "\n    ");
		allowNegative = false;
	}
	return Object.assign(Object.assign({}, props), { allowNegative });
}
function useNumericFormat(props) {
	props = validateAndUpdateProps(props);
	props.decimalSeparator;
	props.allowedDecimalSeparators;
	props.thousandsGroupStyle;
	var suffix$1 = props.suffix;
	var allowNegative = props.allowNegative;
	var allowLeadingZeros = props.allowLeadingZeros;
	var onKeyDown = props.onKeyDown;
	if (onKeyDown === void 0) onKeyDown = noop$1;
	var onBlur = props.onBlur;
	if (onBlur === void 0) onBlur = noop$1;
	var thousandSeparator = props.thousandSeparator;
	var decimalScale = props.decimalScale;
	var fixedDecimalScale = props.fixedDecimalScale;
	var prefix$1 = props.prefix;
	if (prefix$1 === void 0) prefix$1 = "";
	var defaultValue = props.defaultValue;
	var value = props.value;
	var valueIsNumericString = props.valueIsNumericString;
	var onValueChange = props.onValueChange;
	var restProps = __rest(props, [
		"decimalSeparator",
		"allowedDecimalSeparators",
		"thousandsGroupStyle",
		"suffix",
		"allowNegative",
		"allowLeadingZeros",
		"onKeyDown",
		"onBlur",
		"thousandSeparator",
		"decimalScale",
		"fixedDecimalScale",
		"prefix",
		"defaultValue",
		"value",
		"valueIsNumericString",
		"onValueChange"
	]);
	var ref = getSeparators(props);
	var decimalSeparator = ref.decimalSeparator;
	var allowedDecimalSeparators = ref.allowedDecimalSeparators;
	var _format = function(numStr) {
		return format(numStr, props);
	};
	var _removeFormatting = function(inputValue, changeMeta) {
		return removeFormatting(inputValue, changeMeta, props);
	};
	var _value = isNil(value) ? defaultValue : value;
	var _valueIsNumericString = valueIsNumericString !== null && valueIsNumericString !== void 0 ? valueIsNumericString : isNumericString(_value, prefix$1, suffix$1);
	if (!isNil(value)) _valueIsNumericString = _valueIsNumericString || typeof value === "number";
	else if (!isNil(defaultValue)) _valueIsNumericString = _valueIsNumericString || typeof defaultValue === "number";
	var roundIncomingValueToPrecision = function(value$1) {
		if (isNotValidValue(value$1)) return value$1;
		if (typeof value$1 === "number") value$1 = toNumericString(value$1);
		if (_valueIsNumericString && typeof decimalScale === "number") return roundToPrecision(value$1, decimalScale, Boolean(fixedDecimalScale));
		return value$1;
	};
	var ref$1 = useInternalValues(roundIncomingValueToPrecision(value), roundIncomingValueToPrecision(defaultValue), Boolean(_valueIsNumericString), _format, _removeFormatting, onValueChange);
	var ref$1_0 = ref$1[0];
	var numAsString = ref$1_0.numAsString;
	var formattedValue = ref$1_0.formattedValue;
	var _onValueChange = ref$1[1];
	var _onKeyDown = function(e) {
		var el = e.target;
		var key = e.key;
		var selectionStart = el.selectionStart;
		var selectionEnd = el.selectionEnd;
		var value$1 = el.value;
		if (value$1 === void 0) value$1 = "";
		if ((key === "Backspace" || key === "Delete") && selectionEnd < prefix$1.length) {
			e.preventDefault();
			return;
		}
		if (selectionStart !== selectionEnd) {
			onKeyDown(e);
			return;
		}
		if (key === "Backspace" && value$1[0] === "-" && selectionStart === prefix$1.length + 1 && allowNegative) setCaretPosition(el, 1);
		if (decimalScale && fixedDecimalScale) {
			if (key === "Backspace" && value$1[selectionStart - 1] === decimalSeparator) {
				setCaretPosition(el, selectionStart - 1);
				e.preventDefault();
			} else if (key === "Delete" && value$1[selectionStart] === decimalSeparator) e.preventDefault();
		}
		if ((allowedDecimalSeparators === null || allowedDecimalSeparators === void 0 ? void 0 : allowedDecimalSeparators.includes(key)) && value$1[selectionStart] === decimalSeparator) setCaretPosition(el, selectionStart + 1);
		var _thousandSeparator = thousandSeparator === true ? "," : thousandSeparator;
		if (key === "Backspace" && value$1[selectionStart - 1] === _thousandSeparator) setCaretPosition(el, selectionStart - 1);
		if (key === "Delete" && value$1[selectionStart] === _thousandSeparator) setCaretPosition(el, selectionStart + 1);
		onKeyDown(e);
	};
	var _onBlur = function(e) {
		var _value$1 = numAsString;
		if (!_value$1.match(/\d/g)) _value$1 = "";
		if (!allowLeadingZeros) _value$1 = fixLeadingZero(_value$1);
		if (fixedDecimalScale && decimalScale) _value$1 = roundToPrecision(_value$1, decimalScale, fixedDecimalScale);
		if (_value$1 !== numAsString) _onValueChange({
			formattedValue: format(_value$1, props),
			value: _value$1,
			floatValue: parseFloat(_value$1)
		}, {
			event: e,
			source: SourceType.event
		});
		onBlur(e);
	};
	var isValidInputCharacter = function(inputChar) {
		if (inputChar === decimalSeparator) return true;
		return charIsNumber(inputChar);
	};
	var isCharacterSame = function(ref$2) {
		var currentValue = ref$2.currentValue;
		var lastValue = ref$2.lastValue;
		var formattedValue$1 = ref$2.formattedValue;
		var currentValueIndex = ref$2.currentValueIndex;
		var formattedValueIndex = ref$2.formattedValueIndex;
		var curChar = currentValue[currentValueIndex];
		var newChar = formattedValue$1[formattedValueIndex];
		var to = findChangeRange(lastValue, currentValue).to;
		var getDecimalSeparatorIndex = function(value$1) {
			return _removeFormatting(value$1).indexOf(".") + prefix$1.length;
		};
		if (value === 0 && fixedDecimalScale && decimalScale && currentValue[to.start] === decimalSeparator && getDecimalSeparatorIndex(currentValue) < currentValueIndex && getDecimalSeparatorIndex(formattedValue$1) > formattedValueIndex) return false;
		if (currentValueIndex >= to.start && currentValueIndex < to.end && allowedDecimalSeparators && allowedDecimalSeparators.includes(curChar) && newChar === decimalSeparator) return true;
		return curChar === newChar;
	};
	return Object.assign(Object.assign({}, restProps), {
		value: formattedValue,
		valueIsNumericString: false,
		isValidInputCharacter,
		isCharacterSame,
		onValueChange: _onValueChange,
		format: _format,
		removeFormatting: _removeFormatting,
		getCaretBoundary: function(formattedValue$1) {
			return getCaretBoundary(formattedValue$1, props);
		},
		onKeyDown: _onKeyDown,
		onBlur: _onBlur
	});
}
function NumericFormat(props) {
	var numericFormatProps = useNumericFormat(props);
	return import_react.createElement(NumberFormatBase, Object.assign({}, numericFormatProps));
}
function NumberInputChevron({ direction, style: style$1, ...others }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", {
		style: {
			width: "var(--ni-chevron-size)",
			height: "var(--ni-chevron-size)",
			transform: direction === "up" ? "rotate(180deg)" : void 0,
			...style$1
		},
		viewBox: "0 0 15 15",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		...others,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
			d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
			fill: "currentColor",
			fillRule: "evenodd",
			clipRule: "evenodd"
		})
	});
}
var classes$1 = {
	"root": "m_e2f5cd4e",
	"controls": "m_95e17d22",
	"control": "m_80b4b171"
};
var leadingDecimalZeroPattern = /^(0\.0*|-0(\.0*)?)$/;
var leadingZerosPattern = /^-?0\d+(\.\d+)?\.?$/;
var trailingZerosPattern = /\.\d*0$/;
function isNumberString(value) {
	return typeof value === "string" && value !== "" && !Number.isNaN(Number(value));
}
function canIncrement(value) {
	if (typeof value === "number") return value < Number.MAX_SAFE_INTEGER;
	return value === "" || isNumberString(value) && Number(value) < Number.MAX_SAFE_INTEGER;
}
function getDecimalPlaces(inputValue) {
	return inputValue.toString().replace(".", "").length;
}
function isValidNumber(floatValue, value) {
	return (typeof floatValue === "number" ? floatValue < Number.MAX_SAFE_INTEGER : !Number.isNaN(Number(floatValue))) && !Number.isNaN(floatValue) && getDecimalPlaces(value) < 14 && value !== "";
}
function isInRange(value, min$1, max$1) {
	if (value === void 0) return true;
	return (min$1 === void 0 || value >= min$1) && (max$1 === void 0 || value <= max$1);
}
var defaultProps$2 = {
	step: 1,
	clampBehavior: "blur",
	allowDecimal: true,
	allowNegative: true,
	withKeyboardEvents: true,
	allowLeadingZeros: true,
	trimLeadingZeroesOnBlur: true,
	startValue: 0,
	allowedDecimalSeparators: [".", ","]
};
var varsResolver$1 = createVarsResolver((_, { size: size$3 }) => ({ controls: { "--ni-chevron-size": getSize(size$3, "ni-chevron-size") } }));
function clampAndSanitizeInput(sanitizedValue, max$1, min$1) {
	const replaced = sanitizedValue.toString().replace(/^0+(?=\d)/, "");
	const parsedValue = parseFloat(replaced);
	if (Number.isNaN(parsedValue)) return replaced;
	else if (parsedValue > Number.MAX_SAFE_INTEGER) return max$1 !== void 0 ? max$1 : replaced;
	return clamp(parsedValue, min$1, max$1);
}
var NumberInput = factory((_props, ref) => {
	const props = useProps("NumberInput", defaultProps$2, _props);
	const { className, classNames, styles, unstyled, vars, onChange, onValueChange, value, defaultValue, max: max$1, min: min$1, step, hideControls, rightSection, isAllowed, clampBehavior, onBlur, allowDecimal, decimalScale, onKeyDown, onKeyDownCapture, handlersRef, startValue, disabled, rightSectionPointerEvents, allowNegative, readOnly, size: size$3, rightSectionWidth, stepHoldInterval, stepHoldDelay, allowLeadingZeros, withKeyboardEvents, trimLeadingZeroesOnBlur, allowedDecimalSeparators, attributes, ...others } = props;
	const getStyles = useStyles({
		name: "NumberInput",
		classes: classes$1,
		props,
		classNames,
		styles,
		unstyled,
		attributes,
		vars,
		varsResolver: varsResolver$1
	});
	const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
		classNames,
		styles,
		props
	});
	const [_value, setValue] = useUncontrolled({
		value,
		defaultValue,
		finalValue: "",
		onChange
	});
	const shouldUseStepInterval = stepHoldDelay !== void 0 && stepHoldInterval !== void 0;
	const inputRef = (0, import_react.useRef)(null);
	const onStepTimeoutRef = (0, import_react.useRef)(null);
	const stepCountRef = (0, import_react.useRef)(0);
	const handleValueChange = (payload, event) => {
		if (event.source === "event") setValue(isValidNumber(payload.floatValue, payload.value) && !leadingDecimalZeroPattern.test(payload.value) && !(allowLeadingZeros ? leadingZerosPattern.test(payload.value) : false) && !trailingZerosPattern.test(payload.value) ? payload.floatValue : payload.value);
		onValueChange?.(payload, event);
	};
	const getDecimalPlaces2 = (inputValue) => {
		const match = String(inputValue).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
		if (!match) return 0;
		return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0));
	};
	const adjustCursor = (position) => {
		if (inputRef.current && typeof position !== "undefined") inputRef.current.setSelectionRange(position, position);
	};
	const incrementRef = (0, import_react.useRef)(noop);
	incrementRef.current = () => {
		if (!canIncrement(_value)) return;
		let val;
		const currentValuePrecision = getDecimalPlaces2(_value);
		const stepPrecision = getDecimalPlaces2(step);
		const maxPrecision = Math.max(currentValuePrecision, stepPrecision);
		const factor = 10 ** maxPrecision;
		if (!isNumberString(_value) && (typeof _value !== "number" || Number.isNaN(_value))) val = clamp(startValue, min$1, max$1);
		else if (max$1 !== void 0) {
			const incrementedValue = (Math.round(Number(_value) * factor) + Math.round(step * factor)) / factor;
			val = incrementedValue <= max$1 ? incrementedValue : max$1;
		} else val = (Math.round(Number(_value) * factor) + Math.round(step * factor)) / factor;
		const formattedValue = val.toFixed(maxPrecision);
		setValue(parseFloat(formattedValue));
		onValueChange?.({
			floatValue: parseFloat(formattedValue),
			formattedValue,
			value: formattedValue
		}, { source: "increment" });
		setTimeout(() => adjustCursor(inputRef.current?.value.length), 0);
	};
	const decrementRef = (0, import_react.useRef)(noop);
	decrementRef.current = () => {
		if (!canIncrement(_value)) return;
		let val;
		const minValue = min$1 !== void 0 ? min$1 : !allowNegative ? 0 : Number.MIN_SAFE_INTEGER;
		const currentValuePrecision = getDecimalPlaces2(_value);
		const stepPrecision = getDecimalPlaces2(step);
		const maxPrecision = Math.max(currentValuePrecision, stepPrecision);
		const factor = 10 ** maxPrecision;
		if (!isNumberString(_value) && typeof _value !== "number" || Number.isNaN(_value)) val = clamp(startValue, minValue, max$1);
		else {
			const decrementedValue = (Math.round(Number(_value) * factor) - Math.round(step * factor)) / factor;
			val = minValue !== void 0 && decrementedValue < minValue ? minValue : decrementedValue;
		}
		const formattedValue = val.toFixed(maxPrecision);
		setValue(parseFloat(formattedValue));
		onValueChange?.({
			floatValue: parseFloat(formattedValue),
			formattedValue,
			value: formattedValue
		}, { source: "decrement" });
		setTimeout(() => adjustCursor(inputRef.current?.value.length), 0);
	};
	const handleKeyDown = (event) => {
		onKeyDown?.(event);
		if (readOnly || !withKeyboardEvents) return;
		if (event.key === "ArrowUp") {
			event.preventDefault();
			incrementRef.current?.();
		}
		if (event.key === "ArrowDown") {
			event.preventDefault();
			decrementRef.current?.();
		}
	};
	const handleKeyDownCapture = (event) => {
		onKeyDownCapture?.(event);
		if (event.key === "Backspace") {
			const input = inputRef.current;
			if (input && input.selectionStart === 0 && input.selectionStart === input.selectionEnd) {
				event.preventDefault();
				window.setTimeout(() => adjustCursor(0), 0);
			}
		}
	};
	const handleBlur = (event) => {
		let sanitizedValue = _value;
		if (clampBehavior === "blur" && typeof sanitizedValue === "number") sanitizedValue = clamp(sanitizedValue, min$1, max$1);
		if (trimLeadingZeroesOnBlur && typeof sanitizedValue === "string" && getDecimalPlaces2(sanitizedValue) < 15) sanitizedValue = clampAndSanitizeInput(sanitizedValue, max$1, min$1);
		if (_value !== sanitizedValue) setValue(sanitizedValue);
		onBlur?.(event);
	};
	assignRef(handlersRef, {
		increment: incrementRef.current,
		decrement: decrementRef.current
	});
	const onStepHandleChange = (isIncrement) => {
		if (isIncrement) incrementRef.current?.();
		else decrementRef.current?.();
		stepCountRef.current += 1;
	};
	const onStepLoop = (isIncrement) => {
		onStepHandleChange(isIncrement);
		if (shouldUseStepInterval) {
			const interval = typeof stepHoldInterval === "number" ? stepHoldInterval : stepHoldInterval(stepCountRef.current);
			onStepTimeoutRef.current = window.setTimeout(() => onStepLoop(isIncrement), interval);
		}
	};
	const onStep = (event, isIncrement) => {
		event.preventDefault();
		inputRef.current?.focus();
		onStepHandleChange(isIncrement);
		if (shouldUseStepInterval) onStepTimeoutRef.current = window.setTimeout(() => onStepLoop(isIncrement), stepHoldDelay);
	};
	const onStepDone = () => {
		if (onStepTimeoutRef.current) window.clearTimeout(onStepTimeoutRef.current);
		onStepTimeoutRef.current = null;
		stepCountRef.current = 0;
	};
	const controls = /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		...getStyles("controls"),
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(UnstyledButton, {
			...getStyles("control"),
			tabIndex: -1,
			"aria-hidden": true,
			disabled: disabled || typeof _value === "number" && max$1 !== void 0 && _value >= max$1,
			mod: { direction: "up" },
			onMouseDown: (event) => event.preventDefault(),
			onPointerDown: (event) => {
				onStep(event, true);
			},
			onPointerUp: onStepDone,
			onPointerLeave: onStepDone,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NumberInputChevron, { direction: "up" })
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(UnstyledButton, {
			...getStyles("control"),
			tabIndex: -1,
			"aria-hidden": true,
			disabled: disabled || typeof _value === "number" && min$1 !== void 0 && _value <= min$1,
			mod: { direction: "down" },
			onMouseDown: (event) => event.preventDefault(),
			onPointerDown: (event) => {
				onStep(event, false);
			},
			onPointerUp: onStepDone,
			onPointerLeave: onStepDone,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NumberInputChevron, { direction: "down" })
		})]
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputBase, {
		component: NumericFormat,
		allowNegative,
		className: clsx_default(classes$1.root, className),
		size: size$3,
		inputMode: "decimal",
		...others,
		readOnly,
		disabled,
		value: _value,
		getInputRef: useMergedRef(ref, inputRef),
		onValueChange: handleValueChange,
		rightSection: hideControls || readOnly || !canIncrement(_value) ? rightSection : rightSection || controls,
		classNames: resolvedClassNames,
		styles: resolvedStyles,
		unstyled,
		__staticSelector: "NumberInput",
		decimalScale: allowDecimal ? decimalScale : 0,
		onKeyDown: handleKeyDown,
		onKeyDownCapture: handleKeyDownCapture,
		rightSectionPointerEvents: rightSectionPointerEvents ?? (disabled ? "none" : void 0),
		rightSectionWidth: rightSectionWidth ?? `var(--ni-right-section-width-${size$3 || "sm"})`,
		allowLeadingZeros,
		allowedDecimalSeparators,
		onBlur: handleBlur,
		attributes,
		isAllowed: (val) => {
			if (clampBehavior === "strict") {
				if (isAllowed) return isAllowed(val) && isInRange(val.floatValue, min$1, max$1);
				return isInRange(val.floatValue, min$1, max$1);
			}
			return isAllowed ? isAllowed(val) : true;
		}
	});
});
NumberInput.classes = {
	...InputBase.classes,
	...classes$1
};
NumberInput.displayName = "@mantine/core/NumberInput";
var defaultProps$1 = {
	withCheckIcon: true,
	allowDeselect: true,
	checkIconPosition: "left"
};
var Select = factory((_props, ref) => {
	const props = useProps("Select", defaultProps$1, _props);
	const { classNames, styles, unstyled, vars, dropdownOpened, defaultDropdownOpened, onDropdownClose, onDropdownOpen, onFocus, onBlur, onClick, onChange, data, value, defaultValue, selectFirstOptionOnChange, onOptionSubmit, comboboxProps, readOnly, disabled, filter, limit, withScrollArea, maxDropdownHeight, size: size$3, searchable, rightSection, checkIconPosition, withCheckIcon, withAlignedLabels, nothingFoundMessage, name, form, searchValue, defaultSearchValue, onSearchChange, allowDeselect, error, rightSectionPointerEvents, id, clearable, clearButtonProps, hiddenInputProps, renderOption, onClear, autoComplete, scrollAreaProps, __defaultRightSection, __clearSection, __clearable, chevronColor, autoSelectOnBlur, attributes, ...others } = props;
	const parsedData = (0, import_react.useMemo)(() => getParsedComboboxData(data), [data]);
	const retainedSelectedOptions = (0, import_react.useRef)({});
	const optionsLockup = (0, import_react.useMemo)(() => getOptionsLockup(parsedData), [parsedData]);
	const _id = useId(id);
	const [_value, setValue, controlled] = useUncontrolled({
		value,
		defaultValue,
		finalValue: null,
		onChange
	});
	const selectedOption = typeof _value === "string" ? _value in optionsLockup ? optionsLockup[_value] : retainedSelectedOptions.current[_value] : void 0;
	const previousSelectedOption = usePrevious(selectedOption);
	const [search, setSearch, searchControlled] = useUncontrolled({
		value: searchValue,
		defaultValue: defaultSearchValue,
		finalValue: selectedOption ? selectedOption.label : "",
		onChange: onSearchChange
	});
	const combobox = useCombobox({
		opened: dropdownOpened,
		defaultOpened: defaultDropdownOpened,
		onDropdownOpen: () => {
			onDropdownOpen?.();
			combobox.updateSelectedOptionIndex("active", { scrollIntoView: true });
		},
		onDropdownClose: () => {
			onDropdownClose?.();
			setTimeout(combobox.resetSelectedOption, 0);
		}
	});
	const handleSearchChange = (value2) => {
		setSearch(value2);
		combobox.resetSelectedOption();
	};
	const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
		props,
		styles,
		classNames
	});
	(0, import_react.useEffect)(() => {
		if (selectFirstOptionOnChange) combobox.selectFirstOption();
	}, [selectFirstOptionOnChange, search]);
	(0, import_react.useEffect)(() => {
		if (value === null) handleSearchChange("");
		if (typeof value === "string" && selectedOption && (previousSelectedOption?.value !== selectedOption.value || previousSelectedOption?.label !== selectedOption.label)) handleSearchChange(selectedOption.label);
	}, [value, selectedOption]);
	(0, import_react.useEffect)(() => {
		if (!controlled && !searchControlled) handleSearchChange(typeof _value === "string" ? _value in optionsLockup ? optionsLockup[_value]?.label : retainedSelectedOptions.current[_value]?.label || "" : "");
	}, [optionsLockup, _value]);
	(0, import_react.useEffect)(() => {
		if (_value) {
			if (_value in optionsLockup) retainedSelectedOptions.current[_value] = optionsLockup[_value];
		}
	}, [optionsLockup, _value]);
	const clearButton = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.ClearButton, {
		...clearButtonProps,
		onClear: () => {
			setValue(null, null);
			handleSearchChange("");
			onClear?.();
		}
	});
	const _clearable = clearable && !!_value && !disabled && !readOnly;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Combobox, {
		store: combobox,
		__staticSelector: "Select",
		classNames: resolvedClassNames,
		styles: resolvedStyles,
		unstyled,
		readOnly,
		size: size$3,
		attributes,
		keepMounted: autoSelectOnBlur,
		onOptionSubmit: (val) => {
			onOptionSubmit?.(val);
			const optionLockup = allowDeselect ? optionsLockup[val].value === _value ? null : optionsLockup[val] : optionsLockup[val];
			const nextValue = optionLockup ? optionLockup.value : null;
			nextValue !== _value && setValue(nextValue, optionLockup);
			!controlled && handleSearchChange(typeof nextValue === "string" ? optionLockup?.label || "" : "");
			combobox.closeDropdown();
		},
		...comboboxProps,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.Target, {
			targetType: searchable ? "input" : "button",
			autoComplete,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputBase, {
				id: _id,
				ref,
				__defaultRightSection: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.Chevron, {
					size: size$3,
					error,
					unstyled,
					color: chevronColor
				}),
				__clearSection: clearButton,
				__clearable: _clearable,
				rightSection,
				rightSectionPointerEvents: rightSectionPointerEvents || "none",
				...others,
				size: size$3,
				__staticSelector: "Select",
				disabled,
				readOnly: readOnly || !searchable,
				value: search,
				onChange: (event) => {
					handleSearchChange(event.currentTarget.value);
					combobox.openDropdown();
					selectFirstOptionOnChange && combobox.selectFirstOption();
				},
				onFocus: (event) => {
					searchable && combobox.openDropdown();
					onFocus?.(event);
				},
				onBlur: (event) => {
					if (autoSelectOnBlur) combobox.clickSelectedOption();
					searchable && combobox.closeDropdown();
					const optionLockup = typeof _value === "string" && (_value in optionsLockup ? optionsLockup[_value] : retainedSelectedOptions.current[_value]);
					handleSearchChange(optionLockup ? optionLockup.label || "" : "");
					onBlur?.(event);
				},
				onClick: (event) => {
					searchable ? combobox.openDropdown() : combobox.toggleDropdown();
					onClick?.(event);
				},
				classNames: resolvedClassNames,
				styles: resolvedStyles,
				unstyled,
				pointer: !searchable,
				error,
				attributes
			})
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OptionsDropdown, {
			data: parsedData,
			hidden: readOnly || disabled,
			filter,
			search,
			limit,
			hiddenWhenEmpty: !nothingFoundMessage,
			withScrollArea,
			maxDropdownHeight,
			filterOptions: !!searchable && selectedOption?.label !== search,
			value: _value,
			checkIconPosition,
			withCheckIcon,
			withAlignedLabels,
			nothingFoundMessage,
			unstyled,
			labelId: others.label ? `${_id}-label` : void 0,
			"aria-label": others.label ? void 0 : others["aria-label"],
			renderOption,
			scrollAreaProps
		})]
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combobox.HiddenInput, {
		value: _value,
		name,
		form,
		disabled,
		...hiddenInputProps
	})] });
});
Select.classes = {
	...InputBase.classes,
	...Combobox.classes
};
Select.displayName = "@mantine/core/Select";
var SwitchGroupContext = (0, import_react.createContext)(null);
var SwitchGroupProvider = SwitchGroupContext.Provider;
var useSwitchGroupContext = () => (0, import_react.useContext)(SwitchGroupContext);
var SwitchGroup = factory((props, ref) => {
	const { value, defaultValue, onChange, size: size$3, wrapperProps, children, readOnly, disabled, ...others } = useProps("SwitchGroup", null, props);
	const [_value, setValue] = useUncontrolled({
		value,
		defaultValue,
		finalValue: [],
		onChange
	});
	const handleChange = (event) => {
		const itemValue = event.currentTarget.value;
		!readOnly && setValue(_value.includes(itemValue) ? _value.filter((item) => item !== itemValue) : [..._value, itemValue]);
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SwitchGroupProvider, {
		value: {
			value: _value,
			onChange: handleChange,
			size: size$3,
			disabled
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input.Wrapper, {
			size: size$3,
			ref,
			...wrapperProps,
			...others,
			labelElement: "div",
			__staticSelector: "SwitchGroup",
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputsGroupFieldset, {
				role: "group",
				children
			})
		})
	});
});
SwitchGroup.classes = Input.Wrapper.classes;
SwitchGroup.displayName = "@mantine/core/SwitchGroup";
var classes = {
	"root": "m_5f93f3bb",
	"input": "m_926b4011",
	"track": "m_9307d992",
	"thumb": "m_93039a1d",
	"trackLabel": "m_8277e082"
};
var defaultProps = {
	labelPosition: "right",
	withThumbIndicator: true
};
var varsResolver = createVarsResolver((theme$1, { radius, color, size: size$3 }) => ({ root: {
	"--switch-radius": radius === void 0 ? void 0 : getRadius(radius),
	"--switch-height": getSize(size$3, "switch-height"),
	"--switch-width": getSize(size$3, "switch-width"),
	"--switch-thumb-size": getSize(size$3, "switch-thumb-size"),
	"--switch-label-font-size": getSize(size$3, "switch-label-font-size"),
	"--switch-track-label-padding": getSize(size$3, "switch-track-label-padding"),
	"--switch-color": color ? getThemeColor(color, theme$1) : void 0
} }));
var Switch = factory((_props, ref) => {
	const props = useProps("Switch", defaultProps, _props);
	const { classNames, className, style: style$1, styles, unstyled, vars, color, label, offLabel, onLabel, id, size: size$3, radius, wrapperProps, thumbIcon, checked, defaultChecked, onChange, labelPosition, description, error, disabled, variant, rootRef, mod, withThumbIndicator, attributes, ...others } = props;
	const ctx = useSwitchGroupContext();
	const _size = size$3 || ctx?.size;
	const getStyles = useStyles({
		name: "Switch",
		props,
		classes,
		className,
		style: style$1,
		classNames,
		styles,
		unstyled,
		attributes,
		vars,
		varsResolver
	});
	const { styleProps, rest } = extractStyleProps(others);
	const uuid = useId(id);
	const withContextProps = {
		checked: ctx?.value.includes(rest.value) ?? checked,
		onChange: (event) => {
			ctx?.onChange(event);
			onChange?.(event);
		},
		disabled: ctx?.disabled ?? disabled
	};
	const [_checked, handleChange] = useUncontrolled({
		value: withContextProps.checked ?? checked,
		defaultValue: defaultChecked,
		finalValue: false
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(InlineInput, {
		...getStyles("root"),
		__staticSelector: "Switch",
		__stylesApiProps: props,
		id: uuid,
		size: _size,
		labelPosition,
		label,
		description,
		error,
		disabled: withContextProps.disabled,
		bodyElement: "label",
		labelElement: "span",
		classNames,
		styles,
		unstyled,
		"data-checked": withContextProps.checked,
		variant,
		ref: rootRef,
		mod,
		...styleProps,
		...wrapperProps,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
			...rest,
			...withContextProps,
			checked: _checked,
			"data-checked": withContextProps.checked,
			onChange: (event) => {
				withContextProps.onChange?.(event);
				handleChange(event.currentTarget.checked);
			},
			id: uuid,
			ref,
			type: "checkbox",
			role: "switch",
			...getStyles("input")
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Box, {
			"aria-hidden": "true",
			component: "span",
			mod: {
				error,
				"label-position": labelPosition,
				"without-labels": !onLabel && !offLabel
			},
			...getStyles("track"),
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Box, {
				component: "span",
				mod: {
					"reduce-motion": true,
					"with-thumb-indicator": withThumbIndicator && !thumbIcon
				},
				...getStyles("thumb"),
				children: thumbIcon
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				...getStyles("trackLabel"),
				children: _checked ? onLabel : offLabel
			})]
		})]
	});
});
Switch.classes = {
	...classes,
	...InlineInputClasses
};
Switch.displayName = "@mantine/core/Switch";
Switch.Group = SwitchGroup;
var TextInput = factory((props, ref) => {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(InputBase, {
		component: "input",
		ref,
		...useProps("TextInput", null, props),
		__staticSelector: "TextInput"
	});
});
TextInput.classes = InputBase.classes;
TextInput.displayName = "@mantine/core/TextInput";
function SelectArgument(props) {
	const data = (0, import_react.useMemo)(() => props.options.map((c) => ({
		label: c.name,
		value: c.value
	})), [props]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Select, {
		allowDeselect: false,
		maxLength: 30,
		searchable: true,
		label: props.label,
		description: props.description,
		data,
		value: props.value ?? props.defaultValue,
		onChange: (value) => props.onChange(value ?? props.options[0].value),
		style: { width: "60%" }
	});
}
function ArgsTileColumn(props) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: props.args.map((_, idx) => {
		const info = props.argsInfo[idx];
		const argumentName = props.category + " | " + info.name;
		const argumentKey = `${info.id}`;
		if (info.type === EServerArgumentType.STRING) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TextInput, {
			label: argumentName,
			description: info.description,
			defaultValue: info.default,
			value: props.args[idx].value ?? info.default,
			onChange: (e) => props.onArgumentUpdated(idx, e.currentTarget.value),
			style: { width: "60%" }
		}, argumentKey);
		else if (info.type === EServerArgumentType.INT) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(NumberInput, {
			label: argumentName,
			description: info.description,
			defaultValue: info.default,
			value: props.args[idx].value ?? info.default,
			onChange: (e) => props.onArgumentUpdated(idx, typeof e === "string" ? parseInt(e) : e),
			style: { width: "60%" },
			allowDecimal: false
		}, argumentKey);
		else if (info.type === EServerArgumentType.BOOLEAN) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Switch, {
			label: argumentName,
			description: info.description,
			defaultChecked: info.default,
			checked: props.args[idx].value ?? info.default,
			onChange: (e) => props.onArgumentUpdated(idx, e.currentTarget.checked),
			style: { width: "60%" },
			labelPosition: "left"
		}, argumentKey);
		else if (info.type === EServerArgumentType.SELECT) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectArgument, {
			label: argumentName,
			description: info.description,
			defaultValue: info.default,
			value: props.args[idx].value ?? info.default,
			options: info.options,
			onChange: (a) => {
				props.onArgumentUpdated(idx, a);
			}
		}, argumentKey);
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {});
	}) });
}
function PluginSelect(props) {
	const data = (0, import_react.useMemo)(() => props.items.map((c, idx) => ({
		label: c.name,
		value: idx.toString()
	})), [props]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Select, {
		label: props.name,
		description: props.selected != -1 && props.selected < props.items.length ? props.items[props.selected].description : void 0,
		data,
		value: props.selected.toString(),
		onChange: (value) => props.onChange(parseInt(value ?? "0")),
		style: { width: "60%" }
	});
}
function download(filename, text) {
	const element = document.createElement("a");
	element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(text));
	element.setAttribute("download", filename);
	element.style.display = "none";
	document.body.appendChild(element);
	element.click();
	document.body.removeChild(element);
}
function ImageSettings() {
	const operation = useAppStore((s) => s.operation);
	const detectorIndex = useAppStore((s) => s.detectorIndex);
	const detectors = useAppStore((s) => s.detectors);
	const segmenterIndex = useAppStore((s) => s.segmenterIndex);
	const segmenters = useAppStore((s) => s.segmenters);
	const translatorIndex = useAppStore((s) => s.translatorIndex);
	const translators = useAppStore((s) => s.translators);
	const ocrIndex = useAppStore((s) => s.ocrIndex);
	const ocrs = useAppStore((s) => s.ocrs);
	const drawerIndex = useAppStore((s) => s.drawerIndex);
	const drawers = useAppStore((s) => s.drawers);
	const cleanerIndex = useAppStore((s) => s.cleanerIndex);
	const cleaners = useAppStore((s) => s.cleaners);
	const imageFit = useAppStore((s) => s.imageFit);
	const ocrArgs = useAppStore((s) => s.ocrArgs);
	const detectorArgs = useAppStore((s) => s.detectorArgs);
	const segmenterArgs = useAppStore((s) => s.segmenterArgs);
	const translatorArgs = useAppStore((s) => s.translatorArgs);
	const drawerArgs = useAppStore((s) => s.drawerArgs);
	const cleanerArgs = useAppStore((s) => s.cleanerArgs);
	const setImageAddress = useAppStore((s) => s.setImageAddress);
	const setImageFit = useAppStore((s) => s.setImageFit);
	const setSelectedOperation = useAppStore((s) => s.setSelectedOperation);
	const setCleanerIndex = useAppStore((s) => s.setCleanerIndex);
	const setCleanerArgument = useAppStore((s) => s.setCleanerArgument);
	const setDetectorIndex = useAppStore((s) => s.setDetectorIndex);
	const setDetectorArgument = useAppStore((s) => s.setDetectorArgument);
	const setSegmenterIndex = useAppStore((s) => s.setSegmenterIndex);
	const setSegmenterArgument = useAppStore((s) => s.setSegmenterArgument);
	const setTranslatorIndex = useAppStore((s) => s.setTranslatorIndex);
	const setTranslatorArgument = useAppStore((s) => s.setTranslatorArgument);
	const setDrawerIndex = useAppStore((s) => s.setDrawerIndex);
	const setDrawerArgument = useAppStore((s) => s.setDrawerArgument);
	const setOcrIndex = useAppStore((s) => s.setOcrIndex);
	const setOcrArgument = useAppStore((s) => s.setOcrArgument);
	const performCurrentOperation = useAppStore((s) => s.performCurrentOperation);
	const loadConfig = useAppStore((s) => s.loadConfig);
	const exportConfig = useAppStore((s) => s.exportConfig);
	const imageInputRef = (0, import_react.useRef)(null);
	const configInputRef = (0, import_react.useRef)(null);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: "tile",
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(TileRow, {
				name: "Upload Image",
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
						ref: imageInputRef,
						type: "file",
						onChange: (e) => {
							const result = e.target.files?.item(0);
							if (result instanceof Blob) setImageAddress(URL.createObjectURL(result));
						},
						style: { display: "none" },
						accept: "image/*"
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
						ref: configInputRef,
						type: "file",
						onChange: (e) => {
							if (e.target.files !== null) {
								loadConfig(e.target.files[0]);
								e.target.value = "";
							}
						},
						style: { display: "none" },
						accept: ".yaml,.yml,application/x-yaml"
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						style: {
							display: "flex",
							flexDirection: "column",
							width: "100%",
							height: "100%",
							gap: "20px"
						},
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Flex, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
							fullWidth: true,
							className: "upload",
							onClick: () => imageInputRef.current?.click(),
							children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FaFileUpload, {})
						}) }), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Flex, {
							gap: "lg",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
								fullWidth: true,
								onClick: () => configInputRef.current?.click(),
								children: "Load Config"
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
								fullWidth: true,
								onClick: () => {
									download("config.yaml", exportConfig());
								},
								children: "Save Config"
							})]
						})]
					})
				]
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Select, {
				allowDeselect: false,
				label: "Image Fit",
				data: [{
					label: "Fit To Page",
					value: EImageFit.FIT_TO_PAGE.toString()
				}, {
					label: "Scroll",
					value: EImageFit.SCROLL.toString()
				}],
				value: imageFit.toString(),
				onChange: (value) => {
					setImageFit(parseInt(value ?? "0"));
				},
				style: { width: "60%" }
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Select, {
				allowDeselect: false,
				label: "Operation",
				data: [{
					label: "Clean",
					value: EAppOperation.CLEANING.toString()
				}, {
					label: "Translate",
					value: EAppOperation.TRANSLATION.toString()
				}],
				value: operation.toString(),
				onChange: (value) => {
					setSelectedOperation(parseInt(value ?? "0"));
				},
				style: { width: "60%" }
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(PluginSelect, {
				name: "Detector",
				selected: detectorIndex,
				items: detectors,
				onChange: setDetectorIndex
			}),
			detectorArgs.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArgsTileColumn, {
				category: "Detector",
				args: detectorArgs,
				argsInfo: detectors[detectorIndex].args,
				onArgumentUpdated: (idx, val) => setDetectorArgument(idx, val)
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(PluginSelect, {
				name: "Segmenter",
				selected: segmenterIndex,
				items: segmenters,
				onChange: setSegmenterIndex
			}),
			segmenterArgs.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArgsTileColumn, {
				category: "Segmenter",
				args: segmenterArgs,
				argsInfo: segmenters[segmenterIndex].args,
				onArgumentUpdated: (idx, val) => setSegmenterArgument(idx, val)
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(PluginSelect, {
				name: "Cleaner",
				items: cleaners,
				selected: cleanerIndex,
				onChange: setCleanerIndex
			}),
			cleanerArgs.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArgsTileColumn, {
				category: "Cleaner",
				args: cleanerArgs,
				argsInfo: cleaners[cleanerIndex].args,
				onArgumentUpdated: (idx, val) => setCleanerArgument(idx, val)
			}),
			operation === EAppOperation.TRANSLATION && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(PluginSelect, {
					name: "Ocr",
					items: ocrs,
					selected: ocrIndex,
					onChange: setOcrIndex
				}),
				ocrArgs.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArgsTileColumn, {
					category: "Ocr",
					args: ocrArgs,
					argsInfo: ocrs[ocrIndex].args,
					onArgumentUpdated: (idx, val) => setOcrArgument(idx, val)
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(PluginSelect, {
					name: "Translator",
					items: translators,
					selected: translatorIndex,
					onChange: setTranslatorIndex
				}),
				translatorArgs.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArgsTileColumn, {
					category: "Translator",
					args: translatorArgs,
					argsInfo: translators[translatorIndex].args,
					onArgumentUpdated: (idx, val) => setTranslatorArgument(idx, val)
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(PluginSelect, {
					name: "Drawer",
					items: drawers,
					selected: drawerIndex,
					onChange: setDrawerIndex
				}),
				drawerArgs.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArgsTileColumn, {
					category: "Drawer",
					args: drawerArgs,
					argsInfo: drawers[drawerIndex].args,
					onArgumentUpdated: (idx, val) => setDrawerArgument(idx, val)
				})
			] }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "tile-row",
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "tile-row-content",
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
						fullWidth: true,
						onClick: () => {
							performCurrentOperation();
						},
						children: operation === EAppOperation.CLEANING ? "Clean" : "Translate"
					})
				})
			})
		]
	});
}
var theme = createTheme({});
function App() {
	(0, import_react.useEffect)(() => {
		useAppStore.getState().getServerInfo().catch(console.error);
	}, []);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MantineProvider, {
		theme,
		forceColorScheme: "dark",
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: "app",
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ImageSettings, {}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ImageConverter, {})]
		})
	});
}
var App_default = App;
(0, import_client.createRoot)(document.getElementById("root")).render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.StrictMode, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(App_default, {}) }));

//# sourceMappingURL=index-BX-V1oME.js.map